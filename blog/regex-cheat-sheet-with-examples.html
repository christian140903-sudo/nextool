<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
    <link rel="icon" type="image/svg+xml" href="/img/favicon.svg">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Regex Cheat Sheet with Live Examples (2026) | ANIMA</title>
<meta name="description" content="Complete regex cheat sheet with tested examples for every pattern. Covers anchors, quantifiers, groups, lookaheads, and real-world patterns for emails, URLs, and more.">
<meta name="keywords" content="regex cheat sheet, regular expression examples, regex tutorial, regex patterns, regex reference, regex guide 2026, regex tester online">
<meta name="author" content="Christian Bucher">
<meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large">
<link rel="canonical" href="https://nextool.app/blog/regex-cheat-sheet-with-examples.html">

<!-- Open Graph -->
<meta property="og:type" content="article">
<meta property="og:title" content="Regex Cheat Sheet with Live Examples (2026)">
<meta property="og:description" content="Every regex pattern you need, with tested examples. Anchors, quantifiers, groups, lookaheads, and real-world patterns for emails, URLs, IPs, and more.">
<meta property="og:url" content="https://nextool.app/blog/regex-cheat-sheet-with-examples.html">
<meta property="og:site_name" content="ANIMA by Christian Bucher">
<meta property="og:image" content="https://nextool.app/assets/og-blog-regex-cheat-sheet-2026.png">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<meta property="article:published_time" content="2026-02-13T10:00:00Z">
<meta property="article:modified_time" content="2026-02-13T10:00:00Z">
<meta property="article:author" content="Christian Bucher">
<meta property="article:section" content="Developer Tools">
<meta property="article:tag" content="Regex">
<meta property="article:tag" content="Developer Tools">
<meta property="article:tag" content="Reference">

<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Regex Cheat Sheet with Live Examples (2026)">
<meta name="twitter:description" content="Every regex pattern you need, with tested examples. Bookmark this reference and test patterns live.">
<meta name="twitter:image" content="https://nextool.app/assets/og-blog-regex-cheat-sheet-2026.png">

<!-- JSON-LD: Article -->
<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "Regex Cheat Sheet with Live Examples (2026)",
    "description": "Complete regex cheat sheet with tested examples for every pattern. Covers anchors, quantifiers, groups, lookaheads, and real-world patterns.",
    "image": "https://nextool.app/assets/og-blog-regex-cheat-sheet-2026.png",
    "author": {"@type": "Organization", "name": "Christian Bucher", "url": "https://nextool.app"},
    "publisher": {"@type": "Organization", "name": "ANIMA", "logo": {"@type": "ImageObject", "url": "https://nextool.app/images/logo.png"}},
    "datePublished": "2026-02-13T10:00:00Z",
    "dateModified": "2026-02-13T10:00:00Z",
    "mainEntityOfPage": {"@type": "WebPage", "@id": "https://nextool.app/blog/regex-cheat-sheet-with-examples.html"},
    "keywords": "regex cheat sheet, regular expression examples, regex tutorial, regex patterns",
    "wordCount": 2600,
    "articleSection": "Developer Tools"
}
</script>

<!-- JSON-LD: BreadcrumbList -->
<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [
        {"@type": "ListItem", "position": 1, "name": "Home", "item": "https://nextool.app"},
        {"@type": "ListItem", "position": 2, "name": "Blog", "item": "https://nextool.app/blog/"},
        {"@type": "ListItem", "position": 3, "name": "Regex Cheat Sheet with Examples", "item": "https://nextool.app/blog/regex-cheat-sheet-with-examples.html"}
    ]
}
</script>

<!-- JSON-LD: FAQPage -->
<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "FAQPage",
    "mainEntity": [
        {
            "@type": "Question",
            "name": "What is the difference between .* and .*? in regex?",
            "acceptedAnswer": {
                "@type": "Answer",
                "text": ".* is a greedy quantifier -- it matches as many characters as possible. .*? is a lazy (non-greedy) quantifier -- it matches as few characters as possible. For example, given the string '<b>hello</b><b>world</b>', the pattern '<b>(.*)</b>' greedily matches 'hello</b><b>world', capturing everything between the first <b> and the last </b>. The pattern '<b>(.*?)</b>' lazily matches 'hello', stopping at the first </b>. Use lazy quantifiers when you want the shortest match."
            }
        },
        {
            "@type": "Question",
            "name": "How do I match an email address with regex?",
            "acceptedAnswer": {
                "@type": "Answer",
                "text": "A practical email regex for input validation is: ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$. This matches most real-world email addresses. The RFC 5322-compliant regex is thousands of characters long and rarely used in practice because it allows syntax that no modern email provider supports. For production validation, use this simple pattern for client-side feedback and verify with an actual email delivery attempt on the server side."
            }
        },
        {
            "@type": "Question",
            "name": "What is a lookahead in regex and when should I use it?",
            "acceptedAnswer": {
                "@type": "Answer",
                "text": "A lookahead is a zero-width assertion that checks if a pattern exists ahead of the current position without consuming characters. Positive lookahead (?=pattern) asserts that pattern follows. Negative lookahead (?!pattern) asserts that pattern does NOT follow. Common use cases: password validation (must contain a digit: (?=.*\\d)), matching a word only when followed by specific context, and complex find-and-replace operations where you need to match patterns conditionally. You can test lookaheads interactively in ANIMA's free Regex Tester."
            }
        },
        {
            "@type": "Question",
            "name": "What is the best free regex tester online in 2026?",
            "acceptedAnswer": {
                "@type": "Answer",
                "text": "ANIMA's Regex Tester is one of the best free options in 2026. It provides real-time match highlighting, group extraction, flag toggles (global, case-insensitive, multiline, dotAll, unicode), and match count -- all in a clean, ad-free interface that runs entirely in your browser. It also includes a quick reference panel for common patterns. For building regex visually, the ANIMA Regex Builder provides a step-by-step interface that constructs patterns from components."
            }
        },
        {
            "@type": "Question",
            "name": "How do I make regex case-insensitive?",
            "acceptedAnswer": {
                "@type": "Answer",
                "text": "Use the 'i' flag. In JavaScript: /pattern/i or new RegExp('pattern', 'i'). In Python: re.compile('pattern', re.IGNORECASE) or use the inline flag (?i) at the start of the pattern. In most regex testers, there is a checkbox or toggle for case-insensitive mode. The 'i' flag makes all alphabetic matches ignore case, so /hello/i matches 'hello', 'Hello', 'HELLO', and 'hElLo'."
            }
        }
    ]
}
</script>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">

<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --bg: #050508;
  --surface: #111118;
  --surface-2: #1a1a24;
  --surface-3: #222233;
  --primary: #00d4ff;
  --primary-hover: #818cf8;
  --accent: #a855f7;
  --pink: #ec4899;
  --text: #e2e8f0;
  --text-muted: #94a3b8;
  --text-dim: #64748b;
  --border: #1e1e2e;
  --success: #22c55e;
  --warning: #f59e0b;
  --radius: 12px;
  --radius-lg: 16px;
  --shadow: 0 4px 24px rgba(0,0,0,0.4);
}

html { scroll-behavior: smooth; }

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  background: var(--bg);
  color: var(--text);
  line-height: 1.7;
  -webkit-font-smoothing: antialiased;
}

a { color: var(--primary); text-decoration: none; transition: color 0.2s; }
a:hover { color: var(--primary-hover); }

.navbar {
  position: fixed; top: 0; left: 0; right: 0; z-index: 1000;
  background: rgba(5,5,8,0.85);
  backdrop-filter: blur(20px);
  border-bottom: 1px solid var(--border);
  padding: 0 2rem;
  height: 64px;
  display: flex; align-items: center; justify-content: space-between;
}
.nav-logo {
  font-size: 1.4rem; font-weight: 800; color: #fff;
  background: linear-gradient(135deg, var(--primary), var(--accent));
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}
.nav-links { display: flex; align-items: center; gap: 1.5rem; list-style: none; }
.nav-links a { color: var(--text-muted); font-size: 0.9rem; font-weight: 500; transition: color 0.2s; }
.nav-links a:hover { color: #fff; }
.nav-cta {
  background: var(--primary); color: #fff !important; padding: 0.5rem 1.2rem;
  border-radius: 8px; font-weight: 600; font-size: 0.85rem;
  transition: background 0.2s, transform 0.2s;
}
.nav-cta:hover { background: var(--primary-hover); transform: translateY(-1px); }
.nav-mobile-toggle { display: none; background: none; border: none; color: #fff; font-size: 1.5rem; cursor: pointer; }

.article-hero {
  padding: 8rem 2rem 3rem;
  max-width: 900px; margin: 0 auto; text-align: center;
}
.article-meta {
  display: flex; align-items: center; justify-content: center; gap: 1rem;
  margin-bottom: 1.5rem; flex-wrap: wrap;
}
.article-category {
  background: linear-gradient(135deg, var(--primary), var(--accent));
  color: #fff; padding: 0.3rem 0.9rem; border-radius: 20px;
  font-size: 0.75rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em;
}
.article-date, .article-reading-time { color: var(--text-dim); font-size: 0.85rem; }
.article-hero h1 {
  font-size: clamp(2rem, 5vw, 3rem); font-weight: 900; line-height: 1.15;
  color: #fff; margin-bottom: 1.2rem;
}
.article-hero h1 span {
  background: linear-gradient(135deg, var(--primary), var(--pink));
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}
.article-subtitle { color: var(--text-muted); font-size: 1.15rem; max-width: 680px; margin: 0 auto; }

.article-layout {
  display: grid;
  grid-template-columns: 240px 1fr;
  gap: 3rem;
  max-width: 1100px;
  margin: 0 auto;
  padding: 0 2rem 4rem;
  align-items: start;
}

.toc-sidebar {
  position: sticky; top: 84px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 1.2rem;
}
.toc-title {
  font-size: 0.75rem; font-weight: 700; text-transform: uppercase;
  letter-spacing: 0.08em; color: var(--text-dim); margin-bottom: 0.8rem;
}
.toc-list { list-style: none; }
.toc-list li { margin-bottom: 0.4rem; }
.toc-list a {
  color: var(--text-muted); font-size: 0.8rem; display: block;
  padding: 0.25rem 0.5rem; border-radius: 6px; border-left: 2px solid transparent;
  transition: all 0.2s;
}
.toc-list a:hover, .toc-list a.active {
  color: var(--primary); border-left-color: var(--primary); background: rgba(0,212,255,0.06);
}

.article-content { max-width: 720px; }
.article-content h2 {
  font-size: 1.6rem; font-weight: 800; color: #fff;
  margin: 2.5rem 0 1rem; padding-top: 1rem;
  border-top: 1px solid var(--border);
}
.article-content h2:first-of-type { border-top: none; padding-top: 0; margin-top: 0; }
.article-content h3 {
  font-size: 1.2rem; font-weight: 700; color: #fff; margin: 2rem 0 0.8rem;
}
.article-content p { margin-bottom: 1.2rem; color: var(--text); }
.article-content ul, .article-content ol {
  margin: 0 0 1.5rem 1.2rem; color: var(--text);
}
.article-content li { margin-bottom: 0.5rem; }
.article-content strong { color: #fff; }
.article-content blockquote {
  border-left: 3px solid var(--primary); padding: 1rem 1.5rem;
  background: var(--surface); border-radius: 0 var(--radius) var(--radius) 0;
  margin: 1.5rem 0; color: var(--text-muted); font-style: italic;
}
.article-content code {
  background: var(--surface-2); padding: 0.15rem 0.45rem; border-radius: 4px;
  font-size: 0.9em; color: var(--pink); font-family: 'JetBrains Mono', monospace;
}
.article-content pre {
  background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius);
  padding: 1.2rem; overflow-x: auto; margin: 1.5rem 0;
}
.article-content pre code { background: none; padding: 0; color: var(--text); }

.key-takeaway {
  background: linear-gradient(135deg, rgba(34,197,94,0.08), rgba(0,212,255,0.05));
  border: 1px solid rgba(34,197,94,0.2);
  border-radius: var(--radius);
  padding: 1.2rem 1.5rem;
  margin: 1.5rem 0;
}
.key-takeaway-label {
  font-size: 0.72rem; font-weight: 700; text-transform: uppercase;
  letter-spacing: 0.08em; color: var(--success); margin-bottom: 0.4rem;
}

.cta-box {
  background: linear-gradient(135deg, rgba(0,212,255,0.1), rgba(168,85,247,0.08));
  border: 1px solid rgba(0,212,255,0.25);
  border-radius: var(--radius-lg);
  padding: 2rem;
  margin: 2rem 0;
  text-align: center;
}
.cta-box h3 { color: #fff; font-size: 1.3rem; font-weight: 800; margin-bottom: 0.6rem; }
.cta-box p { color: var(--text-muted); margin-bottom: 1.2rem; max-width: 500px; margin-left: auto; margin-right: auto; }
.cta-button {
  display: inline-block;
  background: linear-gradient(135deg, var(--primary), var(--accent));
  color: #fff; font-weight: 700; padding: 0.75rem 2rem;
  border-radius: 10px; font-size: 0.95rem;
  transition: transform 0.2s, box-shadow 0.2s;
}
.cta-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 30px rgba(0,212,255,0.35);
  color: #fff;
}

.comparison-table-wrap {
  overflow-x: auto; margin: 1.5rem 0; border-radius: var(--radius);
  border: 1px solid var(--border);
}
.comparison-table {
  width: 100%; border-collapse: collapse; font-size: 0.85rem;
}
.comparison-table th {
  background: var(--surface-2); color: #fff; font-weight: 700;
  padding: 0.8rem 1rem; text-align: left; white-space: nowrap;
}
.comparison-table td {
  padding: 0.8rem 1rem; border-top: 1px solid var(--border); color: var(--text-muted);
}
.comparison-table tr:hover td { background: rgba(0,212,255,0.04); }
.comparison-table td code {
  background: var(--surface-3); padding: 0.1rem 0.4rem; border-radius: 3px;
  font-size: 0.85em; color: var(--pink); font-family: 'JetBrains Mono', monospace;
}

.author-box {
  display: flex; gap: 1.2rem; align-items: center;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-lg);
  padding: 1.5rem; margin: 2.5rem 0;
}
.author-avatar {
  width: 64px; height: 64px; border-radius: 50%;
  background: linear-gradient(135deg, var(--primary), var(--accent));
  display: flex; align-items: center; justify-content: center;
  font-size: 1.5rem; font-weight: 800; color: #fff; flex-shrink: 0;
}
.author-info h4 { color: #fff; font-weight: 700; margin-bottom: 0.2rem; }
.author-info p { color: var(--text-muted); font-size: 0.85rem; line-height: 1.5; }

.related-articles { margin: 3rem 0; }
.related-articles h3 { color: #fff; font-weight: 800; font-size: 1.3rem; margin-bottom: 1.2rem; }
.related-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 1.2rem; }
.related-card {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 1.2rem;
  transition: border-color 0.3s, transform 0.2s;
}
.related-card:hover { border-color: var(--primary); transform: translateY(-2px); }
.related-card-cat {
  font-size: 0.7rem; text-transform: uppercase; font-weight: 700;
  letter-spacing: 0.05em; color: var(--accent); margin-bottom: 0.5rem;
}
.related-card h4 { color: #fff; font-weight: 700; font-size: 1rem; margin-bottom: 0.4rem; line-height: 1.4; }
.related-card p { color: var(--text-dim); font-size: 0.82rem; }

.site-footer {
  border-top: 1px solid var(--border);
  background: var(--surface);
  padding: 3rem 2rem 1.5rem;
}
.footer-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  gap: 2rem;
  max-width: 1100px;
  margin: 0 auto 2rem;
}
.footer-col h4 {
  color: #fff; font-weight: 700; font-size: 0.85rem; margin-bottom: 0.8rem;
  text-transform: uppercase; letter-spacing: 0.06em;
}
.footer-col a { display: block; color: var(--text-dim); font-size: 0.85rem; margin-bottom: 0.4rem; }
.footer-col a:hover { color: var(--primary); }
.footer-brand {
  font-size: 1.2rem; font-weight: 800;
  background: linear-gradient(135deg, var(--primary), var(--accent));
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  margin-bottom: 0.5rem;
}
.footer-brand-desc { color: var(--text-dim); font-size: 0.82rem; line-height: 1.5; }
.footer-bottom {
  text-align: center; padding-top: 1.5rem;
  border-top: 1px solid var(--border); color: var(--text-dim); font-size: 0.8rem;
}

@media (max-width: 900px) {
  .article-layout { grid-template-columns: 1fr; }
  .toc-sidebar { position: static; margin-bottom: 1rem; }
}
@media (max-width: 640px) {
  .nav-links { display: none; }
  .nav-mobile-toggle { display: block; }
  .article-hero { padding: 6rem 1rem 2rem; }
  .article-layout { padding: 0 1rem 3rem; }
  .author-box { flex-direction: column; text-align: center; }
  .comparison-table { font-size: 0.78rem; }
  .comparison-table th, .comparison-table td { padding: 0.6rem 0.7rem; }
}
</style>
</head>
<body>

<!-- NAVBAR -->
<nav class="navbar">
  <a href="/" class="nav-logo">ANIMA</a>
  <ul class="nav-links">
    <li><a href="/">Home</a></li>
    <li><a href="/free-tools/">Tools</a></li>
    <li><a href="/free-tools/">Free Tools</a></li>
    <li><a href="https://github.com/christian140903-sudo/nextool">Pro</a></li>
    <li><a href="/blog/">Blog</a></li>
    <li><a href="https://github.com/christian140903-sudo/nextool" class="nav-cta">ANIMA</a></li>
  </ul>
  <button class="nav-mobile-toggle" aria-label="Menu">&#9776;</button>
</nav>

<!-- HERO -->
<header class="article-hero">
  <div class="article-meta">
    <span class="article-category">Developer Tools</span>
    <span class="article-date">February 13, 2026</span>
    <span class="article-reading-time">14 min read</span>
  </div>
  <h1>Regex Cheat Sheet <span>with Live Examples</span> (2026)</h1>
  <p class="article-subtitle">A complete, bookmark-worthy regex reference with tested examples for every pattern. Copy the patterns, test them live in our free regex tester, and stop Googling the same syntax.</p>
</header>

<!-- ARTICLE LAYOUT -->
<div class="article-layout">

  <!-- TOC SIDEBAR -->
  <aside class="toc-sidebar">
    <div class="toc-title">Table of Contents</div>
    <ul class="toc-list">
      <li><a href="#basics">Basic Syntax</a></li>
      <li><a href="#character-classes">Character Classes</a></li>
      <li><a href="#anchors">Anchors &amp; Boundaries</a></li>
      <li><a href="#quantifiers">Quantifiers</a></li>
      <li><a href="#groups">Groups &amp; Capturing</a></li>
      <li><a href="#lookaround">Lookahead &amp; Lookbehind</a></li>
      <li><a href="#flags">Flags</a></li>
      <li><a href="#real-world">Real-World Patterns</a></li>
      <li><a href="#js-methods">JavaScript Methods</a></li>
      <li><a href="#common-mistakes">Common Mistakes</a></li>
      <li><a href="#faq">FAQ</a></li>
    </ul>
  </aside>

  <!-- ARTICLE CONTENT -->
  <article class="article-content">

    <h2 id="basics">Basic Syntax: The Building Blocks</h2>

    <p>Every regex pattern is built from a small set of fundamental syntax elements. If you know these, you can read any regular expression. Test each pattern live in the <a href="/free-tools/regex-tester.html">ANIMA Regex Tester</a> as you read.</p>

    <div class="comparison-table-wrap">
      <table class="comparison-table">
        <thead>
          <tr>
            <th>Pattern</th>
            <th>Meaning</th>
            <th>Example</th>
            <th>Matches</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>.</code></td>
            <td>Any character (except newline)</td>
            <td><code>h.t</code></td>
            <td>"hat", "hot", "h t"</td>
          </tr>
          <tr>
            <td><code>\</code></td>
            <td>Escape special character</td>
            <td><code>\.</code></td>
            <td>Literal "."</td>
          </tr>
          <tr>
            <td><code>|</code></td>
            <td>OR (alternation)</td>
            <td><code>cat|dog</code></td>
            <td>"cat" or "dog"</td>
          </tr>
          <tr>
            <td><code>[]</code></td>
            <td>Character set</td>
            <td><code>[aeiou]</code></td>
            <td>Any vowel</td>
          </tr>
          <tr>
            <td><code>[^]</code></td>
            <td>Negated character set</td>
            <td><code>[^0-9]</code></td>
            <td>Any non-digit</td>
          </tr>
          <tr>
            <td><code>-</code></td>
            <td>Range (inside [])</td>
            <td><code>[a-z]</code></td>
            <td>Any lowercase letter</td>
          </tr>
        </tbody>
      </table>
    </div>

    <h2 id="character-classes">Character Classes</h2>

    <p>Character classes are shortcuts for common character sets. They save typing and make patterns more readable.</p>

    <div class="comparison-table-wrap">
      <table class="comparison-table">
        <thead>
          <tr>
            <th>Pattern</th>
            <th>Equivalent</th>
            <th>Meaning</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>\d</code></td>
            <td><code>[0-9]</code></td>
            <td>Any digit</td>
          </tr>
          <tr>
            <td><code>\D</code></td>
            <td><code>[^0-9]</code></td>
            <td>Any non-digit</td>
          </tr>
          <tr>
            <td><code>\w</code></td>
            <td><code>[a-zA-Z0-9_]</code></td>
            <td>Word character (letter, digit, underscore)</td>
          </tr>
          <tr>
            <td><code>\W</code></td>
            <td><code>[^a-zA-Z0-9_]</code></td>
            <td>Non-word character</td>
          </tr>
          <tr>
            <td><code>\s</code></td>
            <td><code>[ \t\n\r\f\v]</code></td>
            <td>Whitespace (space, tab, newline)</td>
          </tr>
          <tr>
            <td><code>\S</code></td>
            <td><code>[^ \t\n\r\f\v]</code></td>
            <td>Non-whitespace</td>
          </tr>
        </tbody>
      </table>
    </div>

    <pre><code>// Extract all numbers from a string
const text = "Order #4521 has 3 items totaling $149.99";
const numbers = text.match(/\d+\.?\d*/g);
// Result: ["4521", "3", "149.99"]

// Extract all words
const words = text.match(/\w+/g);
// Result: ["Order", "4521", "has", "3", "items", "totaling", "149", "99"]</code></pre>

    <h2 id="anchors">Anchors and Boundaries</h2>

    <p>Anchors do not match characters. They match positions in the string. This is a subtle but critical distinction.</p>

    <div class="comparison-table-wrap">
      <table class="comparison-table">
        <thead>
          <tr>
            <th>Pattern</th>
            <th>Meaning</th>
            <th>Example</th>
            <th>Matches in "the cat sat"</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>^</code></td>
            <td>Start of string (or line with <code>m</code> flag)</td>
            <td><code>^the</code></td>
            <td>"the" at the start</td>
          </tr>
          <tr>
            <td><code>$</code></td>
            <td>End of string (or line with <code>m</code> flag)</td>
            <td><code>sat$</code></td>
            <td>"sat" at the end</td>
          </tr>
          <tr>
            <td><code>\b</code></td>
            <td>Word boundary</td>
            <td><code>\bcat\b</code></td>
            <td>"cat" (not "category")</td>
          </tr>
          <tr>
            <td><code>\B</code></td>
            <td>Non-word boundary</td>
            <td><code>\Bcat\B</code></td>
            <td>"cat" in "concatenate"</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="key-takeaway">
      <div class="key-takeaway-label">Common Gotcha</div>
      <p><code>^</code> and <code>$</code> match the start/end of the <strong>entire string</strong> by default. With the <code>m</code> (multiline) flag, they match the start/end of each <strong>line</strong>. This distinction trips up developers regularly when processing multi-line text. Test with the multiline flag toggled on and off in the <a href="/free-tools/regex-tester.html">Regex Tester</a> to see the difference.</p>
    </div>

    <h2 id="quantifiers">Quantifiers: How Many Times</h2>

    <div class="comparison-table-wrap">
      <table class="comparison-table">
        <thead>
          <tr>
            <th>Pattern</th>
            <th>Meaning</th>
            <th>Greedy Example</th>
            <th>Lazy Version</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>*</code></td>
            <td>0 or more</td>
            <td><code>a*</code> matches "", "a", "aaa"</td>
            <td><code>*?</code></td>
          </tr>
          <tr>
            <td><code>+</code></td>
            <td>1 or more</td>
            <td><code>a+</code> matches "a", "aaa"</td>
            <td><code>+?</code></td>
          </tr>
          <tr>
            <td><code>?</code></td>
            <td>0 or 1 (optional)</td>
            <td><code>colou?r</code> matches "color", "colour"</td>
            <td><code>??</code></td>
          </tr>
          <tr>
            <td><code>{n}</code></td>
            <td>Exactly n times</td>
            <td><code>\d{4}</code> matches "2026"</td>
            <td>N/A</td>
          </tr>
          <tr>
            <td><code>{n,}</code></td>
            <td>n or more times</td>
            <td><code>\d{2,}</code> matches "42", "123"</td>
            <td><code>{n,}?</code></td>
          </tr>
          <tr>
            <td><code>{n,m}</code></td>
            <td>Between n and m times</td>
            <td><code>\d{2,4}</code> matches "42", "123", "1234"</td>
            <td><code>{n,m}?</code></td>
          </tr>
        </tbody>
      </table>
    </div>

    <h3>Greedy vs. lazy: why it matters</h3>

    <p>By default, quantifiers are <strong>greedy</strong>: they match as much as possible. Adding <code>?</code> after a quantifier makes it <strong>lazy</strong>: it matches as little as possible.</p>

    <pre><code>// Greedy: matches the LONGEST possible
"&lt;b&gt;hello&lt;/b&gt; and &lt;b&gt;world&lt;/b&gt;".match(/&lt;b&gt;(.*)&lt;\/b&gt;/);
// Capture group 1: "hello&lt;/b&gt; and &lt;b&gt;world"

// Lazy: matches the SHORTEST possible
"&lt;b&gt;hello&lt;/b&gt; and &lt;b&gt;world&lt;/b&gt;".match(/&lt;b&gt;(.*?)&lt;\/b&gt;/);
// Capture group 1: "hello"

// With global flag, lazy finds both matches
"&lt;b&gt;hello&lt;/b&gt; and &lt;b&gt;world&lt;/b&gt;".match(/&lt;b&gt;(.*?)&lt;\/b&gt;/g);
// Result: ["&lt;b&gt;hello&lt;/b&gt;", "&lt;b&gt;world&lt;/b&gt;"]</code></pre>

    <h2 id="groups">Groups and Capturing</h2>

    <div class="comparison-table-wrap">
      <table class="comparison-table">
        <thead>
          <tr>
            <th>Pattern</th>
            <th>Meaning</th>
            <th>Example</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>(pattern)</code></td>
            <td>Capturing group</td>
            <td><code>(\d{4})-(\d{2})-(\d{2})</code> captures year, month, day</td>
          </tr>
          <tr>
            <td><code>(?:pattern)</code></td>
            <td>Non-capturing group</td>
            <td><code>(?:http|https)://</code> groups without capturing</td>
          </tr>
          <tr>
            <td><code>(?&lt;name&gt;pattern)</code></td>
            <td>Named capturing group</td>
            <td><code>(?&lt;year&gt;\d{4})</code> captures as "year"</td>
          </tr>
          <tr>
            <td><code>\1</code></td>
            <td>Backreference to group 1</td>
            <td><code>(\w+)\s+\1</code> matches repeated words</td>
          </tr>
          <tr>
            <td><code>\k&lt;name&gt;</code></td>
            <td>Named backreference</td>
            <td><code>(?&lt;word&gt;\w+)\s+\k&lt;word&gt;</code></td>
          </tr>
        </tbody>
      </table>
    </div>

    <pre><code>// Parse a date with named groups
const dateStr = "2026-02-13";
const match = dateStr.match(/(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/);
console.log(match.groups.year);   // "2026"
console.log(match.groups.month);  // "02"
console.log(match.groups.day);    // "13"

// Find repeated words (common typo detection)
const text = "the the quick brown fox fox";
const dupes = text.match(/\b(\w+)\s+\1\b/g);
// Result: ["the the", "fox fox"]</code></pre>

    <p>Test capturing groups visually using the <a href="/free-tools/regex-tester.html">ANIMA Regex Tester</a> -- it highlights each capture group in a different color and displays group values separately.</p>

    <h2 id="lookaround">Lookahead and Lookbehind</h2>

    <p>Lookaround assertions check for patterns without including them in the match. They are zero-width: they assert that something exists but do not consume characters.</p>

    <div class="comparison-table-wrap">
      <table class="comparison-table">
        <thead>
          <tr>
            <th>Pattern</th>
            <th>Name</th>
            <th>Meaning</th>
            <th>Example</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>(?=pattern)</code></td>
            <td>Positive lookahead</td>
            <td>Followed by pattern</td>
            <td><code>\d+(?= dollars)</code> matches "100" in "100 dollars"</td>
          </tr>
          <tr>
            <td><code>(?!pattern)</code></td>
            <td>Negative lookahead</td>
            <td>NOT followed by pattern</td>
            <td><code>\d+(?! dollars)</code> matches "200" in "200 euros"</td>
          </tr>
          <tr>
            <td><code>(?&lt;=pattern)</code></td>
            <td>Positive lookbehind</td>
            <td>Preceded by pattern</td>
            <td><code>(?&lt;=\$)\d+</code> matches "50" in "$50"</td>
          </tr>
          <tr>
            <td><code>(?&lt;!pattern)</code></td>
            <td>Negative lookbehind</td>
            <td>NOT preceded by pattern</td>
            <td><code>(?&lt;!\$)\d+</code> matches "50" in "50 items"</td>
          </tr>
        </tbody>
      </table>
    </div>

    <pre><code>// Password validation: at least 1 uppercase, 1 lowercase, 1 digit, 8+ chars
const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$/;
passwordRegex.test("Secure123");  // true
passwordRegex.test("weak");       // false

// Extract prices without the $ symbol
const prices = "free.99 and $149.00".match(/(?&lt;=\$)\d+\.?\d*/g);
// Result: ["29.99", "149.00"]

// Match "foo" only when NOT preceded by "bar"
/(?&lt;!bar)foo/.test("foobar");    // true (foo is not preceded by "bar")
/(?&lt;!bar)foo/.test("barfoo");    // false (foo IS preceded by "bar")</code></pre>

    <h2 id="flags">Regex Flags</h2>

    <div class="comparison-table-wrap">
      <table class="comparison-table">
        <thead>
          <tr>
            <th>Flag</th>
            <th>Name</th>
            <th>Effect</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>g</code></td>
            <td>Global</td>
            <td>Find all matches, not just the first</td>
          </tr>
          <tr>
            <td><code>i</code></td>
            <td>Case-insensitive</td>
            <td><code>/hello/i</code> matches "Hello", "HELLO"</td>
          </tr>
          <tr>
            <td><code>m</code></td>
            <td>Multiline</td>
            <td><code>^</code> and <code>$</code> match line starts/ends</td>
          </tr>
          <tr>
            <td><code>s</code></td>
            <td>DotAll</td>
            <td><code>.</code> also matches newline characters</td>
          </tr>
          <tr>
            <td><code>u</code></td>
            <td>Unicode</td>
            <td>Enables full Unicode matching, <code>\p{}</code> categories</td>
          </tr>
          <tr>
            <td><code>d</code></td>
            <td>Indices</td>
            <td>Generates indices for matched substrings</td>
          </tr>
          <tr>
            <td><code>v</code></td>
            <td>UnicodeSets</td>
            <td>Extended Unicode property classes (ES2024+)</td>
          </tr>
        </tbody>
      </table>
    </div>

    <pre><code>// Unicode flag: match accented characters, CJK, emojis
/\p{Letter}/u.test("e");    // true (e is a letter)
/\p{Letter}/u.test("4");    // false
/\p{Emoji}/u.test("@");     // false

// DotAll flag: . matches newlines
"line1\nline2".match(/.+/s);   // ["line1\nline2"]
"line1\nline2".match(/.+/);    // ["line1"]</code></pre>

    <h2 id="real-world">Real-World Patterns You Can Copy</h2>

    <p>These are tested, production-ready patterns for common validation and extraction tasks. Copy them directly or paste them into the <a href="/free-tools/regex-tester.html">Regex Tester</a> to experiment.</p>

    <h3>Email (practical validation)</h3>
    <pre><code>^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$</code></pre>
    <p>Covers 99.9% of real email addresses. The RFC 5322-compliant regex is thousands of characters long and unnecessary for practical validation.</p>

    <h3>URL</h3>
    <pre><code>https?:\/\/[^\s/$.?#].[^\s]*</code></pre>
    <p>Matches HTTP and HTTPS URLs. For stricter validation, use the URL constructor in JavaScript: <code>new URL(str)</code> throws on invalid URLs.</p>

    <h3>IPv4 address</h3>
    <pre><code>^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$</code></pre>
    <p>Validates each octet is 0-255. Rejects "999.999.999.999" and "1.2.3.999".</p>

    <h3>Phone number (international)</h3>
    <pre><code>^\+?[1-9]\d{6,14}$</code></pre>
    <p>Matches E.164 format. For display formatting, use a library like libphonenumber.</p>

    <h3>Date (YYYY-MM-DD)</h3>
    <pre><code>^\d{4}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01])$</code></pre>
    <p>Validates format and month/day ranges. Does not validate actual calendar dates (Feb 30 passes). For full validation, parse with <code>new Date()</code> and check <code>isNaN()</code>.</p>

    <h3>Hex color code</h3>
    <pre><code>^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$</code></pre>
    <p>Matches #FFF, #FF00FF, and #FF00FF80 (with alpha). Use the <a href="/free-tools/color-converter.html">Color Converter</a> to translate between hex, RGB, and HSL formats.</p>

    <h3>Slug (URL-friendly string)</h3>
    <pre><code>^[a-z0-9]+(?:-[a-z0-9]+)*$</code></pre>
    <p>Matches "hello-world", "my-blog-post-123". Rejects leading/trailing hyphens and consecutive hyphens. Generate slugs from titles with the <a href="/free-tools/slug-generator.html">Slug Generator</a>.</p>

    <h3>HTML tag extraction</h3>
    <pre><code>&lt;(\w+)([^&gt;]*)&gt;(.*?)&lt;\/\1&gt;</code></pre>
    <p>Captures tag name, attributes, and content. Works for simple cases but cannot handle nested tags of the same type. For HTML parsing, always use a proper parser (DOMParser, cheerio, etc.).</p>

    <div class="cta-box">
      <h3>Test These Patterns Live</h3>
      <p>Paste any pattern from this cheat sheet into the ANIMA Regex Tester. See matches highlighted in real time, inspect capture groups, and toggle flags.</p>
      <a href="/free-tools/regex-tester.html" class="cta-button">Open Regex Tester</a>
    </div>

    <h2 id="js-methods">JavaScript Regex Methods Quick Reference</h2>

    <pre><code>const str = "Hello World 123";
const re = /(\w+)\s(\w+)/;

// test() — returns boolean
re.test(str);                    // true

// match() — returns matches array
str.match(/\d+/g);              // ["123"]

// matchAll() — returns iterator of all matches with groups
[...str.matchAll(/(\w+)/g)];    // Full match objects with indices

// replace() — string replacement
str.replace(/World/, "Regex");  // "Hello Regex 123"

// replace() with capture groups
"2026-02-13".replace(
  /(\d{4})-(\d{2})-(\d{2})/,
  "$2/$3/$1"
);                               // "02/13/2026"

// replaceAll() — replace all occurrences
"a-b-c".replaceAll("-", "_");   // "a_b_c"

// split() — split by pattern
"one, two , three".split(/\s*,\s*/);  // ["one", "two", "three"]

// search() — returns index of first match
str.search(/\d/);               // 12

// exec() — returns match object (stateful with g flag)
re.exec(str);                   // ["Hello World", "Hello", "World"]</code></pre>

    <p>For find-and-replace across text files and code, the <a href="/free-tools/diff-checker.html">Diff Checker</a> helps you verify that your regex replacements produced the expected output. The <a href="/free-tools/regex-builder.html">Regex Builder</a> helps you construct patterns step by step if you prefer a visual approach.</p>

    <h2 id="common-mistakes">8 Common Regex Mistakes</h2>

    <ol>
      <li><strong>Forgetting to escape special characters.</strong> Characters like <code>.</code>, <code>(</code>, <code>)</code>, <code>[</code>, <code>{</code>, <code>*</code>, <code>+</code>, <code>?</code>, <code>^</code>, <code>$</code>, <code>|</code>, <code>\</code> have special meaning. To match them literally, escape with <code>\</code>.</li>

      <li><strong>Using <code>.*</code> when you mean <code>.*?</code>.</strong> Greedy matching grabs everything. If you are matching between delimiters (quotes, tags, brackets), lazy matching (<code>.*?</code>) is almost always what you want.</li>

      <li><strong>Forgetting the <code>g</code> flag.</strong> Without <code>g</code>, <code>match()</code> returns only the first match. With <code>g</code>, it returns all matches. This is the most common "why does it only find one" bug.</li>

      <li><strong>Anchoring incorrectly.</strong> <code>/hello/</code> matches "hello" anywhere in the string. <code>/^hello$/</code> matches only strings that are exactly "hello". When validating input, you almost always want both anchors.</li>

      <li><strong>Not accounting for newlines.</strong> By default, <code>.</code> does not match <code>\n</code>. Use the <code>s</code> (dotAll) flag if you need <code>.</code> to match everything including newlines.</li>

      <li><strong>Catastrophic backtracking.</strong> Patterns like <code>(a+)+$</code> can cause exponential backtracking on certain inputs, freezing your application. Avoid nested quantifiers on the same character set. Test with long inputs in the <a href="/free-tools/regex-tester.html">Regex Tester</a> to catch performance issues early.</li>

      <li><strong>Using regex to parse HTML.</strong> Regular expressions cannot reliably parse nested structures. Use <code>DOMParser</code>, <code>cheerio</code>, or similar tools for HTML parsing. Regex is fine for extracting simple patterns from HTML, but not for structural parsing.</li>

      <li><strong>Double-escaping in string constructors.</strong> In <code>new RegExp("\\d+")</code>, you need <code>\\d</code> (double backslash) because the string literal consumes the first backslash. With regex literals (<code>/\d+/</code>), single backslash works. This is a frequent source of "pattern does not match" bugs.</li>
    </ol>

    <pre><code>// WRONG: catastrophic backtracking
const bad = /^(a+)+$/;
bad.test("aaaaaaaaaaaaaaaaaaaaaaaa!");  // Hangs!

// FIXED: remove nested quantifier
const good = /^a+$/;
good.test("aaaaaaaaaaaaaaaaaaaaaaaa!");  // false, instantly

// WRONG: double-escaping in RegExp constructor
new RegExp("\d+");       // Same as /d+/ — matches "d", not digits
new RegExp("\\d+");      // Same as /\d+/ — matches digits correctly</code></pre>

    <div class="key-takeaway">
      <div class="key-takeaway-label">Best Practice</div>
      <p>Always use regex literals (<code>/pattern/flags</code>) when the pattern is static. Only use <code>new RegExp()</code> when the pattern is dynamically constructed from variables. This avoids double-escaping bugs and is slightly faster because the regex is compiled at parse time.</p>
    </div>

    <h2 id="faq">Frequently Asked Questions</h2>

    <h3>What is the difference between .* and .*? in regex?</h3>
    <p><code>.*</code> is a greedy quantifier -- it matches as many characters as possible. <code>.*?</code> is a lazy (non-greedy) quantifier -- it matches as few characters as possible. For example, given the string <code>&lt;b&gt;hello&lt;/b&gt;&lt;b&gt;world&lt;/b&gt;</code>, the pattern <code>&lt;b&gt;(.*)&lt;/b&gt;</code> greedily captures "hello&lt;/b&gt;&lt;b&gt;world", while <code>&lt;b&gt;(.*?)&lt;/b&gt;</code> lazily captures just "hello". Use lazy quantifiers when you want the shortest match between delimiters.</p>

    <h3>How do I match an email address with regex?</h3>
    <p>A practical email regex for input validation is: <code>^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$</code>. This matches most real-world email addresses. The RFC 5322-compliant regex is thousands of characters long and rarely needed. For production validation, use this simple pattern for client-side feedback and verify with an actual email delivery attempt server-side.</p>

    <h3>What is a lookahead in regex and when should I use it?</h3>
    <p>A lookahead is a zero-width assertion that checks if a pattern exists ahead of the current position without consuming characters. Positive lookahead <code>(?=pattern)</code> asserts that the pattern follows. Negative lookahead <code>(?!pattern)</code> asserts that it does NOT follow. Common use cases include password validation (checking for required character types), matching words only in specific contexts, and complex find-and-replace operations. Test lookaheads interactively in the <a href="/free-tools/regex-tester.html">ANIMA Regex Tester</a>.</p>

    <h3>What is the best free regex tester online in 2026?</h3>
    <p>The <a href="/free-tools/regex-tester.html">ANIMA Regex Tester</a> is one of the best free options. It provides real-time match highlighting, group extraction, flag toggles, and match count in a clean, ad-free interface running entirely in your browser. For building regex visually, the <a href="/free-tools/regex-builder.html">ANIMA Regex Builder</a> provides a step-by-step interface that constructs patterns from components. Both are part of ANIMA's collection of <a href="/free-tools/">250+ free developer tools</a>.</p>

    <h3>How do I make regex case-insensitive?</h3>
    <p>Use the <code>i</code> flag. In JavaScript: <code>/pattern/i</code> or <code>new RegExp('pattern', 'i')</code>. In Python: <code>re.compile('pattern', re.IGNORECASE)</code> or use the inline flag <code>(?i)</code> at the start of the pattern. The <code>i</code> flag makes all alphabetic matches ignore case, so <code>/hello/i</code> matches "hello", "Hello", "HELLO", and any other case variation.</p>

    <div class="cta-box">
      <h3>Explore ANIMA for free</h3>
      <p>Enhanced features across 250+ developer tools, clean output, and unlimited workspace. One payment, lifetime access.</p>
      <a href="https://github.com/christian140903-sudo/nextool" class="cta-button">Upgrade to Pro &rarr;</a>
    </div>

    <!-- AUTHOR BOX -->
    <div class="author-box">
      <div class="author-avatar">NT</div>
      <div class="author-info">
        <h4>Christian Bucher</h4>
        <p>We build free, privacy-first developer tools. 250+ tools for regex, JSON, CSS, images, and more -- all browser-based, no signup required.</p>
      </div>
    </div>

    <!-- RELATED ARTICLES -->
    <div class="related-articles">
      <h3>Related Articles</h3>
      <div class="related-grid">
        <a href="/blog/regex-tutorial-beginners-guide.html" class="related-card">
          <div class="related-card-cat">Developer Guide</div>
          <h4>Regex Tutorial: A Beginner's Guide</h4>
          <p>Learn regular expressions from scratch with step-by-step explanations and interactive examples.</p>
        </a>
        <a href="/blog/regex-patterns-every-developer-needs.html" class="related-card">
          <div class="related-card-cat">Developer Tools</div>
          <h4>Regex Patterns Every Developer Needs</h4>
          <p>Production-ready regex patterns for validation, extraction, and transformation with code examples.</p>
        </a>
        <a href="/blog/javascript-performance-optimization.html" class="related-card">
          <div class="related-card-cat">JavaScript</div>
          <h4>JavaScript Performance Optimization Guide</h4>
          <p>Optimize your JavaScript code for speed, including regex performance tips and common bottlenecks.</p>
        </a>
      </div>
    </div>

  </article>
</div>

<!-- FOOTER -->

<!-- AUTO-LINKED by ANIMA Engine -->
<div style="margin:2rem 0;padding:1.5rem;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius)">
<p style="font-weight:600;margin-bottom:.5rem">Related Tools</p>
<p><a href="/free-tools/box-shadow-generator.html" style="color:var(--primary);text-decoration:none">CSS Box Shadow Generator</a> · <a href="/free-tools/emoji-picker.html" style="color:var(--primary);text-decoration:none">Emoji Picker & Search</a> · <a href="/free-tools/regex-playground.html" style="color:var(--primary);text-decoration:none">Free Regex Playground</a></p>
</div>

<!-- AUTO-LINKED by ANIMA Engine -->
<div style="margin:2rem 0;padding:1.5rem;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius)">
<p style="font-weight:600;margin-bottom:.5rem">Related Tools</p>
<p><a href="/free-tools/regex-generator.html" style="color:var(--primary);text-decoration:none">Free Regex Pattern Generator</a> · <a href="/free-tools/json-to-yaml-converter.html" style="color:var(--primary);text-decoration:none">Free JSON to YAML Converter</a> · <a href="/free-tools/api-mock-server.html" style="color:var(--primary);text-decoration:none">Free API Mock Server</a></p>
</div>
<footer class="site-footer">
  <div class="footer-grid">
    <div class="footer-col">
      <div class="footer-brand">ANIMA</div>
      <p class="footer-brand-desc">250+ free developer tools for developers and designers. Browser-based, no signup.</p>
    </div>
    <div class="footer-col">
      <h4>Text &amp; Code Tools</h4>
      <a href="/free-tools/regex-tester.html">Regex Tester</a>
      <a href="/free-tools/regex-builder.html">Regex Builder</a>
      <a href="/free-tools/diff-checker.html">Diff Checker</a>
      <a href="/free-tools/text-diff.html">Text Diff</a>
      <a href="/free-tools/slug-generator.html">Slug Generator</a>
    </div>
    <div class="footer-col">
      <h4>Explore</h4>
      <a href="/free-tools/">All 250+ Tools</a>
      <a href="https://github.com/christian140903-sudo/nextool">ANIMA</a>
      <a href="/blog/">Blog</a>
      <a href="/terms.html">Terms</a>
    </div>
    <div class="footer-col">
      <h4>Connect</h4>
      <a href="mailto:hello@nextool.app">Email Us</a>
      <a href="/imprint.html">Imprint</a>
    </div>
  </div>
  <div class="footer-bottom">&copy; 2026 ANIMA. All rights reserved.</div>
</footer>

<script>
// TOC active state
const tocLinks = document.querySelectorAll('.toc-list a');
const sections = document.querySelectorAll('.article-content h2[id]');
window.addEventListener('scroll', () => {
  let current = '';
  sections.forEach(s => { if (window.scrollY >= s.offsetTop - 120) current = s.id; });
  tocLinks.forEach(l => {
    l.classList.remove('active');
    if (l.getAttribute('href') === '#' + current) l.classList.add('active');
  });
});
// Mobile nav toggle
document.querySelector('.nav-mobile-toggle')?.addEventListener('click', () => {
  const links = document.querySelector('.nav-links');
  links.style.display = links.style.display === 'flex' ? 'none' : 'flex';
  links.style.flexDirection = 'column';
  links.style.position = 'absolute';
  links.style.top = '64px';
  links.style.right = '1rem';
  links.style.background = 'var(--surface)';
  links.style.padding = '1rem';
  links.style.borderRadius = '12px';
  links.style.border = '1px solid var(--border)';
});
</script>
<script src="/js/analytics-lite.js" defer></script>
<script src="/js/revenue.js" defer></script>
<script src="/js/lead-capture.js" defer></script>
</body>
</html>