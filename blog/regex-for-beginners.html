<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Regex for Beginners: Learn Regular Expressions | NexTool</title>
    <meta name="description" content="Learn regular expressions in 30 minutes. Beginner-friendly regex tutorial with character classes, quantifiers, groups, lookaheads, and practical examples you can test live.">
    <meta name="keywords" content="regex tutorial, regular expressions, regex for beginners, regex examples, learn regex, regex patterns, regex cheat sheet, regex guide">
    <meta name="author" content="NexTool Team">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://nextool.app/blog/regex-for-beginners.html">

    <!-- Open Graph -->
    <meta property="og:type" content="article">
    <meta property="og:title" content="Regex for Beginners: Learn Regular Expressions in 30 Minutes">
    <meta property="og:description" content="Beginner-friendly regex tutorial. Character classes, quantifiers, groups, lookaheads, and practical examples with a free live regex tester.">
    <meta property="og:url" content="https://nextool.app/blog/regex-for-beginners.html">
    <meta property="og:site_name" content="NexTool">
    <meta property="og:image" content="https://nextool.app/assets/images/blog/regex-for-beginners-og.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="article:published_time" content="2026-02-14T09:00:00Z">
    <meta property="article:modified_time" content="2026-02-14T09:00:00Z">
    <meta property="article:author" content="NexTool Team">
    <meta property="article:section" content="Tutorial">
    <meta property="article:tag" content="Regex">
    <meta property="article:tag" content="Programming">
    <meta property="article:tag" content="Tutorial">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Regex for Beginners: Learn Regular Expressions in 30 Minutes">
    <meta name="twitter:description" content="Beginner-friendly regex tutorial. Character classes, quantifiers, groups, lookaheads, and practical examples.">
    <meta name="twitter:image" content="https://nextool.app/assets/images/blog/regex-for-beginners-og.png">

    <!-- JSON-LD: Article -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Article",
        "headline": "Regex for Beginners: Learn Regular Expressions in 30 Minutes",
        "description": "Learn regular expressions in 30 minutes. Beginner-friendly regex tutorial with character classes, quantifiers, groups, lookaheads, and practical examples you can test live.",
        "image": "https://nextool.app/assets/images/blog/regex-for-beginners-og.png",
        "author": {
            "@type": "Organization",
            "name": "NexTool Team",
            "url": "https://nextool.app"
        },
        "publisher": {
            "@type": "Organization",
            "name": "NexTool",
            "logo": {
                "@type": "ImageObject",
                "url": "https://nextool.app/assets/images/logo.png"
            }
        },
        "datePublished": "2026-02-14T09:00:00Z",
        "dateModified": "2026-02-14T09:00:00Z",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://nextool.app/blog/regex-for-beginners.html"
        },
        "wordCount": 2800,
        "keywords": ["regex", "regular expressions", "regex tutorial", "regex beginners", "regex patterns", "character classes", "quantifiers"]
    }
    </script>

    <!-- JSON-LD: BreadcrumbList -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BreadcrumbList",
        "itemListElement": [
            {
                "@type": "ListItem",
                "position": 1,
                "name": "Home",
                "item": "https://nextool.app"
            },
            {
                "@type": "ListItem",
                "position": 2,
                "name": "Blog",
                "item": "https://nextool.app/blog/"
            },
            {
                "@type": "ListItem",
                "position": 3,
                "name": "Regex for Beginners",
                "item": "https://nextool.app/blog/regex-for-beginners.html"
            }
        ]
    }
    </script>

    <!-- JSON-LD: FAQPage -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "FAQPage",
        "mainEntity": [
            {
                "@type": "Question",
                "name": "What is a regular expression (regex)?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "A regular expression (regex or regexp) is a sequence of characters that defines a search pattern. It is used to match, search, extract, or replace text based on patterns rather than exact strings. For example, the regex \\d{3}-\\d{4} matches any phone number in the format 555-1234 (three digits, a hyphen, four digits). Regular expressions are supported in virtually every programming language including JavaScript, Python, Java, Go, Ruby, PHP, and C#, as well as in command-line tools like grep, sed, and awk."
                }
            },
            {
                "@type": "Question",
                "name": "What is the difference between greedy and lazy quantifiers?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Greedy quantifiers (*, +, {n,m}) match as much text as possible while still allowing the overall pattern to succeed. Lazy quantifiers (*?, +?, {n,m}?) match as little text as possible. For example, given the string '<b>bold</b> and <b>more</b>', the greedy pattern <b>.*</b> matches '<b>bold</b> and <b>more</b>' (everything between the first <b> and the last </b>). The lazy pattern <b>.*?</b> matches only '<b>bold</b>' (stops at the first </b>). Use lazy quantifiers when you want the shortest possible match, which is common when parsing HTML, extracting quoted strings, or matching delimited content."
                }
            },
            {
                "@type": "Question",
                "name": "How do I validate an email address with regex?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "A practical email validation regex is: ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$ which matches most valid email addresses by checking for one or more alphanumeric characters (plus common special characters) before the @ symbol, followed by a domain name with at least one dot and a top-level domain of 2 or more letters. Note that the full RFC 5322 email specification is extremely complex and nearly impossible to match perfectly with regex alone. For production applications, use a simple regex for basic format checking, then verify the email actually exists by sending a confirmation message."
                }
            },
            {
                "@type": "Question",
                "name": "What are lookaheads and lookbehinds in regex?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Lookaheads and lookbehinds (collectively called lookarounds) are zero-width assertions that check whether a pattern exists before or after the current position without including it in the match. A positive lookahead (?=pattern) asserts that what follows matches the pattern. A negative lookahead (?!pattern) asserts that what follows does NOT match. A positive lookbehind (?<=pattern) asserts that what precedes matches the pattern. A negative lookbehind (?<!pattern) asserts that what precedes does NOT match. Example: \\d+(?= dollars) matches '100' in '100 dollars' but not '100' in '100 euros', because it requires 'dollars' to follow without including it in the match."
                }
            },
            {
                "@type": "Question",
                "name": "Which programming languages support regex?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Virtually every modern programming language supports regular expressions. JavaScript uses /pattern/flags syntax or the RegExp constructor. Python provides the re module with functions like re.match(), re.search(), re.findall(), and re.sub(). Java has the java.util.regex package with Pattern and Matcher classes. Go has the regexp package. Ruby has built-in regex with the =~ operator. PHP offers preg_match() and preg_replace() functions. C# uses the System.Text.RegularExpressions namespace. Command-line tools like grep, sed, and awk also use regex extensively. While the core syntax is similar across languages, there are differences in supported features (like lookbehinds in JavaScript only being available since ES2018) and in escaping rules."
                }
            },
            {
                "@type": "Question",
                "name": "How can I test and debug regular expressions?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Use an interactive regex tester that highlights matches in real time as you type. NexTool's free Regex Tester at nextool.app/free-tools/regex-tester.html lets you enter a pattern and test string, see all matches highlighted, view capture groups, and get an explanation of what each part of your pattern does. Other popular tools include regex101.com and Regexr. When debugging, start simple: build your pattern incrementally, testing each piece before adding complexity. Use the verbose/extended flag (x in Python, not available in JavaScript) to add comments to complex patterns. Break long patterns into named groups for readability."
                }
            }
        ]
    }
    </script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <style>
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #050508;
            --surface: #0a0a0f;
            --surface-2: #1a1a24;
            --surface-3: #232330;
            --primary: #6366f1;
            --primary-hover: #818cf8;
            --accent: #a855f7;
            --accent-hover: #c084fc;
            --text: #e2e8f0;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --border: #1e1e2e;
            --success: #22c55e;
            --warning: #f59e0b;
            --error: #ef4444;
            --code-bg: #0d0d14;
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --font-mono: 'JetBrains Mono', 'Fira Code', monospace;
            --max-width: 800px;
            --header-height: 64px;
        }

        html { scroll-behavior: smooth; -webkit-text-size-adjust: 100%; }
        body { font-family: var(--font-sans); background: var(--bg); color: var(--text); line-height: 1.75; font-size: 16px; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; overflow-x: hidden; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg); }
        ::-webkit-scrollbar-thumb { background: var(--surface-3); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

        .nav { position: fixed; top: 0; left: 0; right: 0; height: var(--header-height); background: rgba(5, 5, 8, 0.85); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-bottom: 1px solid var(--border); z-index: 1000; display: flex; align-items: center; justify-content: center; }
        .nav-inner { width: 100%; max-width: 1200px; padding: 0 24px; display: flex; align-items: center; justify-content: space-between; }
        .nav-logo { display: flex; align-items: center; gap: 10px; text-decoration: none; color: var(--text); font-weight: 700; font-size: 1.25rem; }
        .nav-logo-icon { width: 32px; height: 32px; background: linear-gradient(135deg, var(--primary), var(--accent)); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 0.875rem; font-weight: 800; color: #fff; }
        .nav-links { display: flex; align-items: center; gap: 28px; list-style: none; }
        .nav-links a { color: var(--text-secondary); text-decoration: none; font-size: 0.9rem; font-weight: 500; transition: color 0.2s; }
        .nav-links a:hover { color: var(--text); }
        .nav-cta { background: var(--primary); color: #fff !important; padding: 8px 20px; border-radius: 8px; font-weight: 600; transition: background 0.2s, transform 0.2s; }
        .nav-cta:hover { background: var(--primary-hover); transform: translateY(-1px); }

        .article-wrapper { max-width: var(--max-width); margin: 0 auto; padding: calc(var(--header-height) + 48px) 24px 80px; }
        .breadcrumb { display: flex; align-items: center; gap: 8px; margin-bottom: 32px; font-size: 0.85rem; color: var(--text-muted); flex-wrap: wrap; }
        .breadcrumb a { color: var(--text-secondary); text-decoration: none; transition: color 0.2s; }
        .breadcrumb a:hover { color: var(--primary); }

        .article-header { margin-bottom: 48px; padding-bottom: 32px; border-bottom: 1px solid var(--border); }
        .article-category { display: inline-block; background: rgba(168, 85, 247, 0.12); color: var(--accent); padding: 4px 14px; border-radius: 20px; font-size: 0.8rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 16px; }
        .article-title { font-size: clamp(2rem, 5vw, 3rem); font-weight: 800; line-height: 1.15; color: var(--text); margin-bottom: 16px; letter-spacing: -0.03em; }
        .article-subtitle { font-size: 1.2rem; color: var(--text-secondary); line-height: 1.6; margin-bottom: 24px; }
        .article-meta { display: flex; align-items: center; gap: 20px; color: var(--text-muted); font-size: 0.875rem; flex-wrap: wrap; }
        .article-meta-item { display: flex; align-items: center; gap: 6px; }
        .article-meta-item svg { width: 16px; height: 16px; opacity: 0.7; }

        .toc { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 24px 28px; margin-bottom: 48px; }
        .toc-title { font-size: 0.85rem; font-weight: 700; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 16px; }
        .toc-list { list-style: none; counter-reset: toc; }
        .toc-list li { counter-increment: toc; margin-bottom: 8px; }
        .toc-list li a { color: var(--text-secondary); text-decoration: none; font-size: 0.925rem; display: flex; align-items: baseline; gap: 10px; transition: color 0.2s, padding-left 0.2s; padding: 4px 0; }
        .toc-list li a::before { content: counter(toc, decimal-leading-zero); color: var(--text-muted); font-size: 0.8rem; font-family: var(--font-mono); min-width: 20px; }
        .toc-list li a:hover { color: var(--primary); padding-left: 4px; }

        .article-content h2 { font-size: 1.75rem; font-weight: 700; color: var(--text); margin-top: 56px; margin-bottom: 20px; letter-spacing: -0.02em; line-height: 1.3; padding-top: 16px; border-top: 1px solid var(--border); }
        .article-content h2:first-child { margin-top: 0; padding-top: 0; border-top: none; }
        .article-content h3 { font-size: 1.3rem; font-weight: 600; color: var(--text); margin-top: 36px; margin-bottom: 14px; line-height: 1.35; }
        .article-content h4 { font-size: 1.1rem; font-weight: 600; color: var(--text-secondary); margin-top: 28px; margin-bottom: 12px; }
        .article-content p { margin-bottom: 20px; color: var(--text-secondary); line-height: 1.8; }
        .article-content a { color: var(--primary); text-decoration: none; border-bottom: 1px solid transparent; transition: border-color 0.2s; }
        .article-content a:hover { border-bottom-color: var(--primary); }
        .article-content strong { color: var(--text); font-weight: 600; }
        .article-content ul, .article-content ol { margin-bottom: 20px; padding-left: 24px; color: var(--text-secondary); }
        .article-content li { margin-bottom: 10px; line-height: 1.7; }
        .article-content li::marker { color: var(--primary); }
        .article-content blockquote { border-left: 3px solid var(--accent); background: var(--surface); padding: 16px 24px; margin: 28px 0; border-radius: 0 8px 8px 0; font-style: italic; color: var(--text-secondary); }
        .article-content blockquote p:last-child { margin-bottom: 0; }
        .article-content hr { border: none; border-top: 1px solid var(--border); margin: 48px 0; }

        .article-content pre { background: var(--code-bg); border: 1px solid var(--border); border-radius: 12px; padding: 20px 24px; overflow-x: auto; margin: 24px 0; }
        .article-content pre code { font-family: var(--font-mono); font-size: 0.875rem; line-height: 1.65; color: var(--text); background: none; padding: 0; border-radius: 0; }
        .article-content code { font-family: var(--font-mono); font-size: 0.85em; background: var(--surface); color: var(--accent); padding: 2px 8px; border-radius: 5px; }
        .code-label { display: inline-block; background: var(--surface-2); color: var(--text-muted); font-family: var(--font-mono); font-size: 0.75rem; padding: 2px 10px; border-radius: 6px 6px 0 0; margin-bottom: -1px; position: relative; top: 1px; }

        .article-content table { width: 100%; border-collapse: collapse; margin: 24px 0; font-size: 0.925rem; }
        .article-content thead th { background: var(--surface); color: var(--text); font-weight: 600; text-align: left; padding: 12px 16px; border-bottom: 2px solid var(--border); }
        .article-content tbody td { padding: 12px 16px; border-bottom: 1px solid var(--border); color: var(--text-secondary); }
        .article-content tbody tr:hover { background: var(--surface); }

        .info-box { background: rgba(99, 102, 241, 0.08); border: 1px solid rgba(99, 102, 241, 0.2); border-radius: 12px; padding: 20px 24px; margin: 28px 0; }
        .info-box.warning { background: rgba(245, 158, 11, 0.08); border-color: rgba(245, 158, 11, 0.2); }
        .info-box.danger { background: rgba(239, 68, 68, 0.08); border-color: rgba(239, 68, 68, 0.2); }
        .info-box.success { background: rgba(34, 197, 94, 0.08); border-color: rgba(34, 197, 94, 0.2); }
        .info-box-title { font-weight: 700; margin-bottom: 8px; font-size: 0.9rem; display: flex; align-items: center; gap: 8px; }
        .info-box p { color: var(--text-secondary); font-size: 0.925rem; margin-bottom: 0; }

        .tool-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 16px; margin: 28px 0; }
        .tool-card { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 20px; text-decoration: none; color: var(--text); transition: border-color 0.2s, transform 0.2s, box-shadow 0.2s; display: flex; flex-direction: column; gap: 8px; }
        .tool-card:hover { border-color: var(--primary); transform: translateY(-2px); box-shadow: 0 8px 24px rgba(99, 102, 241, 0.1); }
        .tool-card-icon { font-size: 1.5rem; margin-bottom: 4px; }
        .tool-card-name { font-weight: 600; font-size: 0.95rem; }
        .tool-card-desc { font-size: 0.825rem; color: var(--text-muted); line-height: 1.5; }

        .cta-box { background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(168, 85, 247, 0.1)); border: 1px solid rgba(99, 102, 241, 0.25); border-radius: 16px; padding: 40px 32px; text-align: center; margin: 48px 0; }
        .cta-box h3 { font-size: 1.5rem; font-weight: 700; margin-bottom: 12px; color: var(--text); }
        .cta-box p { color: var(--text-secondary); margin-bottom: 24px; max-width: 500px; margin-left: auto; margin-right: auto; }
        .cta-button { display: inline-flex; align-items: center; gap: 8px; background: var(--primary); color: #fff; padding: 14px 32px; border-radius: 10px; text-decoration: none; font-weight: 600; font-size: 1rem; transition: background 0.2s, transform 0.2s, box-shadow 0.2s; }
        .cta-button:hover { background: var(--primary-hover); transform: translateY(-2px); box-shadow: 0 8px 32px rgba(99, 102, 241, 0.3); }
        .cta-button.secondary { background: transparent; border: 1px solid var(--primary); color: var(--primary); margin-left: 12px; }
        .cta-button.secondary:hover { background: rgba(99, 102, 241, 0.1); }

        .faq-section { margin-top: 56px; padding-top: 32px; border-top: 1px solid var(--border); }
        .faq-section h2 { margin-top: 0 !important; padding-top: 0 !important; border-top: none !important; }
        .faq-item { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; margin-bottom: 12px; overflow: hidden; }
        .faq-question { width: 100%; background: none; border: none; color: var(--text); padding: 20px 24px; font-size: 1rem; font-weight: 600; text-align: left; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-family: var(--font-sans); transition: background 0.2s; }
        .faq-question:hover { background: var(--surface-2); }
        .faq-question .icon { transition: transform 0.3s; font-size: 1.25rem; color: var(--text-muted); flex-shrink: 0; margin-left: 16px; }
        .faq-item.open .faq-question .icon { transform: rotate(45deg); }
        .faq-answer { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; }
        .faq-answer-inner { padding: 0 24px 20px; color: var(--text-secondary); line-height: 1.7; }

        .author-box { display: flex; align-items: center; gap: 20px; background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 24px; margin: 48px 0; }
        .author-avatar { width: 64px; height: 64px; background: linear-gradient(135deg, var(--primary), var(--accent)); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; font-weight: 700; color: #fff; flex-shrink: 0; }
        .author-info h4 { font-weight: 600; margin-bottom: 4px; }
        .author-info p { color: var(--text-muted); font-size: 0.875rem; margin: 0; line-height: 1.5; }

        .footer { border-top: 1px solid var(--border); padding: 48px 24px; text-align: center; color: var(--text-muted); font-size: 0.85rem; }
        .footer-inner { max-width: 1200px; margin: 0 auto; }
        .footer-links { display: flex; justify-content: center; gap: 24px; margin-bottom: 20px; flex-wrap: wrap; }
        .footer-links a { color: var(--text-secondary); text-decoration: none; transition: color 0.2s; }
        .footer-links a:hover { color: var(--primary); }

        @media (max-width: 768px) {
            .nav-links { display: none; }
            .article-wrapper { padding: calc(var(--header-height) + 24px) 16px 60px; }
            .article-title { font-size: 1.75rem; }
            .tool-grid { grid-template-columns: 1fr; }
            .cta-box { padding: 28px 20px; }
            .cta-button.secondary { margin-left: 0; margin-top: 12px; }
            .author-box { flex-direction: column; text-align: center; }
            .article-content pre { padding: 16px; border-radius: 8px; }
            .article-content h2 { font-size: 1.4rem; }
            .article-content h3 { font-size: 1.15rem; }
            .article-content table { display: block; overflow-x: auto; }
        }
        @media (max-width: 480px) {
            .article-title { font-size: 1.5rem; }
            .toc { padding: 18px 20px; }
        }
    </style>
</head>
<body>

    <!-- Navigation -->
    <nav class="nav">
        <div class="nav-inner">
            <a href="https://nextool.app" class="nav-logo">
                <div class="nav-logo-icon">N</div>
                NexTool
            </a>
            <ul class="nav-links">
                <li><a href="https://nextool.app/#services">Tools</a></li>
                <li><a href="https://nextool.app/free-tools/">Free Tools</a></li>
                <li><a href="https://nextool.app/blog/">Blog</a></li>
                <li><a href="https://nextool.app/#contact" class="nav-cta">Browse Tools</a></li>
            </ul>
        </div>
    </nav>

    <!-- Article -->
    <article class="article-wrapper" itemscope itemtype="https://schema.org/Article">
        <!-- Breadcrumb -->
        <nav class="breadcrumb" aria-label="Breadcrumb">
            <a href="https://nextool.app">Home</a>
            <span class="separator">/</span>
            <a href="https://nextool.app/blog/">Blog</a>
            <span class="separator">/</span>
            <span>Regex for Beginners</span>
        </nav>

        <!-- Header -->
        <header class="article-header">
            <span class="article-category">Tutorial</span>
            <h1 class="article-title" itemprop="headline">Regex for Beginners: Learn Regular Expressions in 30 Minutes</h1>
            <p class="article-subtitle">Regular expressions look intimidating, but the core concepts are simple. This guide teaches you regex from zero to practical competence, with real-world examples you can test immediately.</p>
            <div class="article-meta">
                <div class="article-meta-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>
                    <span>18 min read</span>
                </div>
                <div class="article-meta-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
                    <time datetime="2026-02-14" itemprop="datePublished">February 14, 2026</time>
                </div>
                <div class="article-meta-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>
                    <span itemprop="author">NexTool Team</span>
                </div>
            </div>
        </header>

        <!-- TOC -->
        <nav class="toc" aria-label="Table of Contents">
            <div class="toc-title">Table of Contents</div>
            <ol class="toc-list">
                <li><a href="#what-is-regex">What Is Regex (And Why Learn It)</a></li>
                <li><a href="#literal-matching">Literal Matching: The Basics</a></li>
                <li><a href="#metacharacters">Metacharacters and Special Characters</a></li>
                <li><a href="#character-classes">Character Classes</a></li>
                <li><a href="#quantifiers">Quantifiers: How Many</a></li>
                <li><a href="#anchors">Anchors: Where to Match</a></li>
                <li><a href="#groups">Groups and Capturing</a></li>
                <li><a href="#alternation">Alternation (OR)</a></li>
                <li><a href="#lookaheads">Lookaheads and Lookbehinds</a></li>
                <li><a href="#flags">Flags and Modifiers</a></li>
                <li><a href="#practical-examples">Practical Examples</a></li>
                <li><a href="#tools">Regex Tools</a></li>
                <li><a href="#faq">Frequently Asked Questions</a></li>
            </ol>
        </nav>

        <!-- Content -->
        <div class="article-content" itemprop="articleBody">

            <h2 id="what-is-regex">What Is Regex (And Why Learn It)</h2>

            <p>A regular expression (regex) is a pattern that describes a set of strings. Instead of searching for a specific piece of text, you search for <strong>anything that matches a pattern</strong>.</p>

            <p>Consider this: you have a log file with 10,000 lines and you need to find every IP address. You could read each line manually. Or you could use the regex pattern <code>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}</code> and find them all in under a second.</p>

            <p>Regex is used everywhere in software development:</p>

            <ul>
                <li><strong>Form validation</strong> &mdash; Check if an email, phone number, or URL is formatted correctly.</li>
                <li><strong>Search and replace</strong> &mdash; Find all dates in <code>MM/DD/YYYY</code> format and convert them to <code>YYYY-MM-DD</code>.</li>
                <li><strong>Log parsing</strong> &mdash; Extract timestamps, error codes, or IP addresses from server logs.</li>
                <li><strong>Data cleaning</strong> &mdash; Strip unwanted characters, normalize whitespace, or extract structured data from unstructured text.</li>
                <li><strong>Code refactoring</strong> &mdash; Rename variables, update function signatures, or migrate API calls across an entire codebase.</li>
            </ul>

            <p>Every major programming language supports regex: JavaScript, Python, Java, Go, Ruby, PHP, C#, Rust, and more. The core syntax is the same across all of them. Learn it once, use it everywhere.</p>

            <p>Open NexTool's <a href="/free-tools/regex-tester.html">Regex Tester</a> in another tab. As you read each section, paste the examples in and experiment. Interactive practice is the fastest way to learn regex.</p>

            <h2 id="literal-matching">Literal Matching: The Basics</h2>

            <p>The simplest regex is a literal string. The pattern <code>cat</code> matches the text "cat" wherever it appears.</p>

            <div class="code-label">regex &mdash; Literal Matches</div>
<pre><code>Pattern: cat
Text:    "The cat sat on the caterpillar"
Matches: "The [cat] sat on the [cat]erpillar"
                ^^^                ^^^

Pattern: 404
Text:    "Error 404: Not Found (code 404)"
Matches: "Error [404]: Not Found (code [404])"</code></pre>

            <p>Regex is case-sensitive by default. The pattern <code>Cat</code> does not match "cat". You can change this with the <code>i</code> flag (covered in the Flags section).</p>

            <div class="info-box">
                <div class="info-box-title">Key Concept</div>
                <p>Regex finds all occurrences of the pattern within the text (when using the global flag). It does not just find the first one. This is what makes it powerful for search-and-replace operations.</p>
            </div>

            <h2 id="metacharacters">Metacharacters and Special Characters</h2>

            <p>Certain characters have special meaning in regex. These are called <strong>metacharacters</strong>. To match them literally, you need to escape them with a backslash (<code>\</code>).</p>

            <table>
                <thead>
                    <tr>
                        <th>Character</th>
                        <th>Meaning</th>
                        <th>To Match Literally</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>.</code></td>
                        <td>Any single character (except newline)</td>
                        <td><code>\.</code></td>
                    </tr>
                    <tr>
                        <td><code>*</code></td>
                        <td>Zero or more of the preceding element</td>
                        <td><code>\*</code></td>
                    </tr>
                    <tr>
                        <td><code>+</code></td>
                        <td>One or more of the preceding element</td>
                        <td><code>\+</code></td>
                    </tr>
                    <tr>
                        <td><code>?</code></td>
                        <td>Zero or one of the preceding element</td>
                        <td><code>\?</code></td>
                    </tr>
                    <tr>
                        <td><code>^</code></td>
                        <td>Start of string (or line)</td>
                        <td><code>\^</code></td>
                    </tr>
                    <tr>
                        <td><code>$</code></td>
                        <td>End of string (or line)</td>
                        <td><code>\$</code></td>
                    </tr>
                    <tr>
                        <td><code>[ ]</code></td>
                        <td>Character class</td>
                        <td><code>\[</code> and <code>\]</code></td>
                    </tr>
                    <tr>
                        <td><code>( )</code></td>
                        <td>Grouping / capturing</td>
                        <td><code>\(</code> and <code>\)</code></td>
                    </tr>
                    <tr>
                        <td><code>{ }</code></td>
                        <td>Quantifier range</td>
                        <td><code>\{</code> and <code>\}</code></td>
                    </tr>
                    <tr>
                        <td><code>|</code></td>
                        <td>Alternation (OR)</td>
                        <td><code>\|</code></td>
                    </tr>
                    <tr>
                        <td><code>\</code></td>
                        <td>Escape character</td>
                        <td><code>\\</code></td>
                    </tr>
                </tbody>
            </table>

            <div class="code-label">regex &mdash; The Dot Matches (Almost) Anything</div>
<pre><code>Pattern: c.t
Text:    "cat cot cut c3t c_t c t"
Matches: [cat] [cot] [cut] [c3t] [c_t] [c t]

Pattern: 192\.168\.1\.1
Text:    "Server at 192.168.1.1 responded"
Matches: "Server at [192.168.1.1] responded"
(Without escaping the dots: 192.168.1.1 would also match "192x168y1z1")</code></pre>

            <h2 id="character-classes">Character Classes</h2>

            <p>A character class matches <strong>one character</strong> from a set. You define the set inside square brackets.</p>

            <table>
                <thead>
                    <tr>
                        <th>Pattern</th>
                        <th>Matches</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>[abc]</code></td>
                        <td>Any one of a, b, or c</td>
                        <td><code>[abc]</code> matches "a" in "apple"</td>
                    </tr>
                    <tr>
                        <td><code>[a-z]</code></td>
                        <td>Any lowercase letter</td>
                        <td><code>[a-z]</code> matches "h" in "Hello"</td>
                    </tr>
                    <tr>
                        <td><code>[A-Z]</code></td>
                        <td>Any uppercase letter</td>
                        <td><code>[A-Z]</code> matches "H" in "Hello"</td>
                    </tr>
                    <tr>
                        <td><code>[0-9]</code></td>
                        <td>Any digit</td>
                        <td><code>[0-9]</code> matches "4" in "Room 4B"</td>
                    </tr>
                    <tr>
                        <td><code>[a-zA-Z0-9]</code></td>
                        <td>Any alphanumeric character</td>
                        <td>Combine ranges in one class</td>
                    </tr>
                    <tr>
                        <td><code>[^abc]</code></td>
                        <td>Any character EXCEPT a, b, or c</td>
                        <td><code>[^0-9]</code> matches any non-digit</td>
                    </tr>
                </tbody>
            </table>

            <h3>Shorthand Character Classes</h3>

            <p>Regex provides shorthand notation for common character classes. These save typing and improve readability.</p>

            <table>
                <thead>
                    <tr>
                        <th>Shorthand</th>
                        <th>Equivalent</th>
                        <th>Matches</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>\d</code></td>
                        <td><code>[0-9]</code></td>
                        <td>Any digit</td>
                    </tr>
                    <tr>
                        <td><code>\D</code></td>
                        <td><code>[^0-9]</code></td>
                        <td>Any non-digit</td>
                    </tr>
                    <tr>
                        <td><code>\w</code></td>
                        <td><code>[a-zA-Z0-9_]</code></td>
                        <td>Any "word" character</td>
                    </tr>
                    <tr>
                        <td><code>\W</code></td>
                        <td><code>[^a-zA-Z0-9_]</code></td>
                        <td>Any non-word character</td>
                    </tr>
                    <tr>
                        <td><code>\s</code></td>
                        <td><code>[ \t\n\r\f]</code></td>
                        <td>Any whitespace</td>
                    </tr>
                    <tr>
                        <td><code>\S</code></td>
                        <td><code>[^ \t\n\r\f]</code></td>
                        <td>Any non-whitespace</td>
                    </tr>
                </tbody>
            </table>

            <div class="code-label">regex &mdash; Character Class Examples</div>
<pre><code>Pattern: \d\d\d-\d\d\d\d
Text:    "Call 555-1234 or 800-5678"
Matches: "Call [555-1234] or [800-5678]"

Pattern: [aeiou]
Text:    "Hello World"
Matches: "H[e]ll[o] W[o]rld"

Pattern: [^aeiou\s]
Text:    "Hello World"
Matches: "[H]e[l][l]o [W]o[r][l][d]"  (consonants only)</code></pre>

            <h2 id="quantifiers">Quantifiers: How Many</h2>

            <p>Quantifiers specify <strong>how many times</strong> the preceding element should be matched.</p>

            <table>
                <thead>
                    <tr>
                        <th>Quantifier</th>
                        <th>Meaning</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>*</code></td>
                        <td>Zero or more</td>
                        <td><code>ab*c</code> matches "ac", "abc", "abbc"</td>
                    </tr>
                    <tr>
                        <td><code>+</code></td>
                        <td>One or more</td>
                        <td><code>ab+c</code> matches "abc", "abbc" (not "ac")</td>
                    </tr>
                    <tr>
                        <td><code>?</code></td>
                        <td>Zero or one (optional)</td>
                        <td><code>colou?r</code> matches "color" and "colour"</td>
                    </tr>
                    <tr>
                        <td><code>{3}</code></td>
                        <td>Exactly 3</td>
                        <td><code>\d{3}</code> matches "123" (not "12" or "1234")</td>
                    </tr>
                    <tr>
                        <td><code>{2,4}</code></td>
                        <td>Between 2 and 4</td>
                        <td><code>\d{2,4}</code> matches "12", "123", "1234"</td>
                    </tr>
                    <tr>
                        <td><code>{3,}</code></td>
                        <td>3 or more</td>
                        <td><code>\w{3,}</code> matches words with 3+ characters</td>
                    </tr>
                </tbody>
            </table>

            <h3>Greedy vs Lazy Quantifiers</h3>

            <p>By default, quantifiers are <strong>greedy</strong>: they match as much text as possible. Adding <code>?</code> after a quantifier makes it <strong>lazy</strong>: it matches as little as possible.</p>

            <div class="code-label">regex &mdash; Greedy vs Lazy</div>
<pre><code>Text: "&lt;b&gt;bold&lt;/b&gt; and &lt;b&gt;more&lt;/b&gt;"

Greedy:  &lt;b&gt;.*&lt;/b&gt;
Match:   [&lt;b&gt;bold&lt;/b&gt; and &lt;b&gt;more&lt;/b&gt;]  (one big match)

Lazy:    &lt;b&gt;.*?&lt;/b&gt;
Matches: [&lt;b&gt;bold&lt;/b&gt;] and [&lt;b&gt;more&lt;/b&gt;]  (two separate matches)</code></pre>

            <div class="info-box warning">
                <div class="info-box-title">Common Mistake</div>
                <p>Using <code>.*</code> (greedy dot-star) is the most common source of unexpected regex behavior. When in doubt, use <code>.*?</code> (lazy) or be more specific about what characters you expect.</p>
            </div>

            <h2 id="anchors">Anchors: Where to Match</h2>

            <p>Anchors do not match characters. They match <strong>positions</strong> within the string.</p>

            <table>
                <thead>
                    <tr>
                        <th>Anchor</th>
                        <th>Matches</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>^</code></td>
                        <td>Start of string (or line with <code>m</code> flag)</td>
                        <td><code>^Hello</code> matches "Hello" only at the start</td>
                    </tr>
                    <tr>
                        <td><code>$</code></td>
                        <td>End of string (or line with <code>m</code> flag)</td>
                        <td><code>world$</code> matches "world" only at the end</td>
                    </tr>
                    <tr>
                        <td><code>\b</code></td>
                        <td>Word boundary</td>
                        <td><code>\bcat\b</code> matches "cat" but not "caterpillar"</td>
                    </tr>
                    <tr>
                        <td><code>\B</code></td>
                        <td>Not a word boundary</td>
                        <td><code>\Bcat</code> matches "cat" in "scat" but not "cat" alone</td>
                    </tr>
                </tbody>
            </table>

            <div class="code-label">regex &mdash; Anchor Examples</div>
<pre><code>Pattern: ^Error
Text:    "Error: file not found\nWarning: low disk\nError: timeout"
Matches: [Error]: file not found  (only the first "Error" at line start)

Pattern: \bcat\b
Text:    "The cat chased the caterpillar into the bobcat's cave"
Matches: "The [cat] chased the caterpillar into the bobcat's cave"
(Only the standalone word "cat", not "caterpillar" or "bobcat")</code></pre>

            <h2 id="groups">Groups and Capturing</h2>

            <p>Parentheses <code>( )</code> serve two purposes: they group parts of a pattern together, and they capture the matched text for later use.</p>

            <div class="code-label">regex &mdash; Capturing Groups</div>
<pre><code>Pattern: (\d{4})-(\d{2})-(\d{2})
Text:    "Date: 2026-02-14"

Full match:  "2026-02-14"
Group 1:     "2026"    (year)
Group 2:     "02"      (month)
Group 3:     "14"      (day)</code></pre>

            <h3>Named Groups</h3>

            <p>Named groups make your regex self-documenting and easier to reference in code.</p>

            <div class="code-label">javascript &mdash; Named Capture Groups</div>
<pre><code>const dateRegex = /(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/;
const match = '2026-02-14'.match(dateRegex);

console.log(match.groups.year);   // "2026"
console.log(match.groups.month);  // "02"
console.log(match.groups.day);    // "14"</code></pre>

            <div class="code-label">python &mdash; Named Capture Groups</div>
<pre><code>import re

pattern = r'(?P&lt;year&gt;\d{4})-(?P&lt;month&gt;\d{2})-(?P&lt;day&gt;\d{2})'
match = re.search(pattern, '2026-02-14')

print(match.group('year'))   # "2026"
print(match.group('month'))  # "02"
print(match.group('day'))    # "14"</code></pre>

            <h3>Non-Capturing Groups</h3>

            <p>When you need grouping but not capturing (to avoid polluting your match groups), use <code>(?:...)</code>.</p>

            <div class="code-label">regex &mdash; Non-Capturing Group</div>
<pre><code>Pattern: (?:https?|ftp)://(\S+)
Text:    "Visit https://example.com"

Full match: "https://example.com"
Group 1:    "example.com"   (only the domain is captured)
(The protocol group is NOT captured because of ?:)</code></pre>

            <h3>Backreferences</h3>

            <p>You can reference a previously captured group within the same pattern using <code>\1</code>, <code>\2</code>, etc.</p>

            <div class="code-label">regex &mdash; Backreference to Find Duplicates</div>
<pre><code>Pattern: \b(\w+)\s+\1\b
Text:    "The the quick brown fox fox jumped"
Matches: "[The the]" and "[fox fox]"
(Finds repeated words)</code></pre>

            <p>Try these group patterns in NexTool's <a href="/free-tools/regex-playground.html">Regex Playground</a>, which visualizes capture groups and highlights each group in a different color.</p>

            <h2 id="alternation">Alternation (OR)</h2>

            <p>The pipe character <code>|</code> acts as a logical OR. It matches the pattern on either side.</p>

            <div class="code-label">regex &mdash; Alternation</div>
<pre><code>Pattern: cat|dog|bird
Text:    "I have a cat and a dog"
Matches: "I have a [cat] and a [dog]"

Pattern: (Mon|Tue|Wed|Thu|Fri|Sat|Sun)day
Text:    "Monday and Friday are my favorites"
Matches: "[Monday] and [Friday] are my favorites"

Pattern: \.(jpg|jpeg|png|gif|webp)$
Text:    "photo.jpg"
Matches: "photo[.jpg]"  (matches image file extensions)</code></pre>

            <h2 id="lookaheads">Lookaheads and Lookbehinds</h2>

            <p>Lookarounds are "zero-width assertions." They check if a pattern exists ahead or behind the current position <strong>without including it in the match</strong>. Think of them as conditions that must be true, but the matched text stays out of the result.</p>

            <table>
                <thead>
                    <tr>
                        <th>Syntax</th>
                        <th>Name</th>
                        <th>What It Does</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>(?=...)</code></td>
                        <td>Positive lookahead</td>
                        <td>What follows MUST match</td>
                    </tr>
                    <tr>
                        <td><code>(?!...)</code></td>
                        <td>Negative lookahead</td>
                        <td>What follows must NOT match</td>
                    </tr>
                    <tr>
                        <td><code>(?&lt;=...)</code></td>
                        <td>Positive lookbehind</td>
                        <td>What precedes MUST match</td>
                    </tr>
                    <tr>
                        <td><code>(?&lt;!...)</code></td>
                        <td>Negative lookbehind</td>
                        <td>What precedes must NOT match</td>
                    </tr>
                </tbody>
            </table>

            <div class="code-label">regex &mdash; Lookaround Examples</div>
<pre><code>// Positive lookahead: match a number followed by "px"
Pattern: \d+(?=px)
Text:    "width: 100px; height: 200em;"
Matches: "[100]px"  (matches 100, not 200)

// Negative lookahead: match "http" NOT followed by "s"
Pattern: http(?!s)
Text:    "http://old.com and https://new.com"
Matches: "[http]://old.com"  (matches insecure only)

// Positive lookbehind: match digits preceded by "$"
Pattern: (?&lt;=\$)\d+
Text:    "Price: $49 and EUR 30"
Matches: "Price: $[49] and EUR 30"  (matches 49, not 30)

// Negative lookbehind: match digits NOT preceded by "#"
Pattern: (?&lt;!#)\b\d+\b
Text:    "Item #42 costs 99"
Matches: "Item #42 costs [99]"  (matches 99, not 42)</code></pre>

            <div class="info-box">
                <div class="info-box-title">Browser Support</div>
                <p>Lookbehinds (<code>(?&lt;=...)</code> and <code>(?&lt;!...)</code>) were added to JavaScript in ES2018. They work in all modern browsers (Chrome 62+, Firefox 78+, Safari 16.4+, Edge 79+). In older environments, use a capturing group as a workaround.</p>
            </div>

            <h2 id="flags">Flags and Modifiers</h2>

            <p>Flags change how the regex engine interprets your pattern. They are added after the closing delimiter in most languages.</p>

            <table>
                <thead>
                    <tr>
                        <th>Flag</th>
                        <th>Name</th>
                        <th>Effect</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>g</code></td>
                        <td>Global</td>
                        <td>Find all matches, not just the first.</td>
                    </tr>
                    <tr>
                        <td><code>i</code></td>
                        <td>Case-insensitive</td>
                        <td><code>/hello/i</code> matches "Hello", "HELLO", "hElLo".</td>
                    </tr>
                    <tr>
                        <td><code>m</code></td>
                        <td>Multiline</td>
                        <td><code>^</code> and <code>$</code> match line starts/ends, not just string starts/ends.</td>
                    </tr>
                    <tr>
                        <td><code>s</code></td>
                        <td>Dot-all</td>
                        <td><code>.</code> matches newline characters too (normally it does not).</td>
                    </tr>
                    <tr>
                        <td><code>u</code></td>
                        <td>Unicode</td>
                        <td>Enable Unicode matching. Required for emoji and non-Latin characters.</td>
                    </tr>
                </tbody>
            </table>

            <div class="code-label">javascript &mdash; Using Flags</div>
<pre><code>// Find all email-like patterns, case insensitive
const emails = text.match(/[\w.+-]+@[\w-]+\.[\w.]+/gi);

// Match at the start of each line (multiline)
const headings = text.match(/^#+\s.+/gm);

// Match across newlines (dotall)
const blocks = text.match(/\{.*?\}/gs);</code></pre>

            <h2 id="practical-examples">Practical Examples</h2>

            <p>Here are real-world regex patterns you will use regularly. Each one is tested and ready to copy.</p>

            <h3>Email Validation (Basic)</h3>

            <div class="code-label">regex</div>
<pre><code>^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$

Matches:    user@example.com, first.last+tag@sub.domain.co
No match:   @example.com, user@, user@.com</code></pre>

            <h3>URL Matching</h3>

            <div class="code-label">regex</div>
<pre><code>https?://[^\s/$.?#].[^\s]*

Matches:    https://example.com/path?q=1
            http://sub.domain.co.uk/page#section</code></pre>

            <h3>Phone Number (US Format)</h3>

            <div class="code-label">regex</div>
<pre><code>^(\+1[-.\s]?)?(\(?\d{3}\)?[-.\s]?)?\d{3}[-.\s]?\d{4}$

Matches:    555-123-4567, (555) 123-4567, +1 555.123.4567
            5551234567, +1-555-123-4567</code></pre>

            <h3>Extract HTML Tags</h3>

            <div class="code-label">regex</div>
<pre><code>&lt;(\w+)([^&gt;]*)&gt;(.*?)&lt;/\1&gt;

Group 1: tag name
Group 2: attributes
Group 3: content

Text:    "&lt;h1 class='title'&gt;Hello World&lt;/h1&gt;"
Match:   tag="h1", attrs=" class='title'", content="Hello World"</code></pre>

            <h3>Password Strength Check</h3>

            <div class="code-label">regex &mdash; Minimum 8 chars, 1 upper, 1 lower, 1 digit</div>
<pre><code>^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$

Matches:    "Password1", "myS3cure", "Ab12345678"
No match:   "password", "PASSWORD1", "Pass1", "12345678"

Breakdown:
  (?=.*[a-z])  - at least one lowercase letter (lookahead)
  (?=.*[A-Z])  - at least one uppercase letter (lookahead)
  (?=.*\d)     - at least one digit (lookahead)
  .{8,}        - at least 8 characters total</code></pre>

            <h3>Find and Replace: Date Format Conversion</h3>

            <div class="code-label">javascript &mdash; MM/DD/YYYY to YYYY-MM-DD</div>
<pre><code>const text = "Start: 02/14/2026, End: 03/15/2026";

const result = text.replace(
  /(\d{2})\/(\d{2})\/(\d{4})/g,
  '$3-$1-$2'
);

console.log(result);
// "Start: 2026-02-14, End: 2026-03-15"</code></pre>

            <h3>Slug Generator</h3>

            <div class="code-label">javascript &mdash; Convert Title to URL Slug</div>
<pre><code>function slugify(text) {
  return text
    .toLowerCase()
    .replace(/[^\w\s-]/g, '')     // Remove non-word chars (except spaces and hyphens)
    .replace(/\s+/g, '-')         // Replace spaces with hyphens
    .replace(/-+/g, '-')          // Collapse multiple hyphens
    .replace(/^-+|-+$/g, '');     // Trim hyphens from ends
}

slugify("Hello World! This is a Test");
// "hello-world-this-is-a-test"</code></pre>

            <p>For quick slug generation without writing code, use NexTool's <a href="/free-tools/slug-generator.html">Slug Generator</a> tool. And you can test all the patterns above in the <a href="/free-tools/regex-tester.html">Regex Tester</a>.</p>

            <div class="cta-box">
                <h3>Test Your Regex Patterns Live</h3>
                <p>NexTool's free Regex Tester highlights matches in real time, shows capture groups, and explains your pattern. No signup required.</p>
                <a href="/free-tools/regex-tester.html" class="cta-button">Open Regex Tester</a>
                <a href="/free-tools/regex-builder.html" class="cta-button secondary">Regex Builder</a>
            </div>

            <h2 id="tools">Regex Tools</h2>

            <div class="tool-grid">
                <a href="/free-tools/regex-tester.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F50D;</div>
                    <div class="tool-card-name">Regex Tester</div>
                    <div class="tool-card-desc">Test regex patterns against any text with real-time match highlighting and group extraction.</div>
                </a>
                <a href="/free-tools/regex-builder.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F3D7;</div>
                    <div class="tool-card-name">Regex Builder</div>
                    <div class="tool-card-desc">Build regex patterns visually with a point-and-click interface. No syntax memorization needed.</div>
                </a>
                <a href="/free-tools/regex-playground.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F3AE;</div>
                    <div class="tool-card-name">Regex Playground</div>
                    <div class="tool-card-desc">Interactive regex sandbox with pattern visualization, group coloring, and step-by-step matching.</div>
                </a>
                <a href="/free-tools/text-case-converter.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F524;</div>
                    <div class="tool-card-name">Text Case Converter</div>
                    <div class="tool-card-desc">Convert text between camelCase, snake_case, kebab-case, and more. Regex-powered transformations.</div>
                </a>
                <a href="/free-tools/slug-generator.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F517;</div>
                    <div class="tool-card-name">Slug Generator</div>
                    <div class="tool-card-desc">Convert any text to a URL-friendly slug. Uses regex under the hood for character normalization.</div>
                </a>
                <a href="/free-tools/html-entity-encoder.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F4BB;</div>
                    <div class="tool-card-name">HTML Entity Encoder</div>
                    <div class="tool-card-desc">Encode and decode HTML entities. Useful for escaping regex metacharacters in HTML contexts.</div>
                </a>
            </div>

            <hr>

            <div class="faq-section" id="faq">
                <h2>Frequently Asked Questions</h2>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>What is a regular expression (regex)?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>A regular expression (regex or regexp) is a sequence of characters that defines a search pattern. It is used to match, search, extract, or replace text based on patterns rather than exact strings. For example, the regex \d{3}-\d{4} matches any phone number in the format 555-1234 (three digits, a hyphen, four digits). Regular expressions are supported in virtually every programming language including JavaScript, Python, Java, Go, Ruby, PHP, and C#, as well as in command-line tools like grep, sed, and awk.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>What is the difference between greedy and lazy quantifiers?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Greedy quantifiers (*, +, {n,m}) match as much text as possible while still allowing the overall pattern to succeed. Lazy quantifiers (*?, +?, {n,m}?) match as little text as possible. For example, given the string "&lt;b&gt;bold&lt;/b&gt; and &lt;b&gt;more&lt;/b&gt;", the greedy pattern &lt;b&gt;.*&lt;/b&gt; matches everything between the first &lt;b&gt; and the last &lt;/b&gt;. The lazy pattern &lt;b&gt;.*?&lt;/b&gt; matches only "&lt;b&gt;bold&lt;/b&gt;" (stops at the first closing tag). Use lazy quantifiers when you want the shortest possible match, which is common when parsing HTML, extracting quoted strings, or matching delimited content.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>How do I validate an email address with regex?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>A practical email validation regex is: ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ which matches most valid email addresses by checking for one or more alphanumeric characters (plus common special characters) before the @ symbol, followed by a domain name with at least one dot and a top-level domain of 2 or more letters. Note that the full RFC 5322 email specification is extremely complex and nearly impossible to match perfectly with regex alone. For production applications, use a simple regex for basic format checking, then verify the email actually exists by sending a confirmation message.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>What are lookaheads and lookbehinds in regex?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Lookaheads and lookbehinds (collectively called lookarounds) are zero-width assertions that check whether a pattern exists before or after the current position without including it in the match. A positive lookahead (?=pattern) asserts that what follows matches the pattern. A negative lookahead (?!pattern) asserts that what follows does NOT match. A positive lookbehind (?&lt;=pattern) asserts that what precedes matches the pattern. A negative lookbehind (?&lt;!pattern) asserts that what precedes does NOT match. Example: \d+(?= dollars) matches "100" in "100 dollars" but not "100" in "100 euros", because it requires "dollars" to follow without including it in the match.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>Which programming languages support regex?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Virtually every modern programming language supports regular expressions. JavaScript uses /pattern/flags syntax or the RegExp constructor. Python provides the re module with functions like re.match(), re.search(), re.findall(), and re.sub(). Java has the java.util.regex package with Pattern and Matcher classes. Go has the regexp package. Ruby has built-in regex with the =~ operator. PHP offers preg_match() and preg_replace() functions. C# uses the System.Text.RegularExpressions namespace. Command-line tools like grep, sed, and awk also use regex extensively. While the core syntax is similar across languages, there are differences in supported features and escaping rules.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>How can I test and debug regular expressions?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Use an interactive regex tester that highlights matches in real time as you type. NexTool's free Regex Tester lets you enter a pattern and test string, see all matches highlighted, view capture groups, and get an explanation of what each part of your pattern does. When debugging, start simple: build your pattern incrementally, testing each piece before adding complexity. Use the verbose/extended flag (x in Python) to add comments to complex patterns. Break long patterns into named groups for readability. The Regex Builder tool can also help you construct patterns visually without memorizing syntax.</p>
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <!-- Author -->
        <div class="author-box">
            <div class="author-avatar">NT</div>
            <div class="author-info">
                <h4>NexTool Team</h4>
                <p>We build free developer tools including regex testers, code formatters, and data converters. Over 150 tools, all browser-based, no signup required.</p>
            </div>
        </div>

        <!-- Bottom CTA -->
        <div class="cta-box">
            <h3>150+ Developer Tools, One Place</h3>
            <p>NexTool Pro ($29) unlocks clean output, enhanced features, and unlimited workspace. One payment, lifetime access.</p>
            <a href="https://nextool.app/free-tools/pro-upgrade.html" class="cta-button">Get NexTool Pro &mdash; $29</a>
            <a href="/free-tools/" class="cta-button secondary">Try Free Tools</a>
        </div>

    </article>

    <!-- Footer -->
    
<!-- AUTO-LINKED by NexTool Engine -->
<div style="margin:2rem 0;padding:1.5rem;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius)">
<p style="font-weight:600;margin-bottom:.5rem">Related Tools</p>
<p><a href="/free-tools/emoji-picker.html" style="color:var(--primary);text-decoration:none">Emoji Picker & Search</a>  <a href="/free-tools/box-shadow-generator.html" style="color:var(--primary);text-decoration:none">CSS Box Shadow Generator</a>  <a href="/free-tools/json-to-yaml-converter.html" style="color:var(--primary);text-decoration:none">Free JSON to YAML Converter</a></p>
</div>

<!-- AUTO-LINKED by NexTool Engine -->
<div style="margin:2rem 0;padding:1.5rem;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius)">
<p style="font-weight:600;margin-bottom:.5rem">Related Tools</p>
<p><a href="/free-tools/json-to-yaml.html" style="color:var(--primary);text-decoration:none">Free JSON to YAML Converter</a>  <a href="/free-tools/regex-generator.html" style="color:var(--primary);text-decoration:none">Free Regex Pattern Generator</a>  <a href="/free-tools/yaml-to-json.html" style="color:var(--primary);text-decoration:none">YAML to JSON Converter</a></p>
</div>
<footer class="footer">
        <div class="footer-inner">
            <div class="footer-links">
                <a href="https://nextool.app">Home</a>
                <a href="https://nextool.app/#services">Tools</a>
                <a href="https://nextool.app/free-tools/">Free Tools</a>
                <a href="https://nextool.app/blog/">Blog</a>
                <a href="https://nextool.app/#contact">Contact</a>
            </div>
            <p>&copy; 2026 NexTool. All rights reserved. 227+ free developer tools.</p>
        </div>
    </footer>

    <!-- FAQ Script -->
    <script>
        function toggleFAQ(button) {
            const item = button.parentElement;
            const answer = item.querySelector('.faq-answer');
            const isOpen = item.classList.contains('open');

            document.querySelectorAll('.faq-item').forEach(faq => {
                faq.classList.remove('open');
                faq.querySelector('.faq-answer').style.maxHeight = null;
            });

            if (!isOpen) {
                item.classList.add('open');
                answer.style.maxHeight = answer.scrollHeight + 'px';
            }
        }
    </script>

    <!-- Revenue Scripts -->
    <script defer src="/js/analytics-lite.js"></script>
    <script defer src="/js/revenue.js"></script>
    <script defer src="/js/lead-capture.js"></script>
</body>
</html>