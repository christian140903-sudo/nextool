<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docker Compose: Complete Guide for Developers | NexTool</title>
    <meta name="description" content="Master Docker Compose from basics to production. Learn docker-compose.yml syntax, services, networks, volumes, environment variables, health checks, multi-stage builds, and deployment best practices.">
    <meta name="keywords" content="docker compose, docker-compose.yml, docker compose tutorial, docker compose services, docker compose volumes, docker compose networks, docker compose production, docker compose guide">
    <meta name="author" content="NexTool Team">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://nextool.app/blog/docker-compose-complete-guide.html">

    <!-- Open Graph -->
    <meta property="og:type" content="article">
    <meta property="og:title" content="Docker Compose: Complete Guide for Developers">
    <meta property="og:description" content="Master Docker Compose from basics to production. Services, networks, volumes, environment variables, health checks, and deployment best practices with real examples.">
    <meta property="og:url" content="https://nextool.app/blog/docker-compose-complete-guide.html">
    <meta property="og:site_name" content="NexTool">
    <meta property="og:image" content="https://nextool.app/assets/images/blog/docker-compose-complete-guide-og.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="article:published_time" content="2026-02-14T09:00:00Z">
    <meta property="article:modified_time" content="2026-02-14T09:00:00Z">
    <meta property="article:author" content="NexTool Team">
    <meta property="article:section" content="Tutorial">
    <meta property="article:tag" content="Docker">
    <meta property="article:tag" content="DevOps">
    <meta property="article:tag" content="Containers">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Docker Compose: Complete Guide for Developers">
    <meta name="twitter:description" content="Master Docker Compose from basics to production. Services, networks, volumes, health checks, and deployment best practices.">
    <meta name="twitter:image" content="https://nextool.app/assets/images/blog/docker-compose-complete-guide-og.png">

    <!-- JSON-LD: Article -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Article",
        "headline": "Docker Compose: Complete Guide for Developers",
        "description": "Master Docker Compose from basics to production. Learn docker-compose.yml syntax, services, networks, volumes, environment variables, health checks, multi-stage builds, and deployment best practices.",
        "image": "https://nextool.app/assets/images/blog/docker-compose-complete-guide-og.png",
        "author": {
            "@type": "Organization",
            "name": "NexTool Team",
            "url": "https://nextool.app"
        },
        "publisher": {
            "@type": "Organization",
            "name": "NexTool",
            "logo": {
                "@type": "ImageObject",
                "url": "https://nextool.app/assets/images/logo.png"
            }
        },
        "datePublished": "2026-02-14T09:00:00Z",
        "dateModified": "2026-02-14T09:00:00Z",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://nextool.app/blog/docker-compose-complete-guide.html"
        },
        "wordCount": 2800,
        "keywords": ["docker compose", "docker-compose.yml", "docker compose tutorial", "docker services", "docker volumes", "docker networks", "container orchestration"]
    }
    </script>

    <!-- JSON-LD: BreadcrumbList -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BreadcrumbList",
        "itemListElement": [
            {
                "@type": "ListItem",
                "position": 1,
                "name": "Home",
                "item": "https://nextool.app"
            },
            {
                "@type": "ListItem",
                "position": 2,
                "name": "Blog",
                "item": "https://nextool.app/blog/"
            },
            {
                "@type": "ListItem",
                "position": 3,
                "name": "Docker Compose Complete Guide",
                "item": "https://nextool.app/blog/docker-compose-complete-guide.html"
            }
        ]
    }
    </script>

    <!-- JSON-LD: FAQPage -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "FAQPage",
        "mainEntity": [
            {
                "@type": "Question",
                "name": "What is the difference between docker compose up and docker compose start?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "docker compose up creates and starts containers, networks, and volumes as defined in your docker-compose.yml file. If containers do not exist, it builds images (if build context is specified), creates the containers, and starts them. docker compose start only starts existing containers that were previously created but stopped. If the containers do not exist yet, docker compose start will fail. In most workflows you use docker compose up (with the -d flag for detached mode) to bring your entire stack online, and docker compose start only if you previously ran docker compose stop to pause services without removing them."
                }
            },
            {
                "@type": "Question",
                "name": "How do I pass environment variables to Docker Compose services?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Docker Compose supports multiple methods for passing environment variables. You can define them inline in docker-compose.yml using the environment key with key-value pairs. You can reference a .env file using the env_file key, which loads all variables from that file into the container. You can also use variable interpolation in docker-compose.yml with ${VARIABLE_NAME} syntax, which pulls values from your shell environment or a .env file in the same directory as your compose file. For sensitive values like API keys and passwords, use Docker secrets in production or store them in a .env file that is excluded from version control via .gitignore."
                }
            },
            {
                "@type": "Question",
                "name": "What is depends_on and does it wait for a service to be ready?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "depends_on controls the startup order of services in Docker Compose. If service B depends_on service A, Compose will start A before B. However, depends_on only waits for the container to start, not for the application inside it to be ready. A database container might be running but still initializing its data. To wait for actual readiness, use depends_on with a condition set to service_healthy combined with a healthcheck on the dependency. For example, a PostgreSQL service can have a healthcheck that runs pg_isready, and the dependent service uses condition: service_healthy to wait until the database actually accepts connections."
                }
            },
            {
                "@type": "Question",
                "name": "How do Docker Compose volumes work and when should I use them?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Docker Compose volumes persist data outside of containers so it survives container restarts and removals. There are two types: named volumes and bind mounts. Named volumes (defined in the top-level volumes section) are managed by Docker and stored in Docker's internal storage. They are best for database data, application state, and anything that should persist independently of your host filesystem. Bind mounts map a host directory directly into the container (e.g., ./src:/app/src) and are best for development, where you want live code changes reflected in the container without rebuilding. Use named volumes for production data and bind mounts for development source code."
                }
            },
            {
                "@type": "Question",
                "name": "Can I use Docker Compose in production?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Yes, Docker Compose can be used in production for single-host deployments. It is well suited for small to medium applications running on a single server. For production use, add restart policies (restart: unless-stopped), configure health checks, use named volumes for persistent data, set resource limits (memory and CPU), avoid bind mounts, use specific image tags instead of latest, and store secrets securely. For multi-host deployments with load balancing, automatic failover, and horizontal scaling, consider Docker Swarm or Kubernetes instead. Many teams use Docker Compose for development and staging, then deploy to Kubernetes in production."
                }
            },
            {
                "@type": "Question",
                "name": "How do I view logs and debug Docker Compose services?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Use docker compose logs to view output from all services, or docker compose logs [service-name] for a specific service. Add -f to follow logs in real time (similar to tail -f). Add --tail 100 to see only the last 100 lines. For debugging, docker compose exec [service-name] sh opens a shell inside a running container. docker compose ps shows the status of all services. docker compose top shows running processes. If a container keeps crashing, check exit codes with docker compose ps -a and inspect logs for error messages. You can also use docker compose config to validate your docker-compose.yml file before starting services."
                }
            }
        ]
    }
    </script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <style>
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #050508;
            --surface: #0a0a0f;
            --surface-2: #1a1a24;
            --surface-3: #232330;
            --primary: #6366f1;
            --primary-hover: #818cf8;
            --accent: #a855f7;
            --accent-hover: #c084fc;
            --text: #e2e8f0;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --border: #1e1e2e;
            --success: #22c55e;
            --warning: #f59e0b;
            --error: #ef4444;
            --code-bg: #0d0d14;
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --font-mono: 'JetBrains Mono', 'Fira Code', monospace;
            --max-width: 800px;
            --header-height: 64px;
        }

        html { scroll-behavior: smooth; -webkit-text-size-adjust: 100%; }
        body { font-family: var(--font-sans); background: var(--bg); color: var(--text); line-height: 1.75; font-size: 16px; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; overflow-x: hidden; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg); }
        ::-webkit-scrollbar-thumb { background: var(--surface-3); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

        .nav { position: fixed; top: 0; left: 0; right: 0; height: var(--header-height); background: rgba(5, 5, 8, 0.85); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-bottom: 1px solid var(--border); z-index: 1000; display: flex; align-items: center; justify-content: center; }
        .nav-inner { width: 100%; max-width: 1200px; padding: 0 24px; display: flex; align-items: center; justify-content: space-between; }
        .nav-logo { display: flex; align-items: center; gap: 10px; text-decoration: none; color: var(--text); font-weight: 700; font-size: 1.25rem; }
        .nav-logo-icon { width: 32px; height: 32px; background: linear-gradient(135deg, var(--primary), var(--accent)); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 0.875rem; font-weight: 800; color: #fff; }
        .nav-links { display: flex; align-items: center; gap: 28px; list-style: none; }
        .nav-links a { color: var(--text-secondary); text-decoration: none; font-size: 0.9rem; font-weight: 500; transition: color 0.2s; }
        .nav-links a:hover { color: var(--text); }
        .nav-cta { background: var(--primary); color: #fff !important; padding: 8px 20px; border-radius: 8px; font-weight: 600; transition: background 0.2s, transform 0.2s; }
        .nav-cta:hover { background: var(--primary-hover); transform: translateY(-1px); }

        .article-wrapper { max-width: var(--max-width); margin: 0 auto; padding: calc(var(--header-height) + 48px) 24px 80px; }
        .breadcrumb { display: flex; align-items: center; gap: 8px; margin-bottom: 32px; font-size: 0.85rem; color: var(--text-muted); flex-wrap: wrap; }
        .breadcrumb a { color: var(--text-secondary); text-decoration: none; transition: color 0.2s; }
        .breadcrumb a:hover { color: var(--primary); }

        .article-header { margin-bottom: 48px; padding-bottom: 32px; border-bottom: 1px solid var(--border); }
        .article-category { display: inline-block; background: rgba(168, 85, 247, 0.12); color: var(--accent); padding: 4px 14px; border-radius: 20px; font-size: 0.8rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 16px; }
        .article-title { font-size: clamp(2rem, 5vw, 3rem); font-weight: 800; line-height: 1.15; color: var(--text); margin-bottom: 16px; letter-spacing: -0.03em; }
        .article-subtitle { font-size: 1.2rem; color: var(--text-secondary); line-height: 1.6; margin-bottom: 24px; }
        .article-meta { display: flex; align-items: center; gap: 20px; color: var(--text-muted); font-size: 0.875rem; flex-wrap: wrap; }
        .article-meta-item { display: flex; align-items: center; gap: 6px; }
        .article-meta-item svg { width: 16px; height: 16px; opacity: 0.7; }

        .toc { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 24px 28px; margin-bottom: 48px; }
        .toc-title { font-size: 0.85rem; font-weight: 700; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 16px; }
        .toc-list { list-style: none; counter-reset: toc; }
        .toc-list li { counter-increment: toc; margin-bottom: 8px; }
        .toc-list li a { color: var(--text-secondary); text-decoration: none; font-size: 0.925rem; display: flex; align-items: baseline; gap: 10px; transition: color 0.2s, padding-left 0.2s; padding: 4px 0; }
        .toc-list li a::before { content: counter(toc, decimal-leading-zero); color: var(--text-muted); font-size: 0.8rem; font-family: var(--font-mono); min-width: 20px; }
        .toc-list li a:hover { color: var(--primary); padding-left: 4px; }

        .article-content h2 { font-size: 1.75rem; font-weight: 700; color: var(--text); margin-top: 56px; margin-bottom: 20px; letter-spacing: -0.02em; line-height: 1.3; padding-top: 16px; border-top: 1px solid var(--border); }
        .article-content h2:first-child { margin-top: 0; padding-top: 0; border-top: none; }
        .article-content h3 { font-size: 1.3rem; font-weight: 600; color: var(--text); margin-top: 36px; margin-bottom: 14px; line-height: 1.35; }
        .article-content h4 { font-size: 1.1rem; font-weight: 600; color: var(--text-secondary); margin-top: 28px; margin-bottom: 12px; }
        .article-content p { margin-bottom: 20px; color: var(--text-secondary); line-height: 1.8; }
        .article-content a { color: var(--primary); text-decoration: none; border-bottom: 1px solid transparent; transition: border-color 0.2s; }
        .article-content a:hover { border-bottom-color: var(--primary); }
        .article-content strong { color: var(--text); font-weight: 600; }
        .article-content ul, .article-content ol { margin-bottom: 20px; padding-left: 24px; color: var(--text-secondary); }
        .article-content li { margin-bottom: 10px; line-height: 1.7; }
        .article-content li::marker { color: var(--primary); }
        .article-content blockquote { border-left: 3px solid var(--accent); background: var(--surface); padding: 16px 24px; margin: 28px 0; border-radius: 0 8px 8px 0; font-style: italic; color: var(--text-secondary); }
        .article-content blockquote p:last-child { margin-bottom: 0; }
        .article-content hr { border: none; border-top: 1px solid var(--border); margin: 48px 0; }

        .article-content pre { background: var(--code-bg); border: 1px solid var(--border); border-radius: 12px; padding: 20px 24px; overflow-x: auto; margin: 24px 0; }
        .article-content pre code { font-family: var(--font-mono); font-size: 0.875rem; line-height: 1.65; color: var(--text); background: none; padding: 0; border-radius: 0; }
        .article-content code { font-family: var(--font-mono); font-size: 0.85em; background: var(--surface); color: var(--accent); padding: 2px 8px; border-radius: 5px; }
        .code-label { display: inline-block; background: var(--surface-2); color: var(--text-muted); font-family: var(--font-mono); font-size: 0.75rem; padding: 2px 10px; border-radius: 6px 6px 0 0; margin-bottom: -1px; position: relative; top: 1px; }

        .article-content table { width: 100%; border-collapse: collapse; margin: 24px 0; font-size: 0.925rem; }
        .article-content thead th { background: var(--surface); color: var(--text); font-weight: 600; text-align: left; padding: 12px 16px; border-bottom: 2px solid var(--border); }
        .article-content tbody td { padding: 12px 16px; border-bottom: 1px solid var(--border); color: var(--text-secondary); }
        .article-content tbody tr:hover { background: var(--surface); }

        .info-box { background: rgba(99, 102, 241, 0.08); border: 1px solid rgba(99, 102, 241, 0.2); border-radius: 12px; padding: 20px 24px; margin: 28px 0; }
        .info-box.warning { background: rgba(245, 158, 11, 0.08); border-color: rgba(245, 158, 11, 0.2); }
        .info-box.danger { background: rgba(239, 68, 68, 0.08); border-color: rgba(239, 68, 68, 0.2); }
        .info-box.success { background: rgba(34, 197, 94, 0.08); border-color: rgba(34, 197, 94, 0.2); }
        .info-box-title { font-weight: 700; margin-bottom: 8px; font-size: 0.9rem; display: flex; align-items: center; gap: 8px; }
        .info-box p { color: var(--text-secondary); font-size: 0.925rem; margin-bottom: 0; }

        .tool-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 16px; margin: 28px 0; }
        .tool-card { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 20px; text-decoration: none; color: var(--text); transition: border-color 0.2s, transform 0.2s, box-shadow 0.2s; display: flex; flex-direction: column; gap: 8px; }
        .tool-card:hover { border-color: var(--primary); transform: translateY(-2px); box-shadow: 0 8px 24px rgba(99, 102, 241, 0.1); }
        .tool-card-icon { font-size: 1.5rem; margin-bottom: 4px; }
        .tool-card-name { font-weight: 600; font-size: 0.95rem; }
        .tool-card-desc { font-size: 0.825rem; color: var(--text-muted); line-height: 1.5; }

        .cta-box { background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(168, 85, 247, 0.1)); border: 1px solid rgba(99, 102, 241, 0.25); border-radius: 16px; padding: 40px 32px; text-align: center; margin: 48px 0; }
        .cta-box h3 { font-size: 1.5rem; font-weight: 700; margin-bottom: 12px; color: var(--text); }
        .cta-box p { color: var(--text-secondary); margin-bottom: 24px; max-width: 500px; margin-left: auto; margin-right: auto; }
        .cta-button { display: inline-flex; align-items: center; gap: 8px; background: var(--primary); color: #fff; padding: 14px 32px; border-radius: 10px; text-decoration: none; font-weight: 600; font-size: 1rem; transition: background 0.2s, transform 0.2s, box-shadow 0.2s; }
        .cta-button:hover { background: var(--primary-hover); transform: translateY(-2px); box-shadow: 0 8px 32px rgba(99, 102, 241, 0.3); }
        .cta-button.secondary { background: transparent; border: 1px solid var(--primary); color: var(--primary); margin-left: 12px; }
        .cta-button.secondary:hover { background: rgba(99, 102, 241, 0.1); }

        .faq-section { margin-top: 56px; padding-top: 32px; border-top: 1px solid var(--border); }
        .faq-section h2 { margin-top: 0 !important; padding-top: 0 !important; border-top: none !important; }
        .faq-item { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; margin-bottom: 12px; overflow: hidden; }
        .faq-question { width: 100%; background: none; border: none; color: var(--text); padding: 20px 24px; font-size: 1rem; font-weight: 600; text-align: left; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-family: var(--font-sans); transition: background 0.2s; }
        .faq-question:hover { background: var(--surface-2); }
        .faq-question .icon { transition: transform 0.3s; font-size: 1.25rem; color: var(--text-muted); flex-shrink: 0; margin-left: 16px; }
        .faq-item.open .faq-question .icon { transform: rotate(45deg); }
        .faq-answer { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; }
        .faq-answer-inner { padding: 0 24px 20px; color: var(--text-secondary); line-height: 1.7; }

        .author-box { display: flex; align-items: center; gap: 20px; background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 24px; margin: 48px 0; }
        .author-avatar { width: 64px; height: 64px; background: linear-gradient(135deg, var(--primary), var(--accent)); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; font-weight: 700; color: #fff; flex-shrink: 0; }
        .author-info h4 { font-weight: 600; margin-bottom: 4px; }
        .author-info p { color: var(--text-muted); font-size: 0.875rem; margin: 0; line-height: 1.5; }

        .footer { border-top: 1px solid var(--border); padding: 48px 24px; text-align: center; color: var(--text-muted); font-size: 0.85rem; }
        .footer-inner { max-width: 1200px; margin: 0 auto; }
        .footer-links { display: flex; justify-content: center; gap: 24px; margin-bottom: 20px; flex-wrap: wrap; }
        .footer-links a { color: var(--text-secondary); text-decoration: none; transition: color 0.2s; }
        .footer-links a:hover { color: var(--primary); }

        @media (max-width: 768px) {
            .nav-links { display: none; }
            .article-wrapper { padding: calc(var(--header-height) + 24px) 16px 60px; }
            .article-title { font-size: 1.75rem; }
            .tool-grid { grid-template-columns: 1fr; }
            .cta-box { padding: 28px 20px; }
            .cta-button.secondary { margin-left: 0; margin-top: 12px; }
            .author-box { flex-direction: column; text-align: center; }
            .article-content pre { padding: 16px; border-radius: 8px; }
            .article-content h2 { font-size: 1.4rem; }
            .article-content h3 { font-size: 1.15rem; }
            .article-content table { display: block; overflow-x: auto; }
        }
        @media (max-width: 480px) {
            .article-title { font-size: 1.5rem; }
            .toc { padding: 18px 20px; }
        }
    </style>
</head>
<body>

    <!-- Navigation -->
    <nav class="nav">
        <div class="nav-inner">
            <a href="https://nextool.app" class="nav-logo">
                <div class="nav-logo-icon">N</div>
                NexTool
            </a>
            <ul class="nav-links">
                <li><a href="https://nextool.app/#services">Tools</a></li>
                <li><a href="https://nextool.app/free-tools/">Free Tools</a></li>
                <li><a href="https://nextool.app/blog/">Blog</a></li>
                <li><a href="https://nextool.app/#contact" class="nav-cta">Browse Tools</a></li>
            </ul>
        </div>
    </nav>

    <!-- Article -->
    <article class="article-wrapper" itemscope itemtype="https://schema.org/Article">
        <!-- Breadcrumb -->
        <nav class="breadcrumb" aria-label="Breadcrumb">
            <a href="https://nextool.app">Home</a>
            <span class="separator">/</span>
            <a href="https://nextool.app/blog/">Blog</a>
            <span class="separator">/</span>
            <span>Docker Compose Complete Guide</span>
        </nav>

        <!-- Header -->
        <header class="article-header">
            <span class="article-category">Tutorial</span>
            <h1 class="article-title" itemprop="headline">Docker Compose: Complete Guide for Developers</h1>
            <p class="article-subtitle">Everything you need to go from a single Dockerfile to a multi-service production stack. Services, networks, volumes, environment variables, health checks, and real-world patterns you can copy into your projects today.</p>
            <div class="article-meta">
                <div class="article-meta-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>
                    <span>22 min read</span>
                </div>
                <div class="article-meta-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
                    <time datetime="2026-02-14" itemprop="datePublished">February 14, 2026</time>
                </div>
                <div class="article-meta-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>
                    <span itemprop="author">NexTool Team</span>
                </div>
            </div>
        </header>

        <!-- TOC -->
        <nav class="toc" aria-label="Table of Contents">
            <div class="toc-title">Table of Contents</div>
            <ol class="toc-list">
                <li><a href="#what-is-docker-compose">What Is Docker Compose</a></li>
                <li><a href="#compose-file-structure">The docker-compose.yml File Structure</a></li>
                <li><a href="#services">Defining Services</a></li>
                <li><a href="#networks">Networks: Service Communication</a></li>
                <li><a href="#volumes">Volumes: Persistent Data</a></li>
                <li><a href="#environment-variables">Environment Variables and Secrets</a></li>
                <li><a href="#build-context">Build Context and Multi-Stage Builds</a></li>
                <li><a href="#health-checks">Health Checks and depends_on</a></li>
                <li><a href="#essential-commands">Essential Docker Compose Commands</a></li>
                <li><a href="#production">Production Best Practices</a></li>
                <li><a href="#full-example">Full-Stack Example</a></li>
                <li><a href="#tools">Related Tools</a></li>
                <li><a href="#faq">Frequently Asked Questions</a></li>
            </ol>
        </nav>

        <!-- Content -->
        <div class="article-content" itemprop="articleBody">

            <h2 id="what-is-docker-compose">What Is Docker Compose</h2>

            <p>Docker Compose is a tool for defining and running multi-container Docker applications. Instead of starting each container manually with long <code>docker run</code> commands, you describe your entire application stack in a single YAML file and bring it up with one command.</p>

            <p>A typical web application needs at least three services: a web server, an application runtime, and a database. Without Compose, you would need to create a network, start each container in the right order, connect them to the network, map ports, mount volumes, and pass environment variables &mdash; all through separate CLI commands. With Compose, you declare all of that in <code>docker-compose.yml</code> and run <code>docker compose up</code>.</p>

            <p>Docker Compose is built into Docker Desktop and available as a standalone plugin for Docker Engine on Linux. Since Docker Compose V2 (2023), the command is <code>docker compose</code> (with a space), not <code>docker-compose</code> (with a hyphen). The old V1 syntax still works, but V2 is the standard going forward.</p>

            <div class="info-box">
                <div class="info-box-title">Version Note</div>
                <p>The top-level <code>version</code> key in docker-compose.yml (e.g., <code>version: "3.8"</code>) is now optional and ignored by Docker Compose V2. You can omit it entirely. This guide uses the latest specification without a version key.</p>
            </div>

            <h2 id="compose-file-structure">The docker-compose.yml File Structure</h2>

            <p>A Compose file has four top-level keys. You will use <code>services</code> in every project. The other three are needed when your stack grows beyond a single service with default settings.</p>

            <div class="code-label">yaml &mdash; Top-Level Structure</div>
<pre><code>services:    # Required. Defines each container in your application.
  web:
    image: nginx:alpine
  api:
    build: ./api
  db:
    image: postgres:16

networks:    # Optional. Custom networks for service isolation.
  frontend:
  backend:

volumes:     # Optional. Named volumes for persistent data.
  db-data:
  cache-data:

configs:     # Optional. External configuration files.
  nginx-conf:
    file: ./nginx.conf</code></pre>

            <p>The file must be valid YAML. Indentation matters &mdash; use two spaces per level (not tabs). If you are unsure about your YAML syntax, paste it into NexTool's <a href="/free-tools/yaml-formatter.html">YAML Formatter</a> to validate and auto-format it before running <code>docker compose up</code>.</p>

            <h2 id="services">Defining Services</h2>

            <p>Each key under <code>services</code> creates a container. A service can use a pre-built image from Docker Hub or build from a Dockerfile in your project.</p>

            <h3>Using a Pre-Built Image</h3>

            <div class="code-label">yaml &mdash; Service with Image</div>
<pre><code>services:
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    restart: unless-stopped</code></pre>

            <h3>Building from a Dockerfile</h3>

            <div class="code-label">yaml &mdash; Service with Build</div>
<pre><code>services:
  api:
    build:
      context: ./api
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    volumes:
      - ./api/src:/app/src
    restart: unless-stopped</code></pre>

            <h3>Common Service Properties</h3>

            <table>
                <thead>
                    <tr>
                        <th>Property</th>
                        <th>Purpose</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>image</code></td>
                        <td>Docker image to use</td>
                        <td><code>nginx:1.25-alpine</code></td>
                    </tr>
                    <tr>
                        <td><code>build</code></td>
                        <td>Path to Dockerfile</td>
                        <td><code>./app</code> or <code>{context: ./app, dockerfile: Dockerfile.prod}</code></td>
                    </tr>
                    <tr>
                        <td><code>ports</code></td>
                        <td>Map host:container ports</td>
                        <td><code>"8080:80"</code></td>
                    </tr>
                    <tr>
                        <td><code>volumes</code></td>
                        <td>Mount directories or named volumes</td>
                        <td><code>./data:/app/data</code></td>
                    </tr>
                    <tr>
                        <td><code>environment</code></td>
                        <td>Set environment variables</td>
                        <td><code>NODE_ENV: production</code></td>
                    </tr>
                    <tr>
                        <td><code>restart</code></td>
                        <td>Restart policy</td>
                        <td><code>unless-stopped</code>, <code>always</code>, <code>on-failure</code></td>
                    </tr>
                    <tr>
                        <td><code>command</code></td>
                        <td>Override default command</td>
                        <td><code>["npm", "run", "dev"]</code></td>
                    </tr>
                    <tr>
                        <td><code>depends_on</code></td>
                        <td>Startup order</td>
                        <td><code>[db, redis]</code></td>
                    </tr>
                    <tr>
                        <td><code>networks</code></td>
                        <td>Attach to networks</td>
                        <td><code>[frontend, backend]</code></td>
                    </tr>
                </tbody>
            </table>

            <h2 id="networks">Networks: Service Communication</h2>

            <p>Docker Compose creates a default network for your project automatically. All services can reach each other by their service name as a hostname. If your Compose file defines services <code>api</code> and <code>db</code>, the API container can connect to the database at <code>db:5432</code> without any extra configuration.</p>

            <p>Custom networks let you isolate services. A common pattern is separating your frontend-facing services from your backend-only services.</p>

            <div class="code-label">yaml &mdash; Custom Networks</div>
<pre><code>services:
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    networks:
      - frontend

  api:
    build: ./api
    networks:
      - frontend
      - backend

  db:
    image: postgres:16
    networks:
      - backend

networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge
    internal: true    # No external access</code></pre>

            <p>In this setup, <code>nginx</code> can reach <code>api</code> (both on <code>frontend</code>), and <code>api</code> can reach <code>db</code> (both on <code>backend</code>). But <code>nginx</code> cannot reach <code>db</code> directly &mdash; they share no network. The <code>internal: true</code> flag on the backend network also blocks outbound internet access from the database container.</p>

            <div class="info-box">
                <div class="info-box-title">DNS Resolution</div>
                <p>Within a Docker Compose network, services discover each other by name. The service name in your Compose file becomes the DNS hostname. Use it in your connection strings: <code>postgres://user:pass@db:5432/mydb</code>, <code>redis://redis:6379</code>, <code>http://api:3000</code>.</p>
            </div>

            <h2 id="volumes">Volumes: Persistent Data</h2>

            <p>Containers are ephemeral by default. When a container is removed, its filesystem is gone. Volumes solve this by storing data outside the container lifecycle.</p>

            <h3>Named Volumes</h3>

            <p>Named volumes are managed by Docker. They persist until explicitly deleted with <code>docker volume rm</code>. Use them for database data, uploaded files, and application state.</p>

            <div class="code-label">yaml &mdash; Named Volumes</div>
<pre><code>services:
  db:
    image: postgres:16
    volumes:
      - db-data:/var/lib/postgresql/data
    environment:
      POSTGRES_PASSWORD: secret

  redis:
    image: redis:7-alpine
    volumes:
      - redis-data:/data

volumes:
  db-data:
  redis-data:</code></pre>

            <h3>Bind Mounts</h3>

            <p>Bind mounts map a host directory into the container. Changes on either side are reflected immediately. This is essential for development workflows where you want hot reload without rebuilding the image.</p>

            <div class="code-label">yaml &mdash; Bind Mounts for Development</div>
<pre><code>services:
  api:
    build: ./api
    volumes:
      - ./api/src:/app/src          # Source code (live reload)
      - ./api/package.json:/app/package.json
      - /app/node_modules           # Anonymous volume (prevents overwrite)
    command: ["npm", "run", "dev"]</code></pre>

            <p>The anonymous volume <code>/app/node_modules</code> (no host path before the colon) prevents your local <code>node_modules</code> from overwriting the container's installed dependencies. This is a critical pattern when using bind mounts with Node.js projects.</p>

            <h2 id="environment-variables">Environment Variables and Secrets</h2>

            <p>There are three ways to pass environment variables to your containers. Each has different use cases.</p>

            <h3>1. Inline in docker-compose.yml</h3>

            <div class="code-label">yaml</div>
<pre><code>services:
  api:
    image: node:20-alpine
    environment:
      NODE_ENV: production
      PORT: 3000
      LOG_LEVEL: info</code></pre>

            <h3>2. Using an .env File</h3>

            <div class="code-label">yaml</div>
<pre><code>services:
  api:
    image: node:20-alpine
    env_file:
      - ./api/.env
      - ./api/.env.local    # Overrides values from .env</code></pre>

            <div class="code-label">.env</div>
<pre><code>DATABASE_URL=postgres://user:pass@db:5432/myapp
REDIS_URL=redis://redis:6379
JWT_SECRET=your-secret-key-here
SMTP_HOST=smtp.example.com
SMTP_PORT=587</code></pre>

            <h3>3. Variable Interpolation</h3>

            <p>Use <code>${VARIABLE}</code> syntax in your Compose file to reference values from your shell or from a <code>.env</code> file in the project root.</p>

            <div class="code-label">yaml &mdash; Variable Interpolation</div>
<pre><code>services:
  db:
    image: postgres:${POSTGRES_VERSION:-16}
    environment:
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    ports:
      - "${DB_PORT:-5432}:5432"</code></pre>

            <p>The <code>:-</code> syntax provides a default value. <code>${POSTGRES_VERSION:-16}</code> uses <code>16</code> if <code>POSTGRES_VERSION</code> is not set. This makes your Compose file flexible across environments.</p>

            <p>To convert environment variables between formats (e.g., from <code>.env</code> to JSON for your application config), try the <a href="/free-tools/yaml-to-json.html">YAML to JSON</a> or <a href="/free-tools/json-formatter.html">JSON Formatter</a> tools.</p>

            <div class="info-box warning">
                <div class="info-box-title">Security Warning</div>
                <p>Never commit <code>.env</code> files with real passwords or API keys to version control. Add <code>.env</code> to your <code>.gitignore</code>. For production, use Docker secrets or your cloud provider's secret management service. Encode sensitive values with <a href="/free-tools/base64.html">Base64</a> if needed for transport, but remember that Base64 is encoding, not encryption.</p>
            </div>

            <h2 id="build-context">Build Context and Multi-Stage Builds</h2>

            <p>The <code>build</code> key controls how Docker Compose builds your images. At its simplest, you point it at a directory containing a Dockerfile.</p>

            <div class="code-label">yaml &mdash; Build Options</div>
<pre><code>services:
  api:
    build:
      context: ./api                    # Directory with Dockerfile
      dockerfile: Dockerfile.prod       # Non-default Dockerfile name
      target: production                # Multi-stage build target
      args:
        NODE_VERSION: 20
        BUILD_DATE: 2026-02-14
      cache_from:
        - myapp-api:latest              # Use existing image as cache</code></pre>

            <h3>Multi-Stage Dockerfile</h3>

            <p>Multi-stage builds produce smaller production images by separating the build environment from the runtime environment.</p>

            <div class="code-label">Dockerfile &mdash; Multi-Stage Node.js</div>
<pre><code># Stage 1: Build
FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Stage 2: Production
FROM node:20-alpine AS production
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./
EXPOSE 3000
USER node
CMD ["node", "dist/index.js"]</code></pre>

            <p>Your Compose file targets the correct stage:</p>

            <div class="code-label">yaml</div>
<pre><code>services:
  # Development: uses builder stage with source mount
  api-dev:
    build:
      context: ./api
      target: builder
    volumes:
      - ./api/src:/app/src
    command: ["npm", "run", "dev"]

  # Production: uses production stage
  api:
    build:
      context: ./api
      target: production
    restart: unless-stopped</code></pre>

            <h2 id="health-checks">Health Checks and depends_on</h2>

            <p><code>depends_on</code> controls startup order, but by default it only waits for the container to start &mdash; not for the application inside to be ready. A PostgreSQL container might take several seconds to initialize its data directory after the container is running.</p>

            <p>Combine <code>healthcheck</code> with <code>depends_on: condition: service_healthy</code> to wait for actual readiness.</p>

            <div class="code-label">yaml &mdash; Health Checks</div>
<pre><code>services:
  db:
    image: postgres:16
    environment:
      POSTGRES_PASSWORD: secret
      POSTGRES_DB: myapp
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5
      start_period: 10s
    volumes:
      - db-data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 3

  api:
    build: ./api
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      DATABASE_URL: postgres://postgres:secret@db:5432/myapp
      REDIS_URL: redis://redis:6379

volumes:
  db-data:</code></pre>

            <p>Now <code>api</code> will not start until both <code>db</code> and <code>redis</code> pass their health checks. The <code>start_period</code> gives slow-starting services (like databases) time to initialize before health checks count as failures.</p>

            <h3>Health Check Properties</h3>

            <table>
                <thead>
                    <tr>
                        <th>Property</th>
                        <th>Default</th>
                        <th>Purpose</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>test</code></td>
                        <td>&mdash;</td>
                        <td>Command to run. Exit code 0 = healthy.</td>
                    </tr>
                    <tr>
                        <td><code>interval</code></td>
                        <td>30s</td>
                        <td>Time between health checks.</td>
                    </tr>
                    <tr>
                        <td><code>timeout</code></td>
                        <td>30s</td>
                        <td>Max time for a single check.</td>
                    </tr>
                    <tr>
                        <td><code>retries</code></td>
                        <td>3</td>
                        <td>Consecutive failures before unhealthy.</td>
                    </tr>
                    <tr>
                        <td><code>start_period</code></td>
                        <td>0s</td>
                        <td>Grace period for slow-starting containers.</td>
                    </tr>
                </tbody>
            </table>

            <h2 id="essential-commands">Essential Docker Compose Commands</h2>

            <p>These are the commands you will use daily. All of them are run from the directory containing your <code>docker-compose.yml</code> file.</p>

            <div class="code-label">bash &mdash; Lifecycle Commands</div>
<pre><code># Start all services (detached mode)
docker compose up -d

# Start and force rebuild images
docker compose up -d --build

# Stop all services (containers remain)
docker compose stop

# Stop and remove containers, networks
docker compose down

# Stop, remove containers, AND delete volumes (CAUTION: data loss)
docker compose down -v

# Restart a specific service
docker compose restart api</code></pre>

            <div class="code-label">bash &mdash; Inspection Commands</div>
<pre><code># List running services
docker compose ps

# View logs (all services)
docker compose logs

# Follow logs for a specific service
docker compose logs -f api --tail 100

# Show running processes
docker compose top

# Validate compose file
docker compose config</code></pre>

            <div class="code-label">bash &mdash; Execution Commands</div>
<pre><code># Open a shell in a running container
docker compose exec api sh

# Run a one-off command (creates a new container)
docker compose run --rm api npm test

# Scale a service to multiple instances
docker compose up -d --scale worker=3</code></pre>

            <p>Use <code>docker compose config</code> before every <code>up</code> to catch YAML syntax errors and unresolved variables. It outputs the fully resolved configuration, showing you exactly what Docker will use. You can also validate your YAML syntax with the <a href="/free-tools/yaml-formatter.html">YAML Formatter</a> for quick error checking.</p>

            <h2 id="production">Production Best Practices</h2>

            <p>Development Compose files are not production-ready. Here are the changes you need to make before deploying.</p>

            <h3>1. Use Specific Image Tags</h3>

            <div class="code-label">yaml</div>
<pre><code># Bad: unpredictable
image: postgres:latest

# Good: pinned version
image: postgres:16.2-alpine</code></pre>

            <h3>2. Set Resource Limits</h3>

            <div class="code-label">yaml</div>
<pre><code>services:
  api:
    build: ./api
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 128M</code></pre>

            <h3>3. Configure Restart Policies</h3>

            <div class="code-label">yaml</div>
<pre><code>services:
  api:
    restart: unless-stopped    # Restarts unless manually stopped
  worker:
    restart: on-failure        # Only restart on non-zero exit
    deploy:
      restart_policy:
        condition: on-failure
        max_attempts: 5
        delay: 10s</code></pre>

            <h3>4. Use Read-Only Filesystems</h3>

            <div class="code-label">yaml</div>
<pre><code>services:
  api:
    read_only: true
    tmpfs:
      - /tmp
      - /app/logs
    security_opt:
      - no-new-privileges:true</code></pre>

            <h3>5. Separate Dev and Prod Files</h3>

            <p>Use a base file and environment-specific overrides:</p>

            <div class="code-label">bash</div>
<pre><code># Development
docker compose -f docker-compose.yml -f docker-compose.dev.yml up

# Production
docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d</code></pre>

            <div class="code-label">yaml &mdash; docker-compose.prod.yml (override)</div>
<pre><code>services:
  api:
    build:
      target: production
    environment:
      NODE_ENV: production
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 512M
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"</code></pre>

            <h3>6. Configure Logging</h3>

            <p>Docker stores container logs on disk by default with no size limit. In production, this can fill your disk.</p>

            <div class="code-label">yaml</div>
<pre><code>services:
  api:
    logging:
      driver: json-file
      options:
        max-size: "10m"    # Rotate after 10MB
        max-file: "5"      # Keep 5 rotated files</code></pre>

            <h2 id="full-example">Full-Stack Example</h2>

            <p>Here is a production-ready Compose file for a typical web application with Nginx, a Node.js API, PostgreSQL, and Redis.</p>

            <div class="code-label">yaml &mdash; docker-compose.yml (Full Stack)</div>
<pre><code>services:
  nginx:
    image: nginx:1.25-alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
    depends_on:
      api:
        condition: service_healthy
    networks:
      - frontend
    restart: unless-stopped
    logging:
      driver: json-file
      options:
        max-size: "5m"
        max-file: "3"

  api:
    build:
      context: ./api
      target: production
    expose:
      - "3000"
    env_file:
      - ./api/.env
    environment:
      NODE_ENV: production
      DATABASE_URL: postgres://${DB_USER}:${DB_PASSWORD}@db:5432/${DB_NAME}
      REDIS_URL: redis://redis:6379
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 15s
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - frontend
      - backend
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M

  db:
    image: postgres:16.2-alpine
    volumes:
      - db-data:/var/lib/postgresql/data
      - ./db/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
    environment:
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: ${DB_NAME}
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${DB_USER}"]
      interval: 5s
      timeout: 5s
      retries: 5
      start_period: 10s
    networks:
      - backend
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 256M

  redis:
    image: redis:7.2-alpine
    command: ["redis-server", "--appendonly", "yes", "--maxmemory", "128mb"]
    volumes:
      - redis-data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 3
    networks:
      - backend
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 192M

networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge
    internal: true

volumes:
  db-data:
  redis-data:</code></pre>

            <p>This configuration isolates the database and Redis on an internal network, limits memory usage for each service, includes health checks for proper startup ordering, and uses read-only volume mounts for configuration files. To compare this file with your own configuration, use the <a href="/free-tools/diff-checker.html">Diff Checker</a> to spot differences side by side.</p>

            <div class="cta-box">
                <h3>Validate Your YAML Before Deploying</h3>
                <p>Catch syntax errors, fix indentation, and convert between formats. NexTool's YAML tools work entirely in your browser &mdash; your config never leaves your machine.</p>
                <a href="/free-tools/yaml-formatter.html" class="cta-button">Open YAML Formatter</a>
                <a href="/free-tools/yaml-to-json.html" class="cta-button secondary">YAML to JSON</a>
            </div>

            <h2 id="tools">Related Tools</h2>

            <div class="tool-grid">
                <a href="/free-tools/yaml-formatter.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F4DD;</div>
                    <div class="tool-card-name">YAML Formatter</div>
                    <div class="tool-card-desc">Validate, format, and beautify YAML files. Catch indentation errors before they break your Compose stack.</div>
                </a>
                <a href="/free-tools/yaml-to-json.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F504;</div>
                    <div class="tool-card-name">YAML to JSON</div>
                    <div class="tool-card-desc">Convert between YAML and JSON formats. Useful for transforming Compose configs to application configs.</div>
                </a>
                <a href="/free-tools/json-formatter.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F4CB;</div>
                    <div class="tool-card-name">JSON Formatter</div>
                    <div class="tool-card-desc">Format, validate, and minify JSON. Works with API responses, config files, and environment exports.</div>
                </a>
                <a href="/free-tools/diff-checker.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F50D;</div>
                    <div class="tool-card-name">Diff Checker</div>
                    <div class="tool-card-desc">Compare two files side by side with highlighted differences. Ideal for reviewing Compose file changes.</div>
                </a>
                <a href="/free-tools/base64.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F510;</div>
                    <div class="tool-card-name">Base64 Encoder</div>
                    <div class="tool-card-desc">Encode and decode Base64 strings. Useful for encoding secrets and certificates in Docker configs.</div>
                </a>
            </div>

            <hr>

            <div class="faq-section" id="faq">
                <h2>Frequently Asked Questions</h2>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>What is the difference between docker compose up and docker compose start?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>docker compose up creates and starts containers, networks, and volumes as defined in your docker-compose.yml file. If containers do not exist, it builds images (if build context is specified), creates the containers, and starts them. docker compose start only starts existing containers that were previously created but stopped. If the containers do not exist yet, docker compose start will fail. In most workflows you use docker compose up (with the -d flag for detached mode) to bring your entire stack online, and docker compose start only if you previously ran docker compose stop to pause services without removing them.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>How do I pass environment variables to Docker Compose services?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Docker Compose supports multiple methods for passing environment variables. You can define them inline in docker-compose.yml using the environment key with key-value pairs. You can reference a .env file using the env_file key, which loads all variables from that file into the container. You can also use variable interpolation in docker-compose.yml with ${VARIABLE_NAME} syntax, which pulls values from your shell environment or a .env file in the same directory as your compose file. For sensitive values like API keys and passwords, use Docker secrets in production or store them in a .env file that is excluded from version control via .gitignore.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>What is depends_on and does it wait for a service to be ready?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>depends_on controls the startup order of services in Docker Compose. If service B depends_on service A, Compose will start A before B. However, depends_on only waits for the container to start, not for the application inside it to be ready. A database container might be running but still initializing its data. To wait for actual readiness, use depends_on with a condition set to service_healthy combined with a healthcheck on the dependency. For example, a PostgreSQL service can have a healthcheck that runs pg_isready, and the dependent service uses condition: service_healthy to wait until the database actually accepts connections.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>How do Docker Compose volumes work and when should I use them?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Docker Compose volumes persist data outside of containers so it survives container restarts and removals. There are two types: named volumes and bind mounts. Named volumes (defined in the top-level volumes section) are managed by Docker and stored in Docker's internal storage. They are best for database data, application state, and anything that should persist independently of your host filesystem. Bind mounts map a host directory directly into the container (e.g., ./src:/app/src) and are best for development, where you want live code changes reflected in the container without rebuilding. Use named volumes for production data and bind mounts for development source code.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>Can I use Docker Compose in production?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Yes, Docker Compose can be used in production for single-host deployments. It is well suited for small to medium applications running on a single server. For production use, add restart policies (restart: unless-stopped), configure health checks, use named volumes for persistent data, set resource limits (memory and CPU), avoid bind mounts, use specific image tags instead of latest, and store secrets securely. For multi-host deployments with load balancing, automatic failover, and horizontal scaling, consider Docker Swarm or Kubernetes instead. Many teams use Docker Compose for development and staging, then deploy to Kubernetes in production.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>How do I view logs and debug Docker Compose services?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Use docker compose logs to view output from all services, or docker compose logs [service-name] for a specific service. Add -f to follow logs in real time (similar to tail -f). Add --tail 100 to see only the last 100 lines. For debugging, docker compose exec [service-name] sh opens a shell inside a running container. docker compose ps shows the status of all services. docker compose top shows running processes. If a container keeps crashing, check exit codes with docker compose ps -a and inspect logs for error messages. You can also use docker compose config to validate your docker-compose.yml file before starting services.</p>
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <!-- Author -->
        <div class="author-box">
            <div class="author-avatar">NT</div>
            <div class="author-info">
                <h4>NexTool Team</h4>
                <p>We build free developer tools including YAML formatters, JSON validators, and diff checkers. Over 150 tools, all browser-based, no signup required.</p>
            </div>
        </div>

        <!-- Bottom CTA -->
        <div class="cta-box">
            <h3>150+ Developer Tools, One Place</h3>
            <p>NexTool Pro ($29) unlocks clean output, enhanced features, and unlimited workspace. One payment, lifetime access.</p>
            <a href="https://nextool.app/free-tools/pro-upgrade.html" class="cta-button">Get NexTool Pro &mdash; $29</a>
            <a href="/free-tools/" class="cta-button secondary">Try Free Tools</a>
        </div>

    </article>

    <!-- Footer -->
    <footer class="footer">
        <div class="footer-inner">
            <div class="footer-links">
                <a href="https://nextool.app">Home</a>
                <a href="https://nextool.app/#services">Tools</a>
                <a href="https://nextool.app/free-tools/">Free Tools</a>
                <a href="https://nextool.app/blog/">Blog</a>
                <a href="https://nextool.app/#contact">Contact</a>
            </div>
            <p>&copy; 2026 NexTool. All rights reserved. 150+ free developer tools.</p>
        </div>
    </footer>

    <!-- FAQ Script -->
    <script>
        function toggleFAQ(button) {
            const item = button.parentElement;
            const answer = item.querySelector('.faq-answer');
            const isOpen = item.classList.contains('open');

            document.querySelectorAll('.faq-item').forEach(faq => {
                faq.classList.remove('open');
                faq.querySelector('.faq-answer').style.maxHeight = null;
            });

            if (!isOpen) {
                item.classList.add('open');
                answer.style.maxHeight = answer.scrollHeight + 'px';
            }
        }
    </script>

    <!-- Revenue Scripts -->
    <script defer src="/js/analytics-lite.js"></script>
    <script defer src="/js/revenue.js"></script>
    <script defer src="/js/lead-capture.js"></script>
</body>
</html>