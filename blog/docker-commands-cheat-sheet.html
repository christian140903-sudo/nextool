<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docker Commands Cheat Sheet: Complete Guide (2026) | NexTool</title>
    <meta name="description" content="The ultimate Docker commands cheat sheet for 2026. Copy-paste commands for images, containers, volumes, networks, Compose, Dockerfile, multi-stage builds, cleanup, and production best practices.">
    <meta name="keywords" content="docker commands cheat sheet, docker commands, docker cheat sheet 2026, docker run, docker build, docker-compose, dockerfile commands, docker volumes, docker networks, docker cleanup, multi-stage builds">
    <meta name="author" content="NexTool Team">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://nextool.app/blog/docker-commands-cheat-sheet.html">

    <!-- Open Graph -->
    <meta property="og:type" content="article">
    <meta property="og:title" content="Docker Commands Cheat Sheet: Complete Guide (2026)">
    <meta property="og:description" content="Every Docker command you actually need. Images, containers, volumes, networks, Compose, Dockerfile instructions, multi-stage builds, cleanup, and security. Copy-paste ready.">
    <meta property="og:url" content="https://nextool.app/blog/docker-commands-cheat-sheet.html">
    <meta property="og:site_name" content="NexTool">
    <meta property="og:image" content="https://nextool.app/assets/images/blog/docker-commands-cheat-sheet-og.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="article:published_time" content="2026-02-14T10:00:00Z">
    <meta property="article:modified_time" content="2026-02-14T10:00:00Z">
    <meta property="article:author" content="NexTool Team">
    <meta property="article:section" content="DevOps">
    <meta property="article:tag" content="Docker">
    <meta property="article:tag" content="DevOps">
    <meta property="article:tag" content="Containers">
    <meta property="article:tag" content="Cheat Sheet">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Docker Commands Cheat Sheet: Complete Guide (2026)">
    <meta name="twitter:description" content="Every Docker command you actually need. Images, containers, volumes, networks, Compose, multi-stage builds, cleanup, and security.">
    <meta name="twitter:image" content="https://nextool.app/assets/images/blog/docker-commands-cheat-sheet-og.png">

    <!-- JSON-LD: Article -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Article",
        "headline": "Docker Commands Cheat Sheet: Complete Guide (2026)",
        "description": "The ultimate Docker commands cheat sheet for 2026. Copy-paste commands for images, containers, volumes, networks, Compose, Dockerfile, multi-stage builds, cleanup, and production best practices.",
        "image": "https://nextool.app/assets/images/blog/docker-commands-cheat-sheet-og.png",
        "author": {
            "@type": "Organization",
            "name": "NexTool Team",
            "url": "https://nextool.app"
        },
        "publisher": {
            "@type": "Organization",
            "name": "NexTool",
            "logo": {
                "@type": "ImageObject",
                "url": "https://nextool.app/assets/images/logo.png"
            }
        },
        "datePublished": "2026-02-14T10:00:00Z",
        "dateModified": "2026-02-14T10:00:00Z",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://nextool.app/blog/docker-commands-cheat-sheet.html"
        },
        "wordCount": 3100,
        "keywords": ["docker commands cheat sheet", "docker commands", "docker cheat sheet", "docker run", "docker build", "docker-compose", "dockerfile", "docker volumes", "docker networks", "multi-stage builds", "docker cleanup"]
    }
    </script>

    <!-- JSON-LD: BreadcrumbList -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BreadcrumbList",
        "itemListElement": [
            {
                "@type": "ListItem",
                "position": 1,
                "name": "Home",
                "item": "https://nextool.app"
            },
            {
                "@type": "ListItem",
                "position": 2,
                "name": "Blog",
                "item": "https://nextool.app/blog/"
            },
            {
                "@type": "ListItem",
                "position": 3,
                "name": "Docker Commands Cheat Sheet",
                "item": "https://nextool.app/blog/docker-commands-cheat-sheet.html"
            }
        ]
    }
    </script>

    <!-- JSON-LD: FAQPage -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "FAQPage",
        "mainEntity": [
            {
                "@type": "Question",
                "name": "What is the difference between docker run and docker exec?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "docker run creates and starts a new container from an image. docker exec runs a command inside an already running container. Use docker run when you need a fresh container instance. Use docker exec -it <container> /bin/sh to open a shell inside a container that is already running, which is useful for debugging, inspecting logs, or running one-off commands without stopping the container."
                }
            },
            {
                "@type": "Question",
                "name": "How do I remove all stopped Docker containers and unused images?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Run docker system prune to remove all stopped containers, unused networks, dangling images, and the build cache in one command. Add the -a flag (docker system prune -a) to also remove images not referenced by any container, not just dangling ones. Add --volumes to include unused volumes. For more targeted cleanup, use docker container prune (stopped containers only), docker image prune -a (unused images), or docker volume prune (unused volumes). Always check what will be removed with the --dry-run flag first in production environments."
                }
            },
            {
                "@type": "Question",
                "name": "What is the difference between COPY and ADD in a Dockerfile?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "COPY simply copies files and directories from the build context into the image. ADD does the same but has two additional features: it can extract tar archives automatically (ADD app.tar.gz /app will unpack the archive), and it can download files from URLs. Docker best practice is to always use COPY unless you specifically need tar extraction. ADD from URLs is discouraged because it creates larger images and you cannot leverage layer caching. If you need to download a file, use RUN curl or RUN wget instead so you can also verify checksums and delete the archive in the same layer."
                }
            },
            {
                "@type": "Question",
                "name": "How do I pass environment variables to a Docker container?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "There are several approaches. Use the -e flag with docker run: docker run -e DATABASE_URL=postgres://... myapp. Pass multiple variables from a file with --env-file: docker run --env-file .env myapp. In Docker Compose, use the environment key to set variables directly, or env_file to reference an .env file. For build-time variables (used in Dockerfile instructions), use ARG in your Dockerfile and pass values with --build-arg during docker build. Important: never put secrets in ARG or ENV instructions since they are visible in image layers. For secrets, use Docker secrets in Swarm mode, mount a secrets file at runtime, or use a secrets manager."
                }
            },
            {
                "@type": "Question",
                "name": "What is a multi-stage Docker build and why should I use it?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "A multi-stage build uses multiple FROM statements in a single Dockerfile. Each FROM starts a new build stage. You compile or build your application in an early stage that has all the build tools (compilers, node_modules, dev dependencies), then COPY only the final output into a minimal runtime image. This dramatically reduces image size because the final image does not contain build tools, source code, or intermediate files. For example, a Node.js app might use a node:22 image (over 1GB) to run npm install and npm run build, then copy the output into a node:22-alpine image (under 200MB). A Go application can be compiled in a golang image and copied into a scratch or distroless image that is under 10MB."
                }
            },
            {
                "@type": "Question",
                "name": "How do Docker networks work and when do I need a custom network?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Docker provides three default networks: bridge (default for standalone containers), host (shares the host network stack), and none (no networking). When you run docker run without specifying a network, containers join the default bridge network where they can communicate by IP address but not by container name. Custom bridge networks enable DNS-based service discovery, meaning containers can reach each other by name (for example, a web container can connect to a database container using the hostname db). Docker Compose creates a custom network automatically for each project, which is why services in a compose file can reference each other by service name. Use custom networks to isolate groups of containers, control which services can communicate, and keep your architecture secure."
                }
            }
        ]
    }
    </script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <style>
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #050508;
            --surface: #0a0a0f;
            --surface-2: #1a1a24;
            --surface-3: #232330;
            --primary: #6366f1;
            --primary-hover: #818cf8;
            --accent: #a855f7;
            --accent-hover: #c084fc;
            --text: #e2e8f0;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --border: #1e1e2e;
            --success: #22c55e;
            --warning: #f59e0b;
            --error: #ef4444;
            --code-bg: #0d0d14;
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --font-mono: 'JetBrains Mono', 'Fira Code', monospace;
            --max-width: 800px;
            --header-height: 64px;
        }

        html { scroll-behavior: smooth; -webkit-text-size-adjust: 100%; }
        body { font-family: var(--font-sans); background: var(--bg); color: var(--text); line-height: 1.75; font-size: 16px; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; overflow-x: hidden; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg); }
        ::-webkit-scrollbar-thumb { background: var(--surface-3); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

        .nav { position: fixed; top: 0; left: 0; right: 0; height: var(--header-height); background: rgba(5, 5, 8, 0.85); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-bottom: 1px solid var(--border); z-index: 1000; display: flex; align-items: center; justify-content: center; }
        .nav-inner { width: 100%; max-width: 1200px; padding: 0 24px; display: flex; align-items: center; justify-content: space-between; }
        .nav-logo { display: flex; align-items: center; gap: 10px; text-decoration: none; color: var(--text); font-weight: 700; font-size: 1.25rem; }
        .nav-logo-icon { width: 32px; height: 32px; background: linear-gradient(135deg, var(--primary), var(--accent)); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 0.875rem; font-weight: 800; color: #fff; }
        .nav-links { display: flex; align-items: center; gap: 28px; list-style: none; }
        .nav-links a { color: var(--text-secondary); text-decoration: none; font-size: 0.9rem; font-weight: 500; transition: color 0.2s; }
        .nav-links a:hover { color: var(--text); }
        .nav-cta { background: var(--primary); color: #fff !important; padding: 8px 20px; border-radius: 8px; font-weight: 600; transition: background 0.2s, transform 0.2s; }
        .nav-cta:hover { background: var(--primary-hover); transform: translateY(-1px); }

        .article-wrapper { max-width: var(--max-width); margin: 0 auto; padding: calc(var(--header-height) + 48px) 24px 80px; }
        .breadcrumb { display: flex; align-items: center; gap: 8px; margin-bottom: 32px; font-size: 0.85rem; color: var(--text-muted); flex-wrap: wrap; }
        .breadcrumb a { color: var(--text-secondary); text-decoration: none; transition: color 0.2s; }
        .breadcrumb a:hover { color: var(--primary); }

        .article-header { margin-bottom: 48px; padding-bottom: 32px; border-bottom: 1px solid var(--border); }
        .article-category { display: inline-block; background: rgba(168, 85, 247, 0.12); color: var(--accent); padding: 4px 14px; border-radius: 20px; font-size: 0.8rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 16px; }
        .article-title { font-size: clamp(2rem, 5vw, 3rem); font-weight: 800; line-height: 1.15; color: var(--text); margin-bottom: 16px; letter-spacing: -0.03em; }
        .article-subtitle { font-size: 1.2rem; color: var(--text-secondary); line-height: 1.6; margin-bottom: 24px; }
        .article-meta { display: flex; align-items: center; gap: 20px; color: var(--text-muted); font-size: 0.875rem; flex-wrap: wrap; }
        .article-meta-item { display: flex; align-items: center; gap: 6px; }
        .article-meta-item svg { width: 16px; height: 16px; opacity: 0.7; }

        .toc { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 24px 28px; margin-bottom: 48px; }
        .toc-title { font-size: 0.85rem; font-weight: 700; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 16px; }
        .toc-list { list-style: none; counter-reset: toc; }
        .toc-list li { counter-increment: toc; margin-bottom: 8px; }
        .toc-list li a { color: var(--text-secondary); text-decoration: none; font-size: 0.925rem; display: flex; align-items: baseline; gap: 10px; transition: color 0.2s, padding-left 0.2s; padding: 4px 0; }
        .toc-list li a::before { content: counter(toc, decimal-leading-zero); color: var(--text-muted); font-size: 0.8rem; font-family: var(--font-mono); min-width: 20px; }
        .toc-list li a:hover { color: var(--primary); padding-left: 4px; }

        .article-content h2 { font-size: 1.75rem; font-weight: 700; color: var(--text); margin-top: 56px; margin-bottom: 20px; letter-spacing: -0.02em; line-height: 1.3; padding-top: 16px; border-top: 1px solid var(--border); }
        .article-content h2:first-child { margin-top: 0; padding-top: 0; border-top: none; }
        .article-content h3 { font-size: 1.3rem; font-weight: 600; color: var(--text); margin-top: 36px; margin-bottom: 14px; line-height: 1.35; }
        .article-content h4 { font-size: 1.1rem; font-weight: 600; color: var(--text-secondary); margin-top: 28px; margin-bottom: 12px; }
        .article-content p { margin-bottom: 20px; color: var(--text-secondary); line-height: 1.8; }
        .article-content a { color: var(--primary); text-decoration: none; border-bottom: 1px solid transparent; transition: border-color 0.2s; }
        .article-content a:hover { border-bottom-color: var(--primary); }
        .article-content strong { color: var(--text); font-weight: 600; }
        .article-content ul, .article-content ol { margin-bottom: 20px; padding-left: 24px; color: var(--text-secondary); }
        .article-content li { margin-bottom: 10px; line-height: 1.7; }
        .article-content li::marker { color: var(--primary); }
        .article-content blockquote { border-left: 3px solid var(--accent); background: var(--surface); padding: 16px 24px; margin: 28px 0; border-radius: 0 8px 8px 0; font-style: italic; color: var(--text-secondary); }
        .article-content blockquote p:last-child { margin-bottom: 0; }
        .article-content hr { border: none; border-top: 1px solid var(--border); margin: 48px 0; }

        .article-content pre { background: var(--code-bg); border: 1px solid var(--border); border-radius: 12px; padding: 20px 24px; overflow-x: auto; margin: 24px 0; }
        .article-content pre code { font-family: var(--font-mono); font-size: 0.875rem; line-height: 1.65; color: var(--text); background: none; padding: 0; border-radius: 0; }
        .article-content code { font-family: var(--font-mono); font-size: 0.85em; background: var(--surface); color: var(--accent); padding: 2px 8px; border-radius: 5px; }
        .code-label { display: inline-block; background: var(--surface-2); color: var(--text-muted); font-family: var(--font-mono); font-size: 0.75rem; padding: 2px 10px; border-radius: 6px 6px 0 0; margin-bottom: -1px; position: relative; top: 1px; }

        .article-content table { width: 100%; border-collapse: collapse; margin: 24px 0; font-size: 0.925rem; }
        .article-content thead th { background: var(--surface); color: var(--text); font-weight: 600; text-align: left; padding: 12px 16px; border-bottom: 2px solid var(--border); }
        .article-content tbody td { padding: 12px 16px; border-bottom: 1px solid var(--border); color: var(--text-secondary); }
        .article-content tbody tr:hover { background: var(--surface); }

        .info-box { background: rgba(99, 102, 241, 0.08); border: 1px solid rgba(99, 102, 241, 0.2); border-radius: 12px; padding: 20px 24px; margin: 28px 0; }
        .info-box.warning { background: rgba(245, 158, 11, 0.08); border-color: rgba(245, 158, 11, 0.2); }
        .info-box.danger { background: rgba(239, 68, 68, 0.08); border-color: rgba(239, 68, 68, 0.2); }
        .info-box.success { background: rgba(34, 197, 94, 0.08); border-color: rgba(34, 197, 94, 0.2); }
        .info-box-title { font-weight: 700; margin-bottom: 8px; font-size: 0.9rem; display: flex; align-items: center; gap: 8px; }
        .info-box p { color: var(--text-secondary); font-size: 0.925rem; margin-bottom: 0; }

        .tool-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 16px; margin: 28px 0; }
        .tool-card { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 20px; text-decoration: none; color: var(--text); transition: border-color 0.2s, transform 0.2s, box-shadow 0.2s; display: flex; flex-direction: column; gap: 8px; }
        .tool-card:hover { border-color: var(--primary); transform: translateY(-2px); box-shadow: 0 8px 24px rgba(99, 102, 241, 0.1); }
        .tool-card-icon { font-size: 1.5rem; margin-bottom: 4px; }
        .tool-card-name { font-weight: 600; font-size: 0.95rem; }
        .tool-card-desc { font-size: 0.825rem; color: var(--text-muted); line-height: 1.5; }

        .cta-box { background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(168, 85, 247, 0.1)); border: 1px solid rgba(99, 102, 241, 0.25); border-radius: 16px; padding: 40px 32px; text-align: center; margin: 48px 0; }
        .cta-box h3 { font-size: 1.5rem; font-weight: 700; margin-bottom: 12px; color: var(--text); }
        .cta-box p { color: var(--text-secondary); margin-bottom: 24px; max-width: 500px; margin-left: auto; margin-right: auto; }
        .cta-button { display: inline-flex; align-items: center; gap: 8px; background: var(--primary); color: #fff; padding: 14px 32px; border-radius: 10px; text-decoration: none; font-weight: 600; font-size: 1rem; transition: background 0.2s, transform 0.2s, box-shadow 0.2s; }
        .cta-button:hover { background: var(--primary-hover); transform: translateY(-2px); box-shadow: 0 8px 32px rgba(99, 102, 241, 0.3); }
        .cta-button.secondary { background: transparent; border: 1px solid var(--primary); color: var(--primary); margin-left: 12px; }
        .cta-button.secondary:hover { background: rgba(99, 102, 241, 0.1); }

        .faq-section { margin-top: 56px; padding-top: 32px; border-top: 1px solid var(--border); }
        .faq-section h2 { margin-top: 0 !important; padding-top: 0 !important; border-top: none !important; }
        .faq-item { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; margin-bottom: 12px; overflow: hidden; }
        .faq-question { width: 100%; background: none; border: none; color: var(--text); padding: 20px 24px; font-size: 1rem; font-weight: 600; text-align: left; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-family: var(--font-sans); transition: background 0.2s; }
        .faq-question:hover { background: var(--surface-2); }
        .faq-question .icon { transition: transform 0.3s; font-size: 1.25rem; color: var(--text-muted); flex-shrink: 0; margin-left: 16px; }
        .faq-item.open .faq-question .icon { transform: rotate(45deg); }
        .faq-answer { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; }
        .faq-answer-inner { padding: 0 24px 20px; color: var(--text-secondary); line-height: 1.7; }

        .author-box { display: flex; align-items: center; gap: 20px; background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 24px; margin: 48px 0; }
        .author-avatar { width: 64px; height: 64px; background: linear-gradient(135deg, var(--primary), var(--accent)); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; font-weight: 700; color: #fff; flex-shrink: 0; }
        .author-info h4 { font-weight: 600; margin-bottom: 4px; }
        .author-info p { color: var(--text-muted); font-size: 0.875rem; margin: 0; line-height: 1.5; }

        .footer { border-top: 1px solid var(--border); padding: 48px 24px; text-align: center; color: var(--text-muted); font-size: 0.85rem; }
        .footer-inner { max-width: 1200px; margin: 0 auto; }
        .footer-links { display: flex; justify-content: center; gap: 24px; margin-bottom: 20px; flex-wrap: wrap; }
        .footer-links a { color: var(--text-secondary); text-decoration: none; transition: color 0.2s; }
        .footer-links a:hover { color: var(--primary); }

        @media (max-width: 768px) {
            .nav-links { display: none; }
            .article-wrapper { padding: calc(var(--header-height) + 24px) 16px 60px; }
            .article-title { font-size: 1.75rem; }
            .tool-grid { grid-template-columns: 1fr; }
            .cta-box { padding: 28px 20px; }
            .cta-button.secondary { margin-left: 0; margin-top: 12px; }
            .author-box { flex-direction: column; text-align: center; }
            .article-content pre { padding: 16px; border-radius: 8px; }
            .article-content h2 { font-size: 1.4rem; }
            .article-content h3 { font-size: 1.15rem; }
            .article-content table { display: block; overflow-x: auto; }
        }
        @media (max-width: 480px) {
            .article-title { font-size: 1.5rem; }
            .toc { padding: 18px 20px; }
        }
    </style>
</head>
<body>

    <!-- Navigation -->
    <nav class="nav">
        <div class="nav-inner">
            <a href="https://nextool.app" class="nav-logo">
                <div class="nav-logo-icon">N</div>
                NexTool
            </a>
            <ul class="nav-links">
                <li><a href="https://nextool.app/#services">Tools</a></li>
                <li><a href="https://nextool.app/free-tools/">Free Tools</a></li>
                <li><a href="https://nextool.app/blog/">Blog</a></li>
                <li><a href="https://nextool.app/#contact" class="nav-cta">Browse Tools</a></li>
            </ul>
        </div>
    </nav>

    <!-- Article -->
    <article class="article-wrapper" itemscope itemtype="https://schema.org/Article">
        <!-- Breadcrumb -->
        <nav class="breadcrumb" aria-label="Breadcrumb">
            <a href="https://nextool.app">Home</a>
            <span class="separator">/</span>
            <a href="https://nextool.app/blog/">Blog</a>
            <span class="separator">/</span>
            <span>Docker Commands Cheat Sheet</span>
        </nav>

        <!-- Header -->
        <header class="article-header">
            <span class="article-category">DevOps</span>
            <h1 class="article-title" itemprop="headline">Docker Commands Cheat Sheet: Complete Guide (2026)</h1>
            <p class="article-subtitle">Every Docker command worth knowing &mdash; organized by category with copy-paste examples. Images, containers, volumes, networks, Compose, Dockerfiles, multi-stage builds, and the cleanup commands that keep your system from running out of disk space.</p>
            <div class="article-meta">
                <div class="article-meta-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>
                    <span>22 min read</span>
                </div>
                <div class="article-meta-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
                    <time datetime="2026-02-14" itemprop="datePublished">February 14, 2026</time>
                </div>
                <div class="article-meta-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>
                    <span itemprop="author">NexTool Team</span>
                </div>
            </div>
        </header>

        <!-- TOC -->
        <nav class="toc" aria-label="Table of Contents">
            <div class="toc-title">Table of Contents</div>
            <ol class="toc-list">
                <li><a href="#images">Image Commands</a></li>
                <li><a href="#containers">Container Lifecycle</a></li>
                <li><a href="#volumes">Volumes and Data Persistence</a></li>
                <li><a href="#networks">Network Commands</a></li>
                <li><a href="#dockerfile">Dockerfile Instructions</a></li>
                <li><a href="#multistage">Multi-Stage Builds</a></li>
                <li><a href="#compose">Docker Compose</a></li>
                <li><a href="#logs">Logs and Debugging</a></li>
                <li><a href="#cleanup">Cleanup and Disk Management</a></li>
                <li><a href="#security">Security Best Practices</a></li>
                <li><a href="#tools">Related Developer Tools</a></li>
                <li><a href="#faq">Frequently Asked Questions</a></li>
            </ol>
        </nav>

        <!-- Content -->
        <div class="article-content" itemprop="articleBody">

            <h2 id="images">Image Commands</h2>

            <p>Docker images are immutable templates that contain everything needed to run an application: the OS layer, runtime, libraries, code, and configuration. Every container starts from an image. Mastering image commands is the foundation of working with Docker.</p>

            <h3>Building Images</h3>

            <div class="code-label">bash &mdash; Building images</div>
<pre><code># Build from Dockerfile in current directory
docker build -t myapp:latest .

# Build with a specific Dockerfile
docker build -f Dockerfile.prod -t myapp:prod .

# Build with build arguments
docker build --build-arg NODE_ENV=production -t myapp:prod .

# Build without cache (force full rebuild)
docker build --no-cache -t myapp:latest .

# Build for a specific platform
docker build --platform linux/amd64 -t myapp:amd64 .

# Build for multiple platforms with buildx
docker buildx build --platform linux/amd64,linux/arm64 \
  -t myregistry.com/myapp:latest --push .</code></pre>

            <h3>Managing Images</h3>

            <div class="code-label">bash &mdash; Image management</div>
<pre><code># List all local images
docker images

# List with formatted output
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"

# Pull an image from a registry
docker pull node:22-alpine

# Pull a specific digest (immutable)
docker pull node@sha256:abc123...

# Push to a registry
docker tag myapp:latest myregistry.com/myapp:v1.2.3
docker push myregistry.com/myapp:v1.2.3

# Inspect image metadata (layers, env, ports)
docker inspect node:22-alpine

# View image layer history
docker history myapp:latest --no-trunc

# Save image to tar archive
docker save myapp:latest -o myapp.tar

# Load image from tar archive
docker load -i myapp.tar

# Remove an image
docker rmi myapp:latest

# Remove all dangling images (untagged)
docker image prune

# Remove ALL unused images
docker image prune -a</code></pre>

            <div class="info-box">
                <div class="info-box-title">Quick Tip</div>
                <p>Use <code>docker images --filter "dangling=true"</code> to see images that are no longer tagged. These accumulate fast during development and consume significant disk space.</p>
            </div>

            <h2 id="containers">Container Lifecycle</h2>

            <p>Containers are running instances of images. They have their own filesystem, network, and process space. Understanding the container lifecycle &mdash; create, start, stop, restart, and remove &mdash; is essential for day-to-day Docker work.</p>

            <h3>Running Containers</h3>

            <div class="code-label">bash &mdash; docker run variants</div>
<pre><code># Run a container (pull image if needed)
docker run nginx:alpine

# Run in detached mode (background)
docker run -d --name webserver nginx:alpine

# Run with port mapping (host:container)
docker run -d -p 8080:80 nginx:alpine

# Run with environment variables
docker run -d -e NODE_ENV=production -e PORT=3000 myapp

# Run with env file
docker run -d --env-file .env myapp

# Run with volume mount (host path)
docker run -d -v $(pwd)/data:/app/data myapp

# Run with named volume
docker run -d -v app-data:/app/data myapp

# Run interactively with a shell
docker run -it ubuntu:22.04 /bin/bash

# Run with automatic removal on exit
docker run --rm -it node:22-alpine node -e "console.log('hello')"

# Run with memory and CPU limits
docker run -d --memory=512m --cpus=1.5 myapp

# Run with a restart policy
docker run -d --restart=unless-stopped myapp

# Run on a specific network
docker run -d --network=mynetwork myapp</code></pre>

            <p>For managing environment variables across your containers, the <a href="/free-tools/env-file-editor.html">.env File Editor</a> helps you create and validate <code>.env</code> files with syntax highlighting and duplicate key detection.</p>

            <h3>Managing Running Containers</h3>

            <div class="code-label">bash &mdash; Container management</div>
<pre><code># List running containers
docker ps

# List ALL containers (including stopped)
docker ps -a

# List with custom format
docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

# Stop a container (SIGTERM, then SIGKILL after 10s)
docker stop webserver

# Stop with custom timeout
docker stop -t 30 webserver

# Start a stopped container
docker start webserver

# Restart a container
docker restart webserver

# Pause / unpause container processes
docker pause webserver
docker unpause webserver

# Remove a stopped container
docker rm webserver

# Force remove a running container
docker rm -f webserver

# Remove all stopped containers
docker container prune

# Execute a command in a running container
docker exec -it webserver /bin/sh

# Copy files between host and container
docker cp webserver:/etc/nginx/nginx.conf ./nginx.conf
docker cp ./app.conf webserver:/etc/nginx/conf.d/

# View resource usage (live)
docker stats

# View resource usage for specific containers
docker stats webserver api-server</code></pre>

            <h2 id="volumes">Volumes and Data Persistence</h2>

            <p>Container filesystems are ephemeral. When a container is removed, its data disappears. Volumes solve this by storing data outside the container lifecycle. There are three types: <strong>named volumes</strong> (managed by Docker), <strong>bind mounts</strong> (host directory mapping), and <strong>tmpfs mounts</strong> (in-memory only).</p>

            <div class="code-label">bash &mdash; Volume commands</div>
<pre><code># Create a named volume
docker volume create pgdata

# List all volumes
docker volume ls

# Inspect volume details (mount point, driver)
docker volume inspect pgdata

# Run container with named volume
docker run -d -v pgdata:/var/lib/postgresql/data postgres:16

# Run with bind mount (host directory)
docker run -d -v $(pwd)/src:/app/src myapp

# Run with read-only bind mount
docker run -d -v $(pwd)/config:/app/config:ro myapp

# Run with tmpfs mount (in-memory, never written to disk)
docker run -d --tmpfs /tmp:rw,size=64m myapp

# Backup a volume to tar archive
docker run --rm -v pgdata:/data -v $(pwd):/backup \
  alpine tar czf /backup/pgdata-backup.tar.gz -C /data .

# Restore a volume from tar archive
docker run --rm -v pgdata:/data -v $(pwd):/backup \
  alpine tar xzf /backup/pgdata-backup.tar.gz -C /data

# Remove a specific volume
docker volume rm pgdata

# Remove all unused volumes
docker volume prune</code></pre>

            <div class="info-box warning">
                <div class="info-box-title">Warning</div>
                <p><code>docker volume prune</code> permanently deletes data. Always verify which volumes are unused with <code>docker volume ls --filter "dangling=true"</code> before pruning in production.</p>
            </div>

            <h2 id="networks">Network Commands</h2>

            <p>Docker networking controls how containers communicate with each other and the outside world. The default bridge network allows basic connectivity, but custom networks enable DNS-based service discovery where containers reach each other by name instead of IP address.</p>

            <div class="code-label">bash &mdash; Network commands</div>
<pre><code># List all networks
docker network ls

# Create a custom bridge network
docker network create mynetwork

# Create with specific subnet and gateway
docker network create --subnet=172.20.0.0/16 --gateway=172.20.0.1 mynetwork

# Inspect network details (connected containers, config)
docker network inspect mynetwork

# Run container on a custom network
docker run -d --network=mynetwork --name api myapp

# Connect a running container to a network
docker network connect mynetwork webserver

# Disconnect a container from a network
docker network disconnect mynetwork webserver

# Remove a network
docker network rm mynetwork

# Remove all unused networks
docker network prune</code></pre>

            <h3>Network Types</h3>

            <table>
                <thead>
                    <tr>
                        <th>Driver</th>
                        <th>Use Case</th>
                        <th>DNS Discovery</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>bridge</code></td>
                        <td>Default for standalone containers</td>
                        <td>Custom bridges only</td>
                    </tr>
                    <tr>
                        <td><code>host</code></td>
                        <td>Container shares host network stack</td>
                        <td>N/A</td>
                    </tr>
                    <tr>
                        <td><code>none</code></td>
                        <td>Complete network isolation</td>
                        <td>N/A</td>
                    </tr>
                    <tr>
                        <td><code>overlay</code></td>
                        <td>Multi-host (Swarm / multi-node)</td>
                        <td>Yes</td>
                    </tr>
                    <tr>
                        <td><code>macvlan</code></td>
                        <td>Assign MAC address, appear as physical device</td>
                        <td>No</td>
                    </tr>
                </tbody>
            </table>

            <p>For reverse-proxy setups in front of your Docker containers, the <a href="/free-tools/nginx-config-generator.html">Nginx Config Generator</a> produces production-ready configurations with SSL termination, caching, and upstream blocks.</p>

            <h2 id="dockerfile">Dockerfile Instructions</h2>

            <p>A Dockerfile is a text file that defines how to build an image. Each instruction creates a layer. Understanding the instructions and their ordering is critical for building small, fast, cacheable images.</p>

            <h3>Core Instructions Reference</h3>

            <table>
                <thead>
                    <tr>
                        <th>Instruction</th>
                        <th>Purpose</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>FROM</code></td>
                        <td>Base image</td>
                        <td><code>FROM node:22-alpine</code></td>
                    </tr>
                    <tr>
                        <td><code>WORKDIR</code></td>
                        <td>Set working directory</td>
                        <td><code>WORKDIR /app</code></td>
                    </tr>
                    <tr>
                        <td><code>COPY</code></td>
                        <td>Copy files from build context</td>
                        <td><code>COPY package*.json ./</code></td>
                    </tr>
                    <tr>
                        <td><code>RUN</code></td>
                        <td>Execute command during build</td>
                        <td><code>RUN npm ci --production</code></td>
                    </tr>
                    <tr>
                        <td><code>ENV</code></td>
                        <td>Set environment variable</td>
                        <td><code>ENV NODE_ENV=production</code></td>
                    </tr>
                    <tr>
                        <td><code>ARG</code></td>
                        <td>Build-time variable</td>
                        <td><code>ARG VERSION=1.0</code></td>
                    </tr>
                    <tr>
                        <td><code>EXPOSE</code></td>
                        <td>Document listening port</td>
                        <td><code>EXPOSE 3000</code></td>
                    </tr>
                    <tr>
                        <td><code>CMD</code></td>
                        <td>Default container command</td>
                        <td><code>CMD ["node", "server.js"]</code></td>
                    </tr>
                    <tr>
                        <td><code>ENTRYPOINT</code></td>
                        <td>Fixed container executable</td>
                        <td><code>ENTRYPOINT ["node"]</code></td>
                    </tr>
                    <tr>
                        <td><code>USER</code></td>
                        <td>Switch to non-root user</td>
                        <td><code>USER appuser</code></td>
                    </tr>
                    <tr>
                        <td><code>HEALTHCHECK</code></td>
                        <td>Container health monitoring</td>
                        <td><code>HEALTHCHECK CMD curl -f http://localhost/</code></td>
                    </tr>
                </tbody>
            </table>

            <h3>Optimized Dockerfile Example</h3>

            <div class="code-label">Dockerfile &mdash; Node.js production</div>
<pre><code>FROM node:22-alpine AS base
WORKDIR /app

# Install dependencies first (cached unless package files change)
COPY package.json package-lock.json ./
RUN npm ci --production && npm cache clean --force

# Copy application code
COPY src/ ./src/
COPY public/ ./public/

# Create non-root user
RUN addgroup -S appgroup && adduser -S appuser -G appgroup
USER appuser

# Document port and set default command
EXPOSE 3000
HEALTHCHECK --interval=30s --timeout=3s CMD wget -q --spider http://localhost:3000/health || exit 1
CMD ["node", "src/server.js"]</code></pre>

            <div class="info-box success">
                <div class="info-box-title">Layer Caching Rule</div>
                <p>Order instructions from least to most frequently changed. <code>COPY package*.json</code> before <code>COPY src/</code> ensures npm install only re-runs when dependencies change, not when you edit source code.</p>
            </div>

            <h2 id="multistage">Multi-Stage Builds</h2>

            <p>Multi-stage builds use multiple <code>FROM</code> statements in a single Dockerfile. Each stage can use a different base image. You build your application in a stage with all the tools, then copy only the compiled output into a minimal runtime image. This is the single most effective technique for reducing Docker image size.</p>

            <h3>Node.js Multi-Stage Build</h3>

            <div class="code-label">Dockerfile &mdash; Multi-stage Node.js</div>
<pre><code># Stage 1: Build
FROM node:22-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Stage 2: Production runtime
FROM node:22-alpine AS production
WORKDIR /app
COPY package*.json ./
RUN npm ci --production && npm cache clean --force
COPY --from=builder /app/dist ./dist

RUN addgroup -S app && adduser -S app -G app
USER app
EXPOSE 3000
CMD ["node", "dist/server.js"]</code></pre>

            <h3>Go Multi-Stage Build (Scratch Image)</h3>

            <div class="code-label">Dockerfile &mdash; Multi-stage Go</div>
<pre><code># Stage 1: Build with full Go toolchain
FROM golang:1.23-alpine AS builder
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -ldflags="-s -w" -o /server ./cmd/server

# Stage 2: Minimal runtime (under 10MB)
FROM scratch
COPY --from=builder /server /server
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
EXPOSE 8080
ENTRYPOINT ["/server"]</code></pre>

            <p>A Go binary compiled with <code>CGO_ENABLED=0</code> can run in a <code>scratch</code> image &mdash; literally an empty filesystem. The final image contains only your binary and CA certificates, often under 10MB.</p>

            <h2 id="compose">Docker Compose</h2>

            <p>Docker Compose defines multi-container applications in a single YAML file. Instead of running multiple <code>docker run</code> commands with long argument lists, you declare everything in <code>compose.yaml</code> (or <code>docker-compose.yml</code>) and manage it with one command. Compose automatically creates a custom network for each project, enabling service-to-service DNS resolution.</p>

            <h3>Full-Stack Compose Example</h3>

            <div class="code-label">compose.yaml &mdash; Web + API + Database + Cache</div>
<pre><code>services:
  web:
    build:
      context: ./frontend
      dockerfile: Dockerfile.prod
    ports:
      - "3000:3000"
    environment:
      - API_URL=http://api:8080
    depends_on:
      api:
        condition: service_healthy
    restart: unless-stopped

  api:
    build: ./backend
    ports:
      - "8080:8080"
    environment:
      - DATABASE_URL=postgres://app:secret@db:5432/myapp
      - REDIS_URL=redis://cache:6379
    depends_on:
      db:
        condition: service_healthy
      cache:
        condition: service_started
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:8080/health"]
      interval: 10s
      timeout: 5s
      retries: 3
    restart: unless-stopped

  db:
    image: postgres:16-alpine
    volumes:
      - pgdata:/var/lib/postgresql/data
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: app
      POSTGRES_PASSWORD: secret
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U app -d myapp"]
      interval: 5s
      timeout: 3s
      retries: 5
    restart: unless-stopped

  cache:
    image: redis:7-alpine
    volumes:
      - redis-data:/data
    restart: unless-stopped

volumes:
  pgdata:
  redis-data:</code></pre>

            <p>Need to build compose files quickly? The <a href="/free-tools/docker-compose-generator.html">Docker Compose Generator</a> lets you visually select services, configure ports, volumes, and networks, then export a production-ready YAML file.</p>

            <h3>Compose Commands</h3>

            <div class="code-label">bash &mdash; Docker Compose commands</div>
<pre><code># Start all services (build if needed)
docker compose up -d

# Start with forced rebuild
docker compose up -d --build

# Stop all services
docker compose down

# Stop and remove volumes (destroys data)
docker compose down -v

# View logs for all services
docker compose logs -f

# View logs for a specific service
docker compose logs -f api

# List running services
docker compose ps

# Scale a service
docker compose up -d --scale api=3

# Execute command in a running service
docker compose exec api /bin/sh

# Run a one-off command
docker compose run --rm api npm run migrate

# Pull latest images for all services
docker compose pull

# Validate compose file syntax
docker compose config</code></pre>

            <p>When editing YAML configuration files, the <a href="/free-tools/yaml-editor.html">YAML Editor</a> catches indentation errors and invalid syntax before Docker does.</p>

            <h2 id="logs">Logs and Debugging</h2>

            <p>When a container misbehaves &mdash; crashes on startup, returns errors, or runs out of resources &mdash; these commands help you find the problem.</p>

            <div class="code-label">bash &mdash; Debugging commands</div>
<pre><code># View container logs
docker logs webserver

# Follow logs in real time
docker logs -f webserver

# Show last 100 lines
docker logs --tail 100 webserver

# Show logs with timestamps
docker logs -t webserver

# Show logs since a specific time
docker logs --since 2026-02-14T10:00:00 webserver
docker logs --since 30m webserver

# Open a shell inside a running container
docker exec -it webserver /bin/sh

# Inspect full container configuration
docker inspect webserver

# Extract specific field with Go template
docker inspect --format='{{.State.Status}}' webserver
docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' webserver

# View filesystem changes since container started
docker diff webserver

# View live resource usage
docker stats webserver

# View all running processes in a container
docker top webserver

# View port mappings
docker port webserver

# View system-wide events (live)
docker events
docker events --filter type=container --filter event=die

# Check container health status
docker inspect --format='{{.State.Health.Status}}' webserver</code></pre>

            <p>When inspecting the JSON output from <code>docker inspect</code>, the <a href="/free-tools/json-formatter.html">JSON Formatter</a> makes deeply nested container configurations readable with syntax highlighting and collapsible tree views.</p>

            <div class="info-box">
                <div class="info-box-title">Debugging a Crashing Container</div>
                <p>If a container exits immediately, override the entrypoint: <code>docker run -it --entrypoint /bin/sh myapp</code>. This gives you a shell inside the container without running the application, so you can inspect the environment, check file permissions, and test commands manually.</p>
            </div>

            <h2 id="cleanup">Cleanup and Disk Management</h2>

            <p>Docker accumulates images, containers, volumes, and build cache fast. Without regular cleanup, disk usage can grow by several GB per week during active development. These commands free space and keep your system healthy.</p>

            <div class="code-label">bash &mdash; Cleanup commands</div>
<pre><code># View total disk usage by Docker
docker system df

# View detailed breakdown
docker system df -v

# Remove ALL unused data (stopped containers, unused networks,
# dangling images, build cache)
docker system prune

# Also remove unused images (not just dangling)
docker system prune -a

# Also remove unused volumes (CAUTION: deletes data)
docker system prune -a --volumes

# Targeted cleanup
docker container prune    # stopped containers
docker image prune        # dangling images
docker image prune -a     # all unused images
docker volume prune       # unused volumes
docker network prune      # unused networks
docker builder prune      # build cache

# Remove images older than 24 hours
docker image prune -a --filter "until=24h"

# Remove containers stopped more than 1 hour ago
docker container prune --filter "until=1h"

# Kill all running containers (emergency)
docker kill $(docker ps -q)

# Remove all containers (running and stopped)
docker rm -f $(docker ps -aq)

# Remove all images
docker rmi -f $(docker images -q)</code></pre>

            <div class="info-box danger">
                <div class="info-box-title">Production Warning</div>
                <p><code>docker system prune -a --volumes</code> is destructive. It removes all unused volumes including database data. In production, always use targeted prune commands and verify with <code>--dry-run</code> or <code>docker system df -v</code> first.</p>
            </div>

            <h2 id="security">Security Best Practices</h2>

            <p>Container security is not optional. A misconfigured container can expose your host system, leak credentials, or become an entry point for attackers. These practices cover the critical areas.</p>

            <h3>Non-Root User</h3>

            <div class="code-label">Dockerfile &mdash; Non-root user setup</div>
<pre><code># Install dependencies as root
FROM node:22-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --production

# Create and switch to non-root user
RUN addgroup -S appgroup && adduser -S appuser -G appgroup
RUN chown -R appuser:appgroup /app
USER appuser

COPY --chown=appuser:appgroup . .
CMD ["node", "server.js"]</code></pre>

            <h3>Runtime Security Flags</h3>

            <div class="code-label">bash &mdash; Secure container runtime</div>
<pre><code># Read-only filesystem
docker run --read-only --tmpfs /tmp myapp

# Drop all capabilities, add only what you need
docker run --cap-drop ALL --cap-add NET_BIND_SERVICE myapp

# Prevent privilege escalation
docker run --security-opt=no-new-privileges myapp

# Limit memory and CPU
docker run --memory=256m --cpus=0.5 myapp

# Disable inter-container communication on default bridge
docker network create --opt com.docker.network.bridge.enable_icc=false isolated

# Run with a specific user (override Dockerfile USER)
docker run --user 1000:1000 myapp

# Mount secrets as read-only files (not env vars)
docker run -v ./secrets/db-password:/run/secrets/db-password:ro myapp</code></pre>

            <h3>Image Scanning</h3>

            <div class="code-label">bash &mdash; Vulnerability scanning</div>
<pre><code># Scan with Docker Scout (built into Docker Desktop)
docker scout cves myapp:latest

# Scan with Trivy (open source)
trivy image myapp:latest

# Scan during CI (fail on critical/high)
trivy image --exit-code 1 --severity CRITICAL,HIGH myapp:latest</code></pre>

            <div class="info-box success">
                <div class="info-box-title">Security Checklist</div>
                <p>1) Use minimal base images (alpine/distroless). 2) Run as non-root. 3) Drop all capabilities. 4) Use read-only filesystems. 5) Never put secrets in ENV or ARG. 6) Scan images in CI. 7) Pin image versions by digest. 8) Use .dockerignore.</p>
            </div>

            <hr>

            <h2 id="tools">Related Developer Tools</h2>

            <div class="tool-grid">
                <a href="/free-tools/docker-compose-generator.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F433;</div>
                    <div class="tool-card-name">Docker Compose Generator</div>
                    <div class="tool-card-desc">Build complete docker-compose.yml files visually. Select services, configure ports, volumes, and networks.</div>
                </a>
                <a href="/free-tools/yaml-editor.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F4C4;</div>
                    <div class="tool-card-name">YAML Editor</div>
                    <div class="tool-card-desc">Edit and validate YAML with real-time error detection. Perfect for compose files and Kubernetes manifests.</div>
                </a>
                <a href="/free-tools/nginx-config-generator.html" class="tool-card">
                    <div class="tool-card-icon">&#x2699;</div>
                    <div class="tool-card-name">Nginx Config Generator</div>
                    <div class="tool-card-desc">Generate Nginx configs for reverse proxying Docker containers with SSL, caching, and load balancing.</div>
                </a>
                <a href="/free-tools/env-file-editor.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F511;</div>
                    <div class="tool-card-name">.env File Editor</div>
                    <div class="tool-card-desc">Create and validate .env files for Docker containers. Syntax highlighting and duplicate detection.</div>
                </a>
                <a href="/free-tools/json-formatter.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F4CB;</div>
                    <div class="tool-card-name">JSON Formatter</div>
                    <div class="tool-card-desc">Format docker inspect output and API responses. Tree view, syntax highlighting, and search.</div>
                </a>
            </div>

            <hr>

            <div class="faq-section" id="faq">
                <h2>Frequently Asked Questions</h2>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>What is the difference between docker run and docker exec?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p><code>docker run</code> creates and starts a new container from an image. <code>docker exec</code> runs a command inside an already running container. Use <code>docker run</code> when you need a fresh container instance. Use <code>docker exec -it &lt;container&gt; /bin/sh</code> to open a shell inside a container that is already running, which is useful for debugging, inspecting logs, or running one-off commands without stopping the container.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>How do I remove all stopped Docker containers and unused images?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Run <code>docker system prune</code> to remove all stopped containers, unused networks, dangling images, and the build cache in one command. Add the <code>-a</code> flag (<code>docker system prune -a</code>) to also remove images not referenced by any container, not just dangling ones. Add <code>--volumes</code> to include unused volumes. For more targeted cleanup, use <code>docker container prune</code> (stopped containers only), <code>docker image prune -a</code> (unused images), or <code>docker volume prune</code> (unused volumes). Always check what will be removed with the <code>--dry-run</code> flag first in production environments.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>What is the difference between COPY and ADD in a Dockerfile?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p><code>COPY</code> simply copies files and directories from the build context into the image. <code>ADD</code> does the same but has two additional features: it can extract tar archives automatically (<code>ADD app.tar.gz /app</code> will unpack the archive), and it can download files from URLs. Docker best practice is to always use <code>COPY</code> unless you specifically need tar extraction. <code>ADD</code> from URLs is discouraged because it creates larger images and you cannot leverage layer caching. If you need to download a file, use <code>RUN curl</code> or <code>RUN wget</code> instead so you can also verify checksums and delete the archive in the same layer.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>How do I pass environment variables to a Docker container?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>There are several approaches. Use the <code>-e</code> flag with docker run: <code>docker run -e DATABASE_URL=postgres://... myapp</code>. Pass multiple variables from a file with <code>--env-file</code>: <code>docker run --env-file .env myapp</code>. In Docker Compose, use the <code>environment</code> key to set variables directly, or <code>env_file</code> to reference an .env file. For build-time variables (used in Dockerfile instructions), use <code>ARG</code> in your Dockerfile and pass values with <code>--build-arg</code> during docker build. Important: never put secrets in <code>ARG</code> or <code>ENV</code> instructions since they are visible in image layers. For secrets, use Docker secrets in Swarm mode, mount a secrets file at runtime, or use a secrets manager.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>What is a multi-stage Docker build and why should I use it?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>A multi-stage build uses multiple <code>FROM</code> statements in a single Dockerfile. Each <code>FROM</code> starts a new build stage. You compile or build your application in an early stage that has all the build tools (compilers, node_modules, dev dependencies), then <code>COPY</code> only the final output into a minimal runtime image. This dramatically reduces image size because the final image does not contain build tools, source code, or intermediate files. For example, a Node.js app might use a <code>node:22</code> image (over 1GB) to run npm install and npm run build, then copy the output into a <code>node:22-alpine</code> image (under 200MB). A Go application can be compiled in a golang image and copied into a scratch or distroless image that is under 10MB.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>How do Docker networks work and when do I need a custom network?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Docker provides three default networks: bridge (default for standalone containers), host (shares the host network stack), and none (no networking). When you run <code>docker run</code> without specifying a network, containers join the default bridge network where they can communicate by IP address but not by container name. Custom bridge networks enable DNS-based service discovery, meaning containers can reach each other by name (for example, a web container can connect to a database container using the hostname <code>db</code>). Docker Compose creates a custom network automatically for each project, which is why services in a compose file can reference each other by service name. Use custom networks to isolate groups of containers, control which services can communicate, and keep your architecture secure.</p>
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <!-- Author -->
        <div class="author-box">
            <div class="author-avatar">NT</div>
            <div class="author-info">
                <h4>NexTool Team</h4>
                <p>We build free, browser-based developer tools for Docker, DevOps, and web development. Over 227 tools, all client-side, no signup required. We write guides based on real production workflows.</p>
            </div>
        </div>

        <!-- Bottom CTA -->
        <div class="cta-box">
            <h3>227+ Developer Tools, Zero Signup</h3>
            <p>NexTool Pro gives you clean output, enhanced features, and unlimited workspace. $29 founding member price (regular $49). One payment, lifetime access.</p>
            <a href="https://nextool.app/free-tools/pro-upgrade.html" class="cta-button">Get NexTool Pro &mdash; $29</a>
            <a href="/free-tools/" class="cta-button secondary">Try Free Tools</a>
        </div>

    </article>

    <!-- Footer -->
    <footer class="footer">
        <div class="footer-inner">
            <div class="footer-links">
                <a href="https://nextool.app">Home</a>
                <a href="https://nextool.app/#services">Tools</a>
                <a href="https://nextool.app/free-tools/">Free Tools</a>
                <a href="https://nextool.app/blog/">Blog</a>
                <a href="https://nextool.app/#contact">Contact</a>
            </div>
            <p>&copy; 2026 NexTool. All rights reserved. 227+ free developer tools.</p>
        </div>
    </footer>

    <!-- FAQ Script -->
    <script>
        function toggleFAQ(button) {
            const item = button.parentElement;
            const answer = item.querySelector('.faq-answer');
            const isOpen = item.classList.contains('open');

            document.querySelectorAll('.faq-item').forEach(faq => {
                faq.classList.remove('open');
                faq.querySelector('.faq-answer').style.maxHeight = null;
            });

            if (!isOpen) {
                item.classList.add('open');
                answer.style.maxHeight = answer.scrollHeight + 'px';
            }
        }
    </script>

    <!-- Revenue Scripts -->
    <script defer src="/js/analytics-lite.js"></script>
    <script defer src="/js/revenue.js"></script>
    <script defer src="/js/lead-capture.js"></script>
</body>
</html>