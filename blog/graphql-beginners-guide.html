<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
    <link rel="icon" type="image/svg+xml" href="/img/favicon.svg">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GraphQL for Beginners: Complete Tutorial | ANIMA</title>
<meta name="description" content="Learn GraphQL from scratch with practical examples. Covers queries, mutations, subscriptions, schema design, types, resolvers, and how GraphQL compares to REST.">
<meta name="keywords" content="graphql tutorial, graphql beginners guide, graphql vs rest, graphql query examples, graphql mutations, graphql schema, graphql types, graphql resolvers, learn graphql, graphql api">
<meta name="author" content="Christian Bucher">
<meta name="robots" content="index, follow">
<link rel="canonical" href="https://nextool.app/blog/graphql-beginners-guide.html">

<!-- Open Graph -->
<meta property="og:type" content="article">
<meta property="og:title" content="GraphQL for Beginners: Complete Tutorial with Examples">
<meta property="og:description" content="Learn GraphQL from scratch with practical examples. Covers queries, mutations, subscriptions, schema design, types, resolvers, and how GraphQL compares to REST.">
<meta property="og:url" content="https://nextool.app/blog/graphql-beginners-guide.html">
<meta property="og:site_name" content="ANIMA by Christian Bucher">
<meta property="article:published_time" content="2026-02-10T12:00:00Z">

<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="GraphQL for Beginners: Complete Tutorial with Examples">
<meta name="twitter:description" content="Learn GraphQL from scratch with practical examples. Covers queries, mutations, subscriptions, schema design, types, resolvers, and how GraphQL compares to REST.">

<!-- JSON-LD: Article -->
<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "GraphQL for Beginners: Complete Tutorial with Examples",
    "description": "Learn GraphQL from scratch with practical examples. Covers queries, mutations, subscriptions, schema design, types, resolvers, and how GraphQL compares to REST.",
    "author": {"@type": "Organization", "name": "Christian Bucher", "url": "https://nextool.app"},
    "publisher": {"@type": "Organization", "name": "ANIMA", "logo": {"@type": "ImageObject", "url": "https://nextool.app/images/logo.png"}},
    "datePublished": "2026-02-10T12:00:00Z",
    "dateModified": "2026-02-10T12:00:00Z",
    "mainEntityOfPage": {"@type": "WebPage", "@id": "https://nextool.app/blog/graphql-beginners-guide.html"},
    "keywords": "graphql tutorial, graphql beginners guide, graphql vs rest, graphql query examples, graphql mutations, graphql schema",
    "wordCount": 2200,
    "articleSection": "Developer Tools"
}
</script>

<!-- JSON-LD: BreadcrumbList -->
<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [
        {"@type": "ListItem", "position": 1, "name": "Home", "item": "https://nextool.app"},
        {"@type": "ListItem", "position": 2, "name": "Blog", "item": "https://nextool.app/blog/"},
        {"@type": "ListItem", "position": 3, "name": "GraphQL for Beginners: Complete Tutorial with Examples", "item": "https://nextool.app/blog/graphql-beginners-guide.html"}
    ]
}
</script>

<!-- JSON-LD: FAQPage -->
<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "FAQPage",
    "mainEntity": [
        {
            "@type": "Question",
            "name": "What is GraphQL and how is it different from REST?",
            "acceptedAnswer": {
                "@type": "Answer",
                "text": "GraphQL is a query language for APIs that lets clients request exactly the data they need in a single request. Unlike REST, where each endpoint returns a fixed data structure and you often need multiple requests to assemble a complete view, GraphQL exposes a single endpoint and lets the client specify the shape of the response. This eliminates over-fetching (getting fields you do not need) and under-fetching (needing extra requests for related data). REST organizes data around resources with separate URLs, while GraphQL organizes data around a typed schema that clients query with a flexible syntax."
            }
        },
        {
            "@type": "Question",
            "name": "What are queries, mutations, and subscriptions in GraphQL?",
            "acceptedAnswer": {
                "@type": "Answer",
                "text": "Queries are read operations that fetch data from the server without changing anything. Mutations are write operations that create, update, or delete data on the server and return the modified result. Subscriptions are long-lived connections, typically over WebSockets, that push real-time updates from the server to the client whenever specified data changes. Queries are analogous to GET requests in REST, mutations map to POST, PUT, PATCH, and DELETE, and subscriptions have no direct REST equivalent because REST is inherently request-response based."
            }
        },
        {
            "@type": "Question",
            "name": "What is a GraphQL schema and why does it matter?",
            "acceptedAnswer": {
                "@type": "Answer",
                "text": "A GraphQL schema is a strongly typed contract that defines every type of data your API can return, every query clients can run, every mutation they can perform, and the relationships between types. It is written in the Schema Definition Language (SDL) and serves as the single source of truth for both the frontend and backend teams. The schema matters because it enables auto-completion in development tools, automatic documentation generation, compile-time validation of queries, and clear communication between teams about what the API can and cannot do."
            }
        },
        {
            "@type": "Question",
            "name": "Is GraphQL better than REST?",
            "acceptedAnswer": {
                "@type": "Answer",
                "text": "Neither is universally better. GraphQL is a strong choice when your client needs flexible data fetching, when you have multiple clients (web, mobile, third-party) with different data needs, or when you want to reduce the number of network requests. REST is a strong choice for simple CRUD APIs, when you need aggressive HTTP caching, when your team is already experienced with REST conventions, or when your API serves a single client with predictable data needs. Many production systems use both: REST for simple public endpoints and GraphQL for complex internal data fetching."
            }
        },
        {
            "@type": "Question",
            "name": "What tools do I need to start learning GraphQL?",
            "acceptedAnswer": {
                "@type": "Answer",
                "text": "To start learning GraphQL you need a GraphQL playground or explorer for writing and testing queries interactively, a JSON formatter for inspecting responses, and optionally an API testing tool for sending raw HTTP requests to a GraphQL endpoint. On the server side, popular frameworks include Apollo Server for JavaScript and TypeScript, Strawberry for Python, and graphql-java for Java. Public GraphQL APIs like the GitHub GraphQL API and the Star Wars API (SWAPI GraphQL) let you practice queries without setting up a server."
            }
        }
    ]
}
</script>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">

<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --bg: #050508;
  --surface: #111118;
  --surface-2: #1a1a24;
  --surface-3: #222233;
  --primary: #00d4ff;
  --primary-hover: #818cf8;
  --accent: #a855f7;
  --pink: #ec4899;
  --text: #e2e8f0;
  --text-muted: #94a3b8;
  --text-dim: #64748b;
  --border: #1e1e2e;
  --success: #22c55e;
  --warning: #f59e0b;
  --radius: 12px;
  --radius-lg: 16px;
  --shadow: 0 4px 24px rgba(0,0,0,0.4);
}

html { scroll-behavior: smooth; }

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  background: var(--bg);
  color: var(--text);
  line-height: 1.7;
  -webkit-font-smoothing: antialiased;
}

a { color: var(--primary); text-decoration: none; transition: color 0.2s; }
a:hover { color: var(--primary-hover); }

/* ===== NAVBAR ===== */
.navbar {
  position: fixed; top: 0; left: 0; right: 0; z-index: 1000;
  background: rgba(5,5,8,0.85);
  backdrop-filter: blur(20px);
  border-bottom: 1px solid var(--border);
  padding: 0 2rem;
  height: 64px;
  display: flex; align-items: center; justify-content: space-between;
}
.nav-logo {
  font-size: 1.4rem; font-weight: 800; color: #fff;
  background: linear-gradient(135deg, var(--primary), var(--accent));
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}
.nav-links { display: flex; align-items: center; gap: 1.5rem; list-style: none; }
.nav-links a { color: var(--text-muted); font-size: 0.9rem; font-weight: 500; transition: color 0.2s; }
.nav-links a:hover { color: #fff; }
.nav-cta {
  background: var(--primary); color: #fff !important; padding: 0.5rem 1.2rem;
  border-radius: 8px; font-weight: 600; font-size: 0.85rem;
  transition: background 0.2s, transform 0.2s;
}
.nav-cta:hover { background: var(--primary-hover); transform: translateY(-1px); }
.nav-mobile-toggle { display: none; background: none; border: none; color: #fff; font-size: 1.5rem; cursor: pointer; }

/* ===== ARTICLE HERO ===== */
.article-hero {
  padding: 8rem 2rem 3rem;
  max-width: 900px; margin: 0 auto; text-align: center;
}
.article-meta {
  display: flex; align-items: center; justify-content: center; gap: 1rem;
  margin-bottom: 1.5rem; flex-wrap: wrap;
}
.article-category {
  background: linear-gradient(135deg, var(--primary), var(--accent));
  color: #fff; padding: 0.3rem 0.9rem; border-radius: 20px;
  font-size: 0.75rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em;
}
.article-date, .article-reading-time { color: var(--text-dim); font-size: 0.85rem; }
.article-hero h1 {
  font-size: clamp(2rem, 5vw, 3rem); font-weight: 900; line-height: 1.15;
  color: #fff; margin-bottom: 1.2rem;
}
.article-hero h1 span {
  background: linear-gradient(135deg, var(--primary), var(--pink));
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}
.article-subtitle { color: var(--text-muted); font-size: 1.15rem; max-width: 680px; margin: 0 auto; }

/* ===== LAYOUT ===== */
.article-layout {
  display: grid;
  grid-template-columns: 240px 1fr;
  gap: 3rem;
  max-width: 1100px;
  margin: 0 auto;
  padding: 0 2rem 4rem;
  align-items: start;
}

/* ===== TOC SIDEBAR ===== */
.toc-sidebar {
  position: sticky; top: 84px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  padding: 1.2rem;
}
.toc-title {
  font-size: 0.75rem; font-weight: 700; text-transform: uppercase;
  letter-spacing: 0.08em; color: var(--text-dim); margin-bottom: 0.8rem;
}
.toc-list { list-style: none; }
.toc-list li { margin-bottom: 0.4rem; }
.toc-list a {
  color: var(--text-muted); font-size: 0.8rem; display: block;
  padding: 0.25rem 0.5rem; border-radius: 6px; border-left: 2px solid transparent;
  transition: all 0.2s;
}
.toc-list a:hover, .toc-list a.active {
  color: var(--primary); border-left-color: var(--primary); background: rgba(0,212,255,0.06);
}

/* ===== ARTICLE CONTENT ===== */
.article-content { max-width: 720px; }
.article-content h2 {
  font-size: 1.6rem; font-weight: 800; color: #fff;
  margin: 2.5rem 0 1rem; padding-top: 1rem;
  border-top: 1px solid var(--border);
}
.article-content h2:first-of-type { border-top: none; padding-top: 0; margin-top: 0; }
.article-content h3 {
  font-size: 1.2rem; font-weight: 700; color: #fff; margin: 2rem 0 0.8rem;
}
.article-content p { margin-bottom: 1.2rem; color: var(--text); }
.article-content ul, .article-content ol {
  margin: 0 0 1.5rem 1.2rem; color: var(--text);
}
.article-content li { margin-bottom: 0.5rem; }
.article-content strong { color: #fff; }
.article-content blockquote {
  border-left: 3px solid var(--primary); padding: 1rem 1.5rem;
  background: var(--surface); border-radius: 0 var(--radius) var(--radius) 0;
  margin: 1.5rem 0; color: var(--text-muted); font-style: italic;
}
.article-content code {
  background: var(--surface-2); padding: 0.15rem 0.45rem; border-radius: 4px;
  font-size: 0.9em; color: var(--pink);
}
.article-content pre {
  background: var(--surface); border: 1px solid var(--border); border-radius: var(--radius);
  padding: 1.2rem; overflow-x: auto; margin: 1.5rem 0;
}
.article-content pre code { background: none; padding: 0; color: var(--text); }

/* ===== KEY TAKEAWAY ===== */
.key-takeaway {
  background: linear-gradient(135deg, rgba(34,197,94,0.08), rgba(0,212,255,0.05));
  border: 1px solid rgba(34,197,94,0.2);
  border-radius: var(--radius);
  padding: 1.2rem 1.5rem;
  margin: 1.5rem 0;
}
.key-takeaway-label {
  font-size: 0.72rem; font-weight: 700; text-transform: uppercase;
  letter-spacing: 0.08em; color: var(--success); margin-bottom: 0.4rem;
}

/* ===== CTA BOX ===== */
.cta-box {
  background: linear-gradient(135deg, rgba(0,212,255,0.1), rgba(168,85,247,0.08));
  border: 1px solid rgba(0,212,255,0.25);
  border-radius: var(--radius-lg);
  padding: 2rem;
  margin: 2rem 0;
  text-align: center;
}
.cta-box h3 { color: #fff; font-size: 1.3rem; font-weight: 800; margin-bottom: 0.6rem; }
.cta-box p { color: var(--text-muted); margin-bottom: 1.2rem; max-width: 500px; margin-left: auto; margin-right: auto; }
.cta-button {
  display: inline-block;
  background: linear-gradient(135deg, var(--primary), var(--accent));
  color: #fff; font-weight: 700; padding: 0.75rem 2rem;
  border-radius: 10px; font-size: 0.95rem;
  transition: transform 0.2s, box-shadow 0.2s;
}
.cta-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 30px rgba(0,212,255,0.35);
  color: #fff;
}

/* ===== COMPARISON TABLE ===== */
.comparison-table {
  width: 100%;
  border-collapse: collapse;
  margin: 1.5rem 0;
  font-size: 0.9rem;
}
.comparison-table th {
  background: var(--surface-2);
  color: #fff;
  font-weight: 700;
  text-align: left;
  padding: 0.75rem 1rem;
  border-bottom: 2px solid var(--border);
}
.comparison-table td {
  padding: 0.65rem 1rem;
  border-bottom: 1px solid var(--border);
  color: var(--text);
}
.comparison-table tr:hover td {
  background: rgba(0,212,255,0.04);
}

/* ===== AUTHOR BOX ===== */
.author-box {
  display: flex; gap: 1.2rem; align-items: center;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-lg);
  padding: 1.5rem; margin: 2.5rem 0;
}
.author-avatar {
  width: 64px; height: 64px; border-radius: 50%;
  background: linear-gradient(135deg, var(--primary), var(--accent));
  display: flex; align-items: center; justify-content: center;
  font-size: 1.5rem; font-weight: 800; color: #fff; flex-shrink: 0;
}
.author-info h4 { color: #fff; font-weight: 700; margin-bottom: 0.2rem; }
.author-info p { color: var(--text-muted); font-size: 0.85rem; line-height: 1.5; }

/* ===== RELATED ARTICLES ===== */
.related-articles { margin: 3rem 0; }
.related-articles h3 { color: #fff; font-weight: 800; font-size: 1.3rem; margin-bottom: 1.2rem; }
.related-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 1.2rem; }
.related-card {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 1.2rem;
  transition: border-color 0.3s, transform 0.2s;
}
.related-card:hover { border-color: var(--primary); transform: translateY(-2px); }
.related-card-cat {
  font-size: 0.7rem; text-transform: uppercase; font-weight: 700;
  letter-spacing: 0.05em; color: var(--accent); margin-bottom: 0.5rem;
}
.related-card h4 { color: #fff; font-weight: 700; font-size: 1rem; margin-bottom: 0.4rem; line-height: 1.4; }
.related-card p { color: var(--text-dim); font-size: 0.82rem; }

/* ===== FOOTER ===== */
.site-footer {
  border-top: 1px solid var(--border);
  background: var(--surface);
  padding: 3rem 2rem 1.5rem;
}
.footer-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  gap: 2rem;
  max-width: 1100px;
  margin: 0 auto 2rem;
}
.footer-col h4 {
  color: #fff; font-weight: 700; font-size: 0.85rem; margin-bottom: 0.8rem;
  text-transform: uppercase; letter-spacing: 0.06em;
}
.footer-col a { display: block; color: var(--text-dim); font-size: 0.85rem; margin-bottom: 0.4rem; }
.footer-col a:hover { color: var(--primary); }
.footer-brand {
  font-size: 1.2rem; font-weight: 800;
  background: linear-gradient(135deg, var(--primary), var(--accent));
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  margin-bottom: 0.5rem;
}
.footer-brand-desc { color: var(--text-dim); font-size: 0.82rem; line-height: 1.5; }
.footer-bottom {
  text-align: center; padding-top: 1.5rem;
  border-top: 1px solid var(--border); color: var(--text-dim); font-size: 0.8rem;
}

/* ===== RESPONSIVE ===== */
@media (max-width: 900px) {
  .article-layout { grid-template-columns: 1fr; }
  .toc-sidebar { position: static; margin-bottom: 1rem; }
  .comparison-table { font-size: 0.8rem; }
  .comparison-table th, .comparison-table td { padding: 0.5rem 0.6rem; }
}
@media (max-width: 640px) {
  .nav-links { display: none; }
  .nav-mobile-toggle { display: block; }
  .article-hero { padding: 6rem 1rem 2rem; }
  .article-layout { padding: 0 1rem 3rem; }
  .author-box { flex-direction: column; text-align: center; }
}
</style>
</head>
<body>

<!-- NAVBAR -->
<nav class="navbar">
  <a href="/" class="nav-logo">ANIMA</a>
  <ul class="nav-links">
    <li><a href="/">Home</a></li>
    <li><a href="/free-tools/">Tools</a></li>
    <li><a href="/free-tools/">Free Tools</a></li>
    <li><a href="https://github.com/christian140903-sudo/nextool">Pro</a></li>
    <li><a href="/blog/">Blog</a></li>
    <li><a href="https://github.com/christian140903-sudo/nextool" class="nav-cta">ANIMA</a></li>
  </ul>
  <button class="nav-mobile-toggle" aria-label="Menu">&#9776;</button>
</nav>

<!-- HERO -->
<header class="article-hero">
  <div class="article-meta">
    <span class="article-category">Developer Tools</span>
    <span class="article-date">February 10, 2026</span>
    <span class="article-reading-time">12 min read</span>
  </div>
  <h1>GraphQL for Beginners: <span>Complete Tutorial with Examples</span></h1>
  <p class="article-subtitle">Everything you need to understand GraphQL from the ground up. Covers queries, mutations, subscriptions, schema design, types, resolvers, and a practical comparison with REST -- all with code examples you can run today.</p>
</header>

<!-- ARTICLE LAYOUT -->
<div class="article-layout">

  <!-- TOC SIDEBAR -->
  <aside class="toc-sidebar">
    <div class="toc-title">Table of Contents</div>
    <ul class="toc-list">
      <li><a href="#what-is-graphql">What Is GraphQL</a></li>
      <li><a href="#graphql-vs-rest">GraphQL vs REST</a></li>
      <li><a href="#core-concepts">Core Concepts</a></li>
      <li><a href="#queries">Writing Queries</a></li>
      <li><a href="#mutations">Mutations</a></li>
      <li><a href="#subscriptions">Subscriptions</a></li>
      <li><a href="#schema-and-types">Schema &amp; Types</a></li>
      <li><a href="#resolvers">Resolvers</a></li>
      <li><a href="#getting-started">Getting Started</a></li>
      <li><a href="#faq">FAQ</a></li>
    </ul>
  </aside>

  <!-- ARTICLE CONTENT -->
  <article class="article-content">

    <h2 id="what-is-graphql">What Is GraphQL and Why Should You Learn It</h2>

    <p>GraphQL is a query language for APIs and a runtime for executing those queries against your data. Facebook developed it internally in 2012 and open-sourced it in 2015. Since then it has been adopted by GitHub, Shopify, Twitter, Airbnb, and thousands of other companies for both internal and public-facing APIs.</p>

    <p>The core idea is simple: <strong>the client decides what data it gets back.</strong> Instead of hitting a fixed endpoint that returns a predetermined JSON structure, you write a query that describes the exact shape of the data you need, send it to a single endpoint, and get back exactly that shape -- nothing more, nothing less.</p>

    <pre><code># A GraphQL query
{
  user(id: "42") {
    name
    email
    posts {
      title
      publishedAt
    }
  }
}</code></pre>

    <p>This single request returns the user's name, email, and all their post titles with publish dates. In a traditional REST API, you would need at least two requests -- one to <code>GET /users/42</code> and another to <code>GET /users/42/posts</code> -- and each response would likely include fields you do not need.</p>

    <p>That difference matters at scale. Mobile clients on slow networks benefit from fewer round trips. Frontend teams benefit from not having to ask the backend team for a new endpoint every time the UI changes. And backend teams benefit from a single, well-typed API surface instead of an ever-growing collection of endpoints.</p>

    <div class="key-takeaway">
      <div class="key-takeaway-label">Key Insight</div>
      <p><strong>GraphQL is not a database query language.</strong> Despite the name, it has nothing to do with SQL. It sits between your client and your server, giving the client a structured way to ask for exactly the data it needs. The server can fetch that data from databases, microservices, REST APIs, or any other source.</p>
    </div>

    <h2 id="graphql-vs-rest">GraphQL vs REST: A Practical Comparison</h2>

    <p>REST and GraphQL are both valid approaches to API design, and understanding their trade-offs helps you choose the right one for your project. Here is a side-by-side comparison.</p>

    <table class="comparison-table">
      <thead>
        <tr>
          <th>Aspect</th>
          <th>REST</th>
          <th>GraphQL</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Endpoints</strong></td>
          <td>Multiple (one per resource)</td>
          <td>Single endpoint for all operations</td>
        </tr>
        <tr>
          <td><strong>Data fetching</strong></td>
          <td>Server decides the response shape</td>
          <td>Client decides the response shape</td>
        </tr>
        <tr>
          <td><strong>Over-fetching</strong></td>
          <td>Common (extra fields returned)</td>
          <td>Eliminated (only requested fields)</td>
        </tr>
        <tr>
          <td><strong>Under-fetching</strong></td>
          <td>Common (multiple requests needed)</td>
          <td>Eliminated (nested data in one query)</td>
        </tr>
        <tr>
          <td><strong>Versioning</strong></td>
          <td>/api/v1/, /api/v2/ patterns</td>
          <td>No versioning needed (additive schema)</td>
        </tr>
        <tr>
          <td><strong>Caching</strong></td>
          <td>Built-in HTTP caching (ETags, Cache-Control)</td>
          <td>Requires client-side cache (Apollo, Relay)</td>
        </tr>
        <tr>
          <td><strong>Type system</strong></td>
          <td>Optional (OpenAPI/Swagger)</td>
          <td>Built-in (schema is the type system)</td>
        </tr>
        <tr>
          <td><strong>Real-time</strong></td>
          <td>Requires WebSockets or SSE separately</td>
          <td>Subscriptions are part of the spec</td>
        </tr>
        <tr>
          <td><strong>Learning curve</strong></td>
          <td>Lower (HTTP methods + URLs)</td>
          <td>Higher (schema, resolvers, query language)</td>
        </tr>
        <tr>
          <td><strong>Tooling</strong></td>
          <td>curl, Postman, browser</td>
          <td>GraphiQL, Apollo Studio, playground tools</td>
        </tr>
      </tbody>
    </table>

    <h3>When to Choose REST</h3>
    <ul>
      <li>Simple CRUD APIs with predictable data needs</li>
      <li>Public APIs where HTTP caching is critical</li>
      <li>Teams already experienced with REST conventions</li>
      <li>File uploads and streaming (simpler with REST)</li>
    </ul>

    <h3>When to Choose GraphQL</h3>
    <ul>
      <li>Multiple clients with different data requirements (web, mobile, third-party)</li>
      <li>Complex, deeply nested data relationships</li>
      <li>Rapidly evolving frontends that frequently change what data they need</li>
      <li>Microservice architectures where one API gateway aggregates multiple services</li>
    </ul>

    <p>You can test both REST and GraphQL APIs using the <a href="/free-tools/api-tester.html">ANIMA API Tester</a> -- just set the method to POST, point it at your GraphQL endpoint, and paste your query as the JSON request body.</p>

    <h2 id="core-concepts">Core Concepts You Need to Know</h2>

    <p>Before writing your first query, understand these five building blocks. Every GraphQL API is built on them.</p>

    <h3>1. Schema</h3>
    <p>The schema defines the entire API surface. It specifies what types exist, what fields each type has, what queries and mutations are available, and how types relate to each other. Think of it as the contract between the client and the server.</p>

    <h3>2. Types</h3>
    <p>GraphQL is strongly typed. Every piece of data has a type -- <code>String</code>, <code>Int</code>, <code>Float</code>, <code>Boolean</code>, <code>ID</code>, or a custom object type you define. Types prevent an entire class of bugs by catching mismatches at query validation time, before any code runs.</p>

    <h3>3. Queries</h3>
    <p>Queries are read operations. They fetch data without side effects. You write a query, send it to the server, and get back data in the exact shape you requested.</p>

    <h3>4. Mutations</h3>
    <p>Mutations are write operations. They create, update, or delete data. Like queries, they return data -- typically the modified resource, so the client can update its local state without a second request.</p>

    <h3>5. Resolvers</h3>
    <p>Resolvers are functions on the server that actually fetch the data for each field in the schema. The schema says "a User has a name and an email." The resolver says "here is how to get the name and email from the database." Resolvers are where your business logic lives.</p>

    <h2 id="queries">Writing GraphQL Queries</h2>

    <p>A GraphQL query looks like a JSON object without the values. You specify the fields you want, and the server fills in the values.</p>

    <h3>Basic Query</h3>
    <pre><code># Fetch a single user
query {
  user(id: "42") {
    name
    email
    avatarUrl
  }
}

# Response
{
  "data": {
    "user": {
      "name": "Alice Chen",
      "email": "alice@example.com",
      "avatarUrl": "https://cdn.example.com/avatars/42.jpg"
    }
  }
}</code></pre>

    <p>Notice how the response mirrors the query structure exactly. If you remove <code>avatarUrl</code> from the query, it disappears from the response. No extra fields, no wasted bandwidth.</p>

    <h3>Nested Queries</h3>
    <p>One of GraphQL's biggest advantages is fetching related data in a single request.</p>

    <pre><code>query {
  user(id: "42") {
    name
    posts(limit: 5) {
      title
      publishedAt
      comments {
        text
        author {
          name
        }
      }
    }
  }
}</code></pre>

    <p>This query returns a user, their five most recent posts, each post's comments, and each comment's author name -- all in one round trip. With REST, this would require at least four separate requests.</p>

    <h3>Query Variables</h3>
    <p>Hardcoding values in queries is fine for testing but impractical in production. Variables let you parameterize queries.</p>

    <pre><code># Query with variables
query GetUser($userId: ID!) {
  user(id: $userId) {
    name
    email
  }
}

# Variables (sent as separate JSON)
{
  "userId": "42"
}</code></pre>

    <p>The <code>$userId: ID!</code> syntax declares a required variable of type ID. The exclamation mark means it cannot be null. Your client library handles passing the variables alongside the query.</p>

    <h3>Aliases and Fragments</h3>
    <p>When you need the same field with different arguments, use aliases. When you repeat the same set of fields, use fragments.</p>

    <pre><code># Aliases: fetch two users in one query
query {
  alice: user(id: "42") {
    ...UserFields
  }
  bob: user(id: "43") {
    ...UserFields
  }
}

# Fragment: reusable field selection
fragment UserFields on User {
  name
  email
  avatarUrl
  createdAt
}</code></pre>

    <p>To experiment with queries interactively, open the <a href="/free-tools/graphql-playground.html">ANIMA GraphQL Playground</a> and connect it to any public GraphQL endpoint. You get syntax highlighting, auto-completion, and instant response formatting.</p>

    <div class="cta-box">
      <h3>Test GraphQL Queries in Your Browser</h3>
      <p>Write queries, inspect responses, and explore schemas with zero setup.</p>
      <a href="/free-tools/graphql-playground.html" class="cta-button">Open GraphQL Playground</a>
    </div>

    <h2 id="mutations">Mutations: Writing Data with GraphQL</h2>

    <p>Mutations follow the same syntax as queries but represent write operations. By convention, mutation names describe the action being performed.</p>

    <h3>Creating a Resource</h3>
    <pre><code>mutation {
  createUser(input: {
    name: "Alice Chen"
    email: "alice@example.com"
    role: EDITOR
  }) {
    id
    name
    email
    createdAt
  }
}</code></pre>

    <p>The mutation creates a user and returns the new user's <code>id</code>, <code>name</code>, <code>email</code>, and <code>createdAt</code> fields. You choose which fields to get back, just like a query. This eliminates the need for a follow-up GET request after creating a resource.</p>

    <h3>Updating a Resource</h3>
    <pre><code>mutation UpdateUser($id: ID!, $input: UpdateUserInput!) {
  updateUser(id: $id, input: $input) {
    id
    name
    email
    updatedAt
  }
}

# Variables
{
  "id": "42",
  "input": {
    "name": "Alice Smith",
    "role": "ADMIN"
  }
}</code></pre>

    <h3>Deleting a Resource</h3>
    <pre><code>mutation {
  deleteUser(id: "42") {
    success
    message
  }
}</code></pre>

    <p>Most GraphQL APIs return a success boolean and an optional message from delete mutations, though the exact return type varies by implementation.</p>

    <div class="key-takeaway">
      <div class="key-takeaway-label">Best Practice</div>
      <p><strong>Always return the modified resource from mutations.</strong> This lets the client update its cache immediately without a follow-up query. If you are building a mutation that creates a user, return the full user object. If you update a post, return the updated post.</p>
    </div>

    <h2 id="subscriptions">Subscriptions: Real-Time Data</h2>

    <p>Subscriptions are GraphQL's answer to real-time updates. While queries and mutations follow a request-response pattern, subscriptions open a persistent connection -- typically a WebSocket -- and push updates to the client whenever the specified event occurs.</p>

    <pre><code>subscription {
  messageAdded(channelId: "general") {
    id
    text
    author {
      name
      avatarUrl
    }
    createdAt
  }
}</code></pre>

    <p>When a new message is added to the "general" channel, the server pushes the message data to every subscribed client. The client specifies exactly which fields it needs, just like with queries and mutations.</p>

    <p>Common use cases for subscriptions:</p>
    <ul>
      <li><strong>Chat applications</strong> -- new messages in real time</li>
      <li><strong>Live dashboards</strong> -- metric updates as they happen</li>
      <li><strong>Notifications</strong> -- alerts pushed to the client instantly</li>
      <li><strong>Collaborative editing</strong> -- changes from other users appearing live</li>
      <li><strong>Order tracking</strong> -- status changes pushed to the customer</li>
    </ul>

    <p>Subscriptions require a WebSocket-capable server. Apollo Server, Hasura, and most modern GraphQL frameworks support them out of the box.</p>

    <h2 id="schema-and-types">Schema Definition and the Type System</h2>

    <p>The schema is the backbone of every GraphQL API. It is written in the Schema Definition Language (SDL) and defines every type, field, query, mutation, and subscription your API supports.</p>

    <h3>Scalar Types</h3>
    <p>GraphQL includes five built-in scalar types:</p>
    <ul>
      <li><code>String</code> -- UTF-8 text</li>
      <li><code>Int</code> -- 32-bit signed integer</li>
      <li><code>Float</code> -- double-precision floating point</li>
      <li><code>Boolean</code> -- true or false</li>
      <li><code>ID</code> -- a unique identifier (serialized as a string)</li>
    </ul>

    <p>You can also define custom scalars like <code>DateTime</code>, <code>URL</code>, or <code>JSON</code> for domain-specific data.</p>

    <h3>Object Types</h3>
    <pre><code>type User {
  id: ID!
  name: String!
  email: String!
  bio: String
  role: Role!
  posts: [Post!]!
  createdAt: DateTime!
}

type Post {
  id: ID!
  title: String!
  body: String!
  author: User!
  comments: [Comment!]!
  publishedAt: DateTime
}

type Comment {
  id: ID!
  text: String!
  author: User!
  post: Post!
  createdAt: DateTime!
}</code></pre>

    <p>The <code>!</code> means a field is non-nullable -- the server guarantees it will always have a value. <code>[Post!]!</code> means the field returns a non-null list of non-null Post objects. This type system catches errors before any code runs. If a client queries a field that does not exist, or passes a string where an integer is expected, the server rejects the query at validation time.</p>

    <h3>Enum Types</h3>
    <pre><code>enum Role {
  VIEWER
  EDITOR
  ADMIN
}

enum PostStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}</code></pre>

    <p>Enums restrict a field to a fixed set of values. They are self-documenting and prevent invalid states.</p>

    <h3>Input Types</h3>
    <pre><code>input CreateUserInput {
  name: String!
  email: String!
  role: Role = VIEWER
}

input UpdateUserInput {
  name: String
  email: String
  role: Role
}</code></pre>

    <p>Input types define the shape of data sent to mutations. Note the <code>= VIEWER</code> default value on the role field in <code>CreateUserInput</code>.</p>

    <h3>The Root Types</h3>
    <pre><code>type Query {
  user(id: ID!): User
  users(limit: Int = 20, offset: Int = 0): [User!]!
  post(id: ID!): Post
  searchPosts(query: String!): [Post!]!
}

type Mutation {
  createUser(input: CreateUserInput!): User!
  updateUser(id: ID!, input: UpdateUserInput!): User!
  deleteUser(id: ID!): Boolean!
  createPost(input: CreatePostInput!): Post!
}

type Subscription {
  messageAdded(channelId: ID!): Message!
  postPublished: Post!
}</code></pre>

    <p>These three root types -- Query, Mutation, and Subscription -- are the entry points to your API. Every operation a client can perform starts here.</p>

    <p>Use the <a href="/free-tools/json-schema-generator.html">ANIMA JSON Schema Generator</a> to convert sample JSON responses into structured schemas. It is especially useful when you are designing a GraphQL schema based on existing REST API responses.</p>

    <h2 id="resolvers">Resolvers: Where the Data Actually Comes From</h2>

    <p>A schema declares what data is available. Resolvers implement how that data is fetched. Every field in the schema can have a resolver function. In practice, you only write resolvers for fields that require custom logic -- GraphQL frameworks provide default resolvers for simple property access.</p>

    <h3>Basic Resolvers in JavaScript</h3>
    <pre><code>const resolvers = {
  Query: {
    user: async (parent, { id }, context) => {
      return context.db.users.findById(id);
    },
    users: async (parent, { limit, offset }, context) => {
      return context.db.users.findAll({ limit, offset });
    },
  },

  Mutation: {
    createUser: async (parent, { input }, context) => {
      const user = await context.db.users.create(input);
      return user;
    },
    deleteUser: async (parent, { id }, context) => {
      await context.db.users.delete(id);
      return true;
    },
  },

  User: {
    posts: async (user, args, context) => {
      return context.db.posts.findByAuthorId(user.id);
    },
  },
};</code></pre>

    <p>Each resolver receives four arguments:</p>
    <ul>
      <li><code>parent</code> -- the result of the parent resolver (useful for nested fields)</li>
      <li><code>args</code> -- the arguments passed to the field in the query</li>
      <li><code>context</code> -- shared state like database connections, authentication info, and data loaders</li>
      <li><code>info</code> -- metadata about the query (rarely used directly)</li>
    </ul>

    <h3>The N+1 Problem and DataLoader</h3>
    <p>Consider a query that fetches 20 users and each user's posts. Without optimization, the server runs 1 query for the user list + 20 queries for each user's posts = 21 database queries. This is the N+1 problem.</p>

    <p>The standard solution is <strong>DataLoader</strong>, a batching utility. Instead of fetching posts for each user individually, DataLoader collects all the user IDs, waits for the current execution tick to complete, then runs a single batch query: <code>SELECT * FROM posts WHERE author_id IN (id1, id2, ... id20)</code>. This reduces 21 queries to 2.</p>

    <pre><code>const DataLoader = require('dataloader');

const postLoader = new DataLoader(async (userIds) => {
  const posts = await db.posts.findByAuthorIds(userIds);
  // Group posts by author_id to match the input order
  return userIds.map(id =>
    posts.filter(post => post.authorId === id)
  );
});

// In the User resolver
User: {
  posts: (user) => postLoader.load(user.id),
}</code></pre>

    <div class="key-takeaway">
      <div class="key-takeaway-label">Performance Tip</div>
      <p><strong>Always use DataLoader for resolvers that fetch related data.</strong> Without it, a single GraphQL query can generate hundreds of database queries. DataLoader is not optional in production -- it is essential.</p>
    </div>

    <h2 id="getting-started">Getting Started: Your First GraphQL Server</h2>

    <p>The fastest way to build a GraphQL server in 2026 is with Apollo Server and Node.js. Here is a minimal working example.</p>

    <h3>Step 1: Initialize the Project</h3>
    <pre><code>mkdir graphql-demo && cd graphql-demo
npm init -y
npm install @apollo/server graphql</code></pre>

    <h3>Step 2: Write the Server</h3>
    <pre><code>// index.js
import { ApolloServer } from '@apollo/server';
import { startStandaloneServer } from '@apollo/server/standalone';

// Schema
const typeDefs = `
  type Book {
    id: ID!
    title: String!
    author: String!
    year: Int
  }

  type Query {
    books: [Book!]!
    book(id: ID!): Book
  }

  type Mutation {
    addBook(title: String!, author: String!, year: Int): Book!
  }
`;

// In-memory data
let books = [
  { id: "1", title: "The Pragmatic Programmer", author: "David Thomas", year: 1999 },
  { id: "2", title: "Clean Code", author: "Robert C. Martin", year: 2008 },
  { id: "3", title: "Designing Data-Intensive Applications", author: "Martin Kleppmann", year: 2017 },
];

// Resolvers
const resolvers = {
  Query: {
    books: () => books,
    book: (_, { id }) => books.find(b => b.id === id),
  },
  Mutation: {
    addBook: (_, { title, author, year }) => {
      const book = { id: String(books.length + 1), title, author, year };
      books.push(book);
      return book;
    },
  },
};

// Start the server
const server = new ApolloServer({ typeDefs, resolvers });
const { url } = await startStandaloneServer(server, { listen: { port: 4000 } });
console.log(`Server running at ${url}`);</code></pre>

    <h3>Step 3: Run and Test</h3>
    <pre><code># Start the server
node index.js

# Test with curl
curl -X POST http://localhost:4000/ \
  -H "Content-Type: application/json" \
  -d '{"query": "{ books { title author year } }"}'</code></pre>

    <p>Open <code>http://localhost:4000</code> in your browser and Apollo Server serves a built-in GraphQL sandbox where you can write and run queries interactively.</p>

    <p>For formatting and inspecting the JSON responses from your GraphQL server, paste the output into the <a href="/free-tools/json-formatter.html">ANIMA JSON Formatter</a> for a collapsible, syntax-highlighted tree view.</p>

    <h3>Practice with Public APIs</h3>
    <p>If you want to practice queries without setting up a server, these public GraphQL APIs are available:</p>
    <ul>
      <li><strong>GitHub GraphQL API</strong> -- <code>https://api.github.com/graphql</code> (requires a personal access token)</li>
      <li><strong>Star Wars API (SWAPI)</strong> -- <code>https://swapi-graphql.netlify.app/.netlify/functions/index</code></li>
      <li><strong>Countries API</strong> -- <code>https://countries.trevorblades.com/graphql</code></li>
      <li><strong>SpaceX API</strong> -- <code>https://spacex-production.up.railway.app/graphql</code></li>
    </ul>

    <h2 id="faq">Frequently Asked Questions</h2>

    <h3>What is GraphQL and how is it different from REST?</h3>
    <p>GraphQL is a query language for APIs that lets clients request exactly the data they need in a single request. Unlike REST, where each endpoint returns a fixed data structure and you often need multiple requests to assemble a complete view, GraphQL exposes a single endpoint and lets the client specify the shape of the response. This eliminates over-fetching (getting fields you do not need) and under-fetching (needing extra requests for related data). REST organizes data around resources with separate URLs, while GraphQL organizes data around a typed schema that clients query with a flexible syntax.</p>

    <h3>What are queries, mutations, and subscriptions in GraphQL?</h3>
    <p>Queries are read operations that fetch data from the server without changing anything. Mutations are write operations that create, update, or delete data on the server and return the modified result. Subscriptions are long-lived connections, typically over WebSockets, that push real-time updates from the server to the client whenever specified data changes. Queries are analogous to GET requests in REST, mutations map to POST, PUT, PATCH, and DELETE, and subscriptions have no direct REST equivalent because REST is inherently request-response based.</p>

    <h3>What is a GraphQL schema and why does it matter?</h3>
    <p>A GraphQL schema is a strongly typed contract that defines every type of data your API can return, every query clients can run, every mutation they can perform, and the relationships between types. It is written in the Schema Definition Language (SDL) and serves as the single source of truth for both frontend and backend teams. The schema matters because it enables auto-completion in development tools, automatic documentation generation, compile-time validation of queries, and clear communication between teams about what the API can and cannot do.</p>

    <h3>Is GraphQL better than REST?</h3>
    <p>Neither is universally better. GraphQL is a strong choice when your client needs flexible data fetching, when you have multiple clients (web, mobile, third-party) with different data needs, or when you want to reduce the number of network requests. REST is a strong choice for simple CRUD APIs, when you need aggressive HTTP caching, when your team is already experienced with REST conventions, or when your API serves a single client with predictable data needs. Many production systems use both: REST for simple public endpoints and GraphQL for complex internal data fetching.</p>

    <h3>What tools do I need to start learning GraphQL?</h3>
    <p>To start learning GraphQL you need a <a href="/free-tools/graphql-playground.html">GraphQL playground</a> for writing and testing queries interactively, a <a href="/free-tools/json-formatter.html">JSON formatter</a> for inspecting responses, and optionally an <a href="/free-tools/api-tester.html">API testing tool</a> for sending raw HTTP requests to a GraphQL endpoint. On the server side, popular frameworks include Apollo Server for JavaScript and TypeScript, Strawberry for Python, and graphql-java for Java. Public GraphQL APIs like the GitHub GraphQL API and the Star Wars API (SWAPI GraphQL) let you practice queries without setting up a server.</p>

    <!-- CTA Box -->
    <div class="cta-box">
      <h3>Explore 150+ Free Developer Tools</h3>
      <p>GraphQL Playground, API Tester, JSON Formatter, and more. All browser-based, no signup required.</p>
      <a href="/free-tools/" class="cta-button">Browse All Free Tools</a>
    </div>

    <!-- AUTHOR BOX -->
    <div class="author-box">
      <div class="author-avatar">NT</div>
      <div class="author-info">
        <h4>Christian Bucher</h4>
        <p>We build free, privacy-first developer tools. Our mission is to make the tools you reach for every day faster, cleaner, and more respectful of your data.</p>
      </div>
    </div>

    <!-- RELATED ARTICLES -->
    <div class="related-articles">
      <h3>Related Articles</h3>
      <div class="related-grid">
        <a href="/blog/how-to-test-api-endpoints-guide.html" class="related-card">
          <div class="related-card-cat">Developer Tools</div>
          <h4>How to Test API Endpoints: A Complete Guide</h4>
          <p>Everything you need to know about testing REST API endpoints with curl, free tools, and automation.</p>
        </a>
        <a href="/blog/how-to-format-json-complete-guide.html" class="related-card">
          <div class="related-card-cat">Developer Tools</div>
          <h4>How to Format JSON: The Complete Guide</h4>
          <p>Everything you need to know about formatting, validating, and beautifying JSON data with examples and free tools.</p>
        </a>
        <a href="/blog/data-format-conversion-guide.html" class="related-card">
          <div class="related-card-cat">Data &amp; Development</div>
          <h4>How to Convert Between JSON, CSV, XML, and YAML</h4>
          <p>A practical guide to data format conversion with code examples, pitfalls, and free online tools.</p>
        </a>
      </div>
    </div>

  </article>
</div>

<!-- FOOTER -->

<!-- AUTO-LINKED by ANIMA Engine -->
<div style="margin:2rem 0;padding:1.5rem;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius)">
<p style="font-weight:600;margin-bottom:.5rem">Related Tools</p>
<p><a href="/free-tools/box-shadow-generator.html" style="color:var(--primary);text-decoration:none">CSS Box Shadow Generator</a> · <a href="/free-tools/emoji-picker.html" style="color:var(--primary);text-decoration:none">Emoji Picker & Search</a> · <a href="/free-tools/favicon-generator.html" style="color:var(--primary);text-decoration:none">Favicon Generator</a></p>
</div>

<!-- AUTO-LINKED by ANIMA Engine -->
<div style="margin:2rem 0;padding:1.5rem;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius)">
<p style="font-weight:600;margin-bottom:.5rem">Related Tools</p>
<p><a href="/free-tools/icon-generator.html" style="color:var(--primary);text-decoration:none">Free Icon Generator</a> · <a href="/free-tools/api-mock-server.html" style="color:var(--primary);text-decoration:none">Free API Mock Server</a> · <a href="/free-tools/api-request-builder.html" style="color:var(--primary);text-decoration:none">Free API Request Builder</a></p>
</div>

<!-- AUTO-LINKED by ANIMA Engine -->
<div style="margin:2rem 0;padding:1.5rem;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius)">
<p style="font-weight:600;margin-bottom:.5rem">Related Tools</p>
<p><a href="/free-tools/git-diff-viewer.html" style="color:var(--primary);text-decoration:none">Free Git Diff Viewer</a> · <a href="/free-tools/json-to-yaml-converter.html" style="color:var(--primary);text-decoration:none">Free JSON to YAML Converter</a> · <a href="/free-tools/regex-playground.html" style="color:var(--primary);text-decoration:none">Free Regex Playground</a></p>
</div>
<footer class="site-footer">
  <div class="footer-grid">
    <div class="footer-col">
      <div class="footer-brand">ANIMA</div>
      <p class="footer-brand-desc">253+ free developer tools for developers and designers. Browser-based, no signup.</p>
    </div>
    <div class="footer-col">
      <h4>Free Tools</h4>
      <a href="/free-tools/">All 150+ Tools</a>
      <a href="/free-tools/json-formatter.html">JSON Formatter</a>
      <a href="/free-tools/csv-formatter.html">CSV Formatter</a>
      <a href="/free-tools/regex-tester.html">Regex Tester</a>
      <a href="/free-tools/image-compressor.html">Image Compressor</a>
    </div>
    <div class="footer-col">
      <h4>Explore</h4>
      <a href="https://github.com/christian140903-sudo/nextool">ANIMA</a>
      <a href="/workspace.html">Workspace</a>
      <a href="/blog/">Blog</a>
      <a href="/terms.html">Terms</a>
    </div>
    <div class="footer-col">
      <h4>Connect</h4>
      <a href="mailto:hello@nextool.app">Email Us</a>
      <a href="/imprint.html">Imprint</a>
    </div>
  </div>
  <div class="footer-bottom">&copy; 2026 ANIMA. All rights reserved.</div>
</footer>

<script>
// TOC active state
const tocLinks = document.querySelectorAll('.toc-list a');
const sections = document.querySelectorAll('.article-content h2[id]');
window.addEventListener('scroll', () => {
  let current = '';
  sections.forEach(s => { if (window.scrollY >= s.offsetTop - 120) current = s.id; });
  tocLinks.forEach(l => {
    l.classList.remove('active');
    if (l.getAttribute('href') === '#' + current) l.classList.add('active');
  });
});
// Mobile nav toggle
document.querySelector('.nav-mobile-toggle')?.addEventListener('click', () => {
  const links = document.querySelector('.nav-links');
  links.style.display = links.style.display === 'flex' ? 'none' : 'flex';
  links.style.flexDirection = 'column';
  links.style.position = 'absolute';
  links.style.top = '64px';
  links.style.right = '1rem';
  links.style.background = 'var(--surface)';
  links.style.padding = '1rem';
  links.style.borderRadius = '12px';
  links.style.border = '1px solid var(--border)';
});
</script>
<script src="/js/analytics-lite.js" defer></script>
<script src="/js/revenue.js" defer></script>
<script src="/js/lead-capture.js" defer></script>
</body>
</html>