<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Password Security in 2026: Developer Best Practices | NexTool</title>
    <meta name="description" content="Complete password security guide for developers. Learn bcrypt, argon2, scrypt hashing, salting, password policies, 2FA implementation, and passkey adoption in 2026.">
    <meta name="keywords" content="password security best practices, bcrypt vs argon2, password hashing, password salting, passkeys, 2fa developer, scrypt hashing, password policy 2026, password strength, secure authentication">
    <meta name="author" content="NexTool Team">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://nextool.app/blog/password-security-best-practices.html">

    <!-- Open Graph -->
    <meta property="og:type" content="article">
    <meta property="og:title" content="Password Security in 2026: Best Practices for Developers">
    <meta property="og:description" content="Complete password security guide. Learn bcrypt, argon2, scrypt hashing, salting, 2FA, and passkey adoption for modern applications.">
    <meta property="og:url" content="https://nextool.app/blog/password-security-best-practices.html">
    <meta property="og:site_name" content="NexTool">
    <meta property="og:image" content="https://nextool.app/assets/images/blog/password-security-best-practices-og.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="article:published_time" content="2026-02-14T09:00:00Z">
    <meta property="article:modified_time" content="2026-02-14T09:00:00Z">
    <meta property="article:author" content="NexTool Team">
    <meta property="article:section" content="Security">
    <meta property="article:tag" content="Security">
    <meta property="article:tag" content="Passwords">
    <meta property="article:tag" content="Authentication">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Password Security in 2026: Best Practices for Developers">
    <meta name="twitter:description" content="Complete password security guide for developers. Bcrypt, argon2, scrypt, salting, 2FA, and passkeys.">
    <meta name="twitter:image" content="https://nextool.app/assets/images/blog/password-security-best-practices-og.png">

    <!-- JSON-LD: Article -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Article",
        "headline": "Password Security in 2026: Best Practices for Developers",
        "description": "Complete password security guide for developers. Learn bcrypt, argon2, scrypt hashing, salting, password policies, 2FA implementation, and passkey adoption in 2026.",
        "image": "https://nextool.app/assets/images/blog/password-security-best-practices-og.png",
        "author": {
            "@type": "Organization",
            "name": "NexTool Team",
            "url": "https://nextool.app"
        },
        "publisher": {
            "@type": "Organization",
            "name": "NexTool",
            "logo": {
                "@type": "ImageObject",
                "url": "https://nextool.app/assets/images/logo.png"
            }
        },
        "datePublished": "2026-02-14T09:00:00Z",
        "dateModified": "2026-02-14T09:00:00Z",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://nextool.app/blog/password-security-best-practices.html"
        },
        "wordCount": 2900,
        "keywords": ["password security", "bcrypt", "argon2", "scrypt", "password hashing", "salting", "2FA", "passkeys", "authentication"]
    }
    </script>

    <!-- JSON-LD: BreadcrumbList -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BreadcrumbList",
        "itemListElement": [
            {
                "@type": "ListItem",
                "position": 1,
                "name": "Home",
                "item": "https://nextool.app"
            },
            {
                "@type": "ListItem",
                "position": 2,
                "name": "Blog",
                "item": "https://nextool.app/blog/"
            },
            {
                "@type": "ListItem",
                "position": 3,
                "name": "Password Security Best Practices",
                "item": "https://nextool.app/blog/password-security-best-practices.html"
            }
        ]
    }
    </script>

    <!-- JSON-LD: FAQPage -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "FAQPage",
        "mainEntity": [
            {
                "@type": "Question",
                "name": "Should I use bcrypt or Argon2 for password hashing in 2026?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Argon2id is the recommended choice for new projects in 2026. It won the Password Hashing Competition in 2015 and has been the OWASP recommendation since 2023. Argon2id is memory-hard, making it resistant to both GPU and ASIC attacks, and it lets you configure memory usage, parallelism, and iteration count independently. However, bcrypt remains a solid choice if your platform does not have a well-tested Argon2 library. Bcrypt has been battle-tested for over 25 years and is supported everywhere. The most important thing is to use any of the recommended algorithms (Argon2id, bcrypt, or scrypt) rather than MD5, SHA-1, SHA-256, or any unsalted/fast hash."
                }
            },
            {
                "@type": "Question",
                "name": "What is password salting and why is it important?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "A salt is a random string that is appended or prepended to a password before hashing. Each user gets a unique salt, which is stored alongside the hash in the database. Salting is important because it prevents two users with the same password from having the same hash (defeating rainbow table attacks), and it makes precomputed hash tables useless. Without salting, an attacker who obtains your database can look up common password hashes in a rainbow table and crack millions of passwords instantly. With unique salts, each password must be attacked individually. Modern hashing functions like bcrypt and Argon2 generate and embed the salt automatically, so you do not need to manage salts manually."
                }
            },
            {
                "@type": "Question",
                "name": "What password length and complexity rules should I enforce?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "NIST SP 800-63B (updated 2024) recommends: minimum 8 characters (15+ is better), maximum at least 64 characters, allow all printable ASCII characters plus Unicode, check against a list of known breached passwords (like the Have I Been Pwned database), do NOT require specific character classes (uppercase, lowercase, digit, symbol), and do NOT force periodic password changes. The reasoning is that complexity rules lead users to create predictable patterns like 'Password1!' while a long passphrase like 'correct horse battery staple' is both stronger and easier to remember. Focus on length and breach checking rather than arbitrary complexity rules."
                }
            },
            {
                "@type": "Question",
                "name": "How do I implement two-factor authentication (2FA) correctly?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Implement TOTP (Time-based One-Time Password) as the baseline 2FA method. Use a library that generates a shared secret, creates a QR code for authenticator apps (Google Authenticator, Authy, 1Password), and validates 6-digit codes with a time window of plus or minus one step (30 seconds). Store the shared secret encrypted in your database. Always provide backup codes (8-10 single-use codes) during setup. For higher security, support WebAuthn/FIDO2 security keys. Avoid SMS-based 2FA as the primary option because SIM swapping attacks are well-documented, though SMS is still better than no 2FA at all. Never use email as a second factor for the same account's password reset flow."
                }
            },
            {
                "@type": "Question",
                "name": "What are passkeys and should I support them?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Passkeys are a passwordless authentication standard built on WebAuthn/FIDO2. Instead of a password, users authenticate with their device's biometric sensor (fingerprint, face), a PIN, or a security key. The cryptographic key pair is stored on the user's device (or synced via their platform's cloud keychain), and only the public key is stored on the server. Passkeys are phishing-resistant by design because the browser verifies the domain. As of 2026, passkeys are supported by Apple (iCloud Keychain), Google (Google Password Manager), Microsoft (Windows Hello), and all major browsers. You should support passkeys alongside traditional passwords. Use a WebAuthn library like SimpleWebAuthn (JavaScript) or py-webauthn (Python) to implement them."
                }
            },
            {
                "@type": "Question",
                "name": "How do I check if a password has been exposed in a data breach?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Use the Have I Been Pwned (HIBP) Passwords API with k-anonymity. Hash the password with SHA-1, send only the first 5 characters of the hash to the API, and receive a list of matching hash suffixes. Check if the full hash appears in the response. This approach never sends the actual password or the full hash to any external service. The API is free and returns the number of times each password has appeared in known breaches. In practice, you can integrate this check at registration and password change. NexTool's Password Strength Checker performs this check entirely in your browser. Block any password that has appeared in more than 0 breaches, or at minimum warn the user and require confirmation."
                }
            }
        ]
    }
    </script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <style>
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #050508;
            --surface: #0a0a0f;
            --surface-2: #1a1a24;
            --surface-3: #232330;
            --primary: #6366f1;
            --primary-hover: #818cf8;
            --accent: #a855f7;
            --accent-hover: #c084fc;
            --text: #e2e8f0;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --border: #1e1e2e;
            --success: #22c55e;
            --warning: #f59e0b;
            --error: #ef4444;
            --code-bg: #0d0d14;
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --font-mono: 'JetBrains Mono', 'Fira Code', monospace;
            --max-width: 800px;
            --header-height: 64px;
        }

        html { scroll-behavior: smooth; -webkit-text-size-adjust: 100%; }
        body { font-family: var(--font-sans); background: var(--bg); color: var(--text); line-height: 1.75; font-size: 16px; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; overflow-x: hidden; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg); }
        ::-webkit-scrollbar-thumb { background: var(--surface-3); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

        .nav { position: fixed; top: 0; left: 0; right: 0; height: var(--header-height); background: rgba(5, 5, 8, 0.85); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-bottom: 1px solid var(--border); z-index: 1000; display: flex; align-items: center; justify-content: center; }
        .nav-inner { width: 100%; max-width: 1200px; padding: 0 24px; display: flex; align-items: center; justify-content: space-between; }
        .nav-logo { display: flex; align-items: center; gap: 10px; text-decoration: none; color: var(--text); font-weight: 700; font-size: 1.25rem; }
        .nav-logo-icon { width: 32px; height: 32px; background: linear-gradient(135deg, var(--primary), var(--accent)); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 0.875rem; font-weight: 800; color: #fff; }
        .nav-links { display: flex; align-items: center; gap: 28px; list-style: none; }
        .nav-links a { color: var(--text-secondary); text-decoration: none; font-size: 0.9rem; font-weight: 500; transition: color 0.2s; }
        .nav-links a:hover { color: var(--text); }
        .nav-cta { background: var(--primary); color: #fff !important; padding: 8px 20px; border-radius: 8px; font-weight: 600; transition: background 0.2s, transform 0.2s; }
        .nav-cta:hover { background: var(--primary-hover); transform: translateY(-1px); }

        .article-wrapper { max-width: var(--max-width); margin: 0 auto; padding: calc(var(--header-height) + 48px) 24px 80px; }
        .breadcrumb { display: flex; align-items: center; gap: 8px; margin-bottom: 32px; font-size: 0.85rem; color: var(--text-muted); flex-wrap: wrap; }
        .breadcrumb a { color: var(--text-secondary); text-decoration: none; transition: color 0.2s; }
        .breadcrumb a:hover { color: var(--primary); }

        .article-header { margin-bottom: 48px; padding-bottom: 32px; border-bottom: 1px solid var(--border); }
        .article-category { display: inline-block; background: rgba(168, 85, 247, 0.12); color: var(--accent); padding: 4px 14px; border-radius: 20px; font-size: 0.8rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 16px; }
        .article-title { font-size: clamp(2rem, 5vw, 3rem); font-weight: 800; line-height: 1.15; color: var(--text); margin-bottom: 16px; letter-spacing: -0.03em; }
        .article-subtitle { font-size: 1.2rem; color: var(--text-secondary); line-height: 1.6; margin-bottom: 24px; }
        .article-meta { display: flex; align-items: center; gap: 20px; color: var(--text-muted); font-size: 0.875rem; flex-wrap: wrap; }
        .article-meta-item { display: flex; align-items: center; gap: 6px; }
        .article-meta-item svg { width: 16px; height: 16px; opacity: 0.7; }

        .toc { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 24px 28px; margin-bottom: 48px; }
        .toc-title { font-size: 0.85rem; font-weight: 700; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 16px; }
        .toc-list { list-style: none; counter-reset: toc; }
        .toc-list li { counter-increment: toc; margin-bottom: 8px; }
        .toc-list li a { color: var(--text-secondary); text-decoration: none; font-size: 0.925rem; display: flex; align-items: baseline; gap: 10px; transition: color 0.2s, padding-left 0.2s; padding: 4px 0; }
        .toc-list li a::before { content: counter(toc, decimal-leading-zero); color: var(--text-muted); font-size: 0.8rem; font-family: var(--font-mono); min-width: 20px; }
        .toc-list li a:hover { color: var(--primary); padding-left: 4px; }

        .article-content h2 { font-size: 1.75rem; font-weight: 700; color: var(--text); margin-top: 56px; margin-bottom: 20px; letter-spacing: -0.02em; line-height: 1.3; padding-top: 16px; border-top: 1px solid var(--border); }
        .article-content h2:first-child { margin-top: 0; padding-top: 0; border-top: none; }
        .article-content h3 { font-size: 1.3rem; font-weight: 600; color: var(--text); margin-top: 36px; margin-bottom: 14px; line-height: 1.35; }
        .article-content h4 { font-size: 1.1rem; font-weight: 600; color: var(--text-secondary); margin-top: 28px; margin-bottom: 12px; }
        .article-content p { margin-bottom: 20px; color: var(--text-secondary); line-height: 1.8; }
        .article-content a { color: var(--primary); text-decoration: none; border-bottom: 1px solid transparent; transition: border-color 0.2s; }
        .article-content a:hover { border-bottom-color: var(--primary); }
        .article-content strong { color: var(--text); font-weight: 600; }
        .article-content ul, .article-content ol { margin-bottom: 20px; padding-left: 24px; color: var(--text-secondary); }
        .article-content li { margin-bottom: 10px; line-height: 1.7; }
        .article-content li::marker { color: var(--primary); }
        .article-content blockquote { border-left: 3px solid var(--accent); background: var(--surface); padding: 16px 24px; margin: 28px 0; border-radius: 0 8px 8px 0; font-style: italic; color: var(--text-secondary); }
        .article-content blockquote p:last-child { margin-bottom: 0; }
        .article-content hr { border: none; border-top: 1px solid var(--border); margin: 48px 0; }

        .article-content pre { background: var(--code-bg); border: 1px solid var(--border); border-radius: 12px; padding: 20px 24px; overflow-x: auto; margin: 24px 0; }
        .article-content pre code { font-family: var(--font-mono); font-size: 0.875rem; line-height: 1.65; color: var(--text); background: none; padding: 0; border-radius: 0; }
        .article-content code { font-family: var(--font-mono); font-size: 0.85em; background: var(--surface); color: var(--accent); padding: 2px 8px; border-radius: 5px; }
        .code-label { display: inline-block; background: var(--surface-2); color: var(--text-muted); font-family: var(--font-mono); font-size: 0.75rem; padding: 2px 10px; border-radius: 6px 6px 0 0; margin-bottom: -1px; position: relative; top: 1px; }

        .article-content table { width: 100%; border-collapse: collapse; margin: 24px 0; font-size: 0.925rem; }
        .article-content thead th { background: var(--surface); color: var(--text); font-weight: 600; text-align: left; padding: 12px 16px; border-bottom: 2px solid var(--border); }
        .article-content tbody td { padding: 12px 16px; border-bottom: 1px solid var(--border); color: var(--text-secondary); }
        .article-content tbody tr:hover { background: var(--surface); }

        .info-box { background: rgba(99, 102, 241, 0.08); border: 1px solid rgba(99, 102, 241, 0.2); border-radius: 12px; padding: 20px 24px; margin: 28px 0; }
        .info-box.warning { background: rgba(245, 158, 11, 0.08); border-color: rgba(245, 158, 11, 0.2); }
        .info-box.danger { background: rgba(239, 68, 68, 0.08); border-color: rgba(239, 68, 68, 0.2); }
        .info-box.success { background: rgba(34, 197, 94, 0.08); border-color: rgba(34, 197, 94, 0.2); }
        .info-box-title { font-weight: 700; margin-bottom: 8px; font-size: 0.9rem; display: flex; align-items: center; gap: 8px; }
        .info-box p { color: var(--text-secondary); font-size: 0.925rem; margin-bottom: 0; }

        .tool-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 16px; margin: 28px 0; }
        .tool-card { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 20px; text-decoration: none; color: var(--text); transition: border-color 0.2s, transform 0.2s, box-shadow 0.2s; display: flex; flex-direction: column; gap: 8px; }
        .tool-card:hover { border-color: var(--primary); transform: translateY(-2px); box-shadow: 0 8px 24px rgba(99, 102, 241, 0.1); }
        .tool-card-icon { font-size: 1.5rem; margin-bottom: 4px; }
        .tool-card-name { font-weight: 600; font-size: 0.95rem; }
        .tool-card-desc { font-size: 0.825rem; color: var(--text-muted); line-height: 1.5; }

        .cta-box { background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(168, 85, 247, 0.1)); border: 1px solid rgba(99, 102, 241, 0.25); border-radius: 16px; padding: 40px 32px; text-align: center; margin: 48px 0; }
        .cta-box h3 { font-size: 1.5rem; font-weight: 700; margin-bottom: 12px; color: var(--text); }
        .cta-box p { color: var(--text-secondary); margin-bottom: 24px; max-width: 500px; margin-left: auto; margin-right: auto; }
        .cta-button { display: inline-flex; align-items: center; gap: 8px; background: var(--primary); color: #fff; padding: 14px 32px; border-radius: 10px; text-decoration: none; font-weight: 600; font-size: 1rem; transition: background 0.2s, transform 0.2s, box-shadow 0.2s; }
        .cta-button:hover { background: var(--primary-hover); transform: translateY(-2px); box-shadow: 0 8px 32px rgba(99, 102, 241, 0.3); }
        .cta-button.secondary { background: transparent; border: 1px solid var(--primary); color: var(--primary); margin-left: 12px; }
        .cta-button.secondary:hover { background: rgba(99, 102, 241, 0.1); }

        .faq-section { margin-top: 56px; padding-top: 32px; border-top: 1px solid var(--border); }
        .faq-section h2 { margin-top: 0 !important; padding-top: 0 !important; border-top: none !important; }
        .faq-item { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; margin-bottom: 12px; overflow: hidden; }
        .faq-question { width: 100%; background: none; border: none; color: var(--text); padding: 20px 24px; font-size: 1rem; font-weight: 600; text-align: left; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-family: var(--font-sans); transition: background 0.2s; }
        .faq-question:hover { background: var(--surface-2); }
        .faq-question .icon { transition: transform 0.3s; font-size: 1.25rem; color: var(--text-muted); flex-shrink: 0; margin-left: 16px; }
        .faq-item.open .faq-question .icon { transform: rotate(45deg); }
        .faq-answer { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; }
        .faq-answer-inner { padding: 0 24px 20px; color: var(--text-secondary); line-height: 1.7; }

        .author-box { display: flex; align-items: center; gap: 20px; background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 24px; margin: 48px 0; }
        .author-avatar { width: 64px; height: 64px; background: linear-gradient(135deg, var(--primary), var(--accent)); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; font-weight: 700; color: #fff; flex-shrink: 0; }
        .author-info h4 { font-weight: 600; margin-bottom: 4px; }
        .author-info p { color: var(--text-muted); font-size: 0.875rem; margin: 0; line-height: 1.5; }

        .footer { border-top: 1px solid var(--border); padding: 48px 24px; text-align: center; color: var(--text-muted); font-size: 0.85rem; }
        .footer-inner { max-width: 1200px; margin: 0 auto; }
        .footer-links { display: flex; justify-content: center; gap: 24px; margin-bottom: 20px; flex-wrap: wrap; }
        .footer-links a { color: var(--text-secondary); text-decoration: none; transition: color 0.2s; }
        .footer-links a:hover { color: var(--primary); }

        @media (max-width: 768px) {
            .nav-links { display: none; }
            .article-wrapper { padding: calc(var(--header-height) + 24px) 16px 60px; }
            .article-title { font-size: 1.75rem; }
            .tool-grid { grid-template-columns: 1fr; }
            .cta-box { padding: 28px 20px; }
            .cta-button.secondary { margin-left: 0; margin-top: 12px; }
            .author-box { flex-direction: column; text-align: center; }
            .article-content pre { padding: 16px; border-radius: 8px; }
            .article-content h2 { font-size: 1.4rem; }
            .article-content h3 { font-size: 1.15rem; }
            .article-content table { display: block; overflow-x: auto; }
        }
        @media (max-width: 480px) {
            .article-title { font-size: 1.5rem; }
            .toc { padding: 18px 20px; }
        }
    </style>
</head>
<body>

    <!-- Navigation -->
    <nav class="nav">
        <div class="nav-inner">
            <a href="https://nextool.app" class="nav-logo">
                <div class="nav-logo-icon">N</div>
                NexTool
            </a>
            <ul class="nav-links">
                <li><a href="https://nextool.app/#services">Tools</a></li>
                <li><a href="https://nextool.app/free-tools/">Free Tools</a></li>
                <li><a href="https://nextool.app/blog/">Blog</a></li>
                <li><a href="https://nextool.app/#contact" class="nav-cta">Browse Tools</a></li>
            </ul>
        </div>
    </nav>

    <!-- Article -->
    <article class="article-wrapper" itemscope itemtype="https://schema.org/Article">
        <!-- Breadcrumb -->
        <nav class="breadcrumb" aria-label="Breadcrumb">
            <a href="https://nextool.app">Home</a>
            <span class="separator">/</span>
            <a href="https://nextool.app/blog/">Blog</a>
            <span class="separator">/</span>
            <span>Password Security Best Practices</span>
        </nav>

        <!-- Header -->
        <header class="article-header">
            <span class="article-category">Security</span>
            <h1 class="article-title" itemprop="headline">Password Security in 2026: Best Practices for Developers</h1>
            <p class="article-subtitle">Passwords are still the primary authentication method for most applications. This guide covers how to hash, salt, validate, and store passwords correctly &mdash; plus when to move beyond passwords entirely with 2FA and passkeys.</p>
            <div class="article-meta">
                <div class="article-meta-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>
                    <span>19 min read</span>
                </div>
                <div class="article-meta-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
                    <time datetime="2026-02-14" itemprop="datePublished">February 14, 2026</time>
                </div>
                <div class="article-meta-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>
                    <span itemprop="author">NexTool Team</span>
                </div>
            </div>
        </header>

        <!-- TOC -->
        <nav class="toc" aria-label="Table of Contents">
            <div class="toc-title">Table of Contents</div>
            <ol class="toc-list">
                <li><a href="#why-password-security">Why Password Security Still Matters</a></li>
                <li><a href="#hashing">Password Hashing: bcrypt, Argon2, scrypt</a></li>
                <li><a href="#salting">Salting: What It Is and How It Works</a></li>
                <li><a href="#implementation">Implementation: Hashing in Code</a></li>
                <li><a href="#password-policies">Password Policies That Actually Work</a></li>
                <li><a href="#breach-checking">Checking Against Known Breaches</a></li>
                <li><a href="#2fa">Two-Factor Authentication (2FA)</a></li>
                <li><a href="#passkeys">Passkeys: The Future of Authentication</a></li>
                <li><a href="#storage">Secure Storage and Transmission</a></li>
                <li><a href="#tools">Security Tools</a></li>
                <li><a href="#faq">Frequently Asked Questions</a></li>
            </ol>
        </nav>

        <!-- Content -->
        <div class="article-content" itemprop="articleBody">

            <h2 id="why-password-security">Why Password Security Still Matters</h2>

            <p>In 2024, the RockYou2024 compilation exposed nearly 10 billion unique plaintext passwords from decades of data breaches. The Snowflake breach chain compromised over 165 organizations because stolen credentials lacked multi-factor authentication. Despite years of industry efforts toward passwordless login, passwords remain the primary authentication method for the vast majority of web applications.</p>

            <p>As a developer, the passwords your users trust you with are a liability. Store them correctly, and a database breach is an inconvenience. Store them wrong, and it becomes front-page news. The difference is entirely in how you handle three things: <strong>hashing</strong>, <strong>validation policies</strong>, and <strong>layered authentication</strong>.</p>

            <p>This guide covers each one with working code examples. You can test password strength and generate secure passwords as you read using NexTool's <a href="/free-tools/password-strength-checker.html">Password Strength Checker</a> and <a href="/free-tools/password-generator.html">Password Generator</a>.</p>

            <h2 id="hashing">Password Hashing: bcrypt, Argon2, scrypt</h2>

            <p>A hash function takes an input of any length and produces a fixed-length output. <strong>Cryptographic hash functions</strong> are one-way: given the output, you cannot compute the input. Password hashing adds a critical requirement: the function must be <strong>intentionally slow</strong>.</p>

            <p>Fast hash functions like MD5 and SHA-256 compute billions of hashes per second on modern GPUs. An attacker with a stolen database can try every common password in minutes. Password-specific hash functions are designed to be slow (hundreds of milliseconds per hash), making brute-force attacks computationally infeasible.</p>

            <h3>Algorithm Comparison</h3>

            <table>
                <thead>
                    <tr>
                        <th>Algorithm</th>
                        <th>Year</th>
                        <th>Memory-Hard</th>
                        <th>GPU Resistant</th>
                        <th>Recommendation</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Argon2id</strong></td>
                        <td>2015</td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td>Best choice for new projects</td>
                    </tr>
                    <tr>
                        <td><strong>bcrypt</strong></td>
                        <td>1999</td>
                        <td>No (4 KB)</td>
                        <td>Moderate</td>
                        <td>Excellent, widely supported</td>
                    </tr>
                    <tr>
                        <td><strong>scrypt</strong></td>
                        <td>2009</td>
                        <td>Yes</td>
                        <td>Yes</td>
                        <td>Good alternative to Argon2</td>
                    </tr>
                    <tr>
                        <td><strong>PBKDF2</strong></td>
                        <td>2000</td>
                        <td>No</td>
                        <td>No</td>
                        <td>Acceptable if nothing else available</td>
                    </tr>
                    <tr>
                        <td>SHA-256</td>
                        <td>2001</td>
                        <td>No</td>
                        <td>No</td>
                        <td>Never use for passwords</td>
                    </tr>
                    <tr>
                        <td>MD5</td>
                        <td>1992</td>
                        <td>No</td>
                        <td>No</td>
                        <td>Never use for passwords</td>
                    </tr>
                </tbody>
            </table>

            <div class="info-box danger">
                <div class="info-box-title">Never Use Fast Hashes for Passwords</div>
                <p>MD5, SHA-1, and SHA-256 were designed to be fast. A single RTX 4090 GPU computes ~8 billion MD5 hashes per second. That means every 8-character password using lowercase letters and digits (2.8 trillion combinations) can be cracked in under 6 minutes. Use bcrypt, Argon2id, or scrypt.</p>
            </div>

            <h3>Argon2id</h3>

            <p>Argon2 won the Password Hashing Competition (PHC) in 2015 and is the OWASP-recommended algorithm. The <code>id</code> variant combines Argon2i (resistant to side-channel attacks) and Argon2d (resistant to GPU attacks). You configure three parameters independently:</p>

            <ul>
                <li><strong>Memory</strong> &mdash; How much RAM the hash requires (e.g., 64 MB). Higher memory makes GPU attacks expensive because GPUs have limited per-core memory.</li>
                <li><strong>Iterations (time cost)</strong> &mdash; How many passes over the memory. More iterations = slower hash.</li>
                <li><strong>Parallelism</strong> &mdash; How many threads to use. Set to the number of cores available on your server for hashing.</li>
            </ul>

            <p>OWASP's recommended minimum for Argon2id: <strong>19 MiB memory, 2 iterations, 1 parallelism</strong>. For higher security: 64 MiB memory, 3 iterations, 4 parallelism. Tune until hashing takes 200-500ms on your hardware.</p>

            <h3>bcrypt</h3>

            <p>bcrypt has been the industry standard since 1999. It uses a single parameter called <strong>cost factor</strong> (also called work factor or rounds), expressed as a power of 2. A cost of 12 means 2^12 = 4,096 iterations. Each increment doubles the computation time.</p>

            <p>In 2026, use a minimum cost factor of <strong>12</strong> (roughly 250ms on modern hardware). If your server can handle it, use 13 or 14. bcrypt has a 72-byte input limit &mdash; passwords longer than 72 bytes are silently truncated. If you need to support longer passwords, pre-hash with SHA-256 before passing to bcrypt.</p>

            <h3>scrypt</h3>

            <p>scrypt was designed specifically to be memory-hard. It takes three parameters: <strong>N</strong> (CPU/memory cost, must be a power of 2), <strong>r</strong> (block size), and <strong>p</strong> (parallelism). Recommended values: N=2^15, r=8, p=1, which uses about 32 MB of memory per hash.</p>

            <h2 id="salting">Salting: What It Is and How It Works</h2>

            <p>A <strong>salt</strong> is a random value unique to each user, combined with their password before hashing. Without salting, two users with the same password produce the same hash &mdash; meaning an attacker who cracks one has cracked both.</p>

            <div class="code-label">pseudocode &mdash; Why Salting Matters</div>
<pre><code>// Without salt: identical passwords produce identical hashes
hash("password123") = "ef92b778..."
hash("password123") = "ef92b778..."  // Same! Attacker cracks one, gets both.

// With unique salts: identical passwords produce different hashes
hash("a1b2c3d4" + "password123") = "7f2e9c3a..."
hash("x9y8z7w6" + "password123") = "1d4e5f6a..."  // Different!</code></pre>

            <p>Salting defeats two attack strategies:</p>

            <ul>
                <li><strong>Rainbow tables</strong> &mdash; Precomputed lookup tables mapping common passwords to hashes. With unique salts, every possible password would need a separate table for every salt, making precomputation infeasible.</li>
                <li><strong>Batch cracking</strong> &mdash; Without salts, an attacker can hash a candidate password once and compare it against every hash in the database. With salts, each hash requires a separate computation.</li>
            </ul>

            <div class="info-box success">
                <div class="info-box-title">bcrypt and Argon2 Handle Salts Automatically</div>
                <p>Both bcrypt and Argon2 generate a cryptographically random salt and embed it in the output hash string. You do not need to generate or store salts separately. Just pass the password in and store the full output string.</p>
            </div>

            <h2 id="implementation">Implementation: Hashing in Code</h2>

            <h3>Node.js: bcrypt</h3>

            <div class="code-label">javascript &mdash; bcrypt with the bcrypt Package</div>
<pre><code>import bcrypt from 'bcrypt';

const SALT_ROUNDS = 12; // 2^12 iterations, ~250ms

// Hash a password (at registration or password change)
async function hashPassword(plaintext) {
  return bcrypt.hash(plaintext, SALT_ROUNDS);
}

// Verify a password (at login)
async function verifyPassword(plaintext, storedHash) {
  return bcrypt.compare(plaintext, storedHash);
}

// Usage
const hash = await hashPassword('my-secure-password');
// "$2b$12$LJ3m4ys3Lk0TSwHjZx.G5e8K7Yf2cVDq9xlmPJ6xUq4aExZnSCXi"

const isValid = await verifyPassword('my-secure-password', hash);
// true</code></pre>

            <h3>Node.js: Argon2</h3>

            <div class="code-label">javascript &mdash; Argon2id with the argon2 Package</div>
<pre><code>import argon2 from 'argon2';

async function hashPassword(plaintext) {
  return argon2.hash(plaintext, {
    type: argon2.argon2id,
    memoryCost: 65536,  // 64 MiB
    timeCost: 3,        // 3 iterations
    parallelism: 4
  });
}

async function verifyPassword(plaintext, storedHash) {
  return argon2.verify(storedHash, plaintext);
}

const hash = await hashPassword('my-secure-password');
// "$argon2id$v=19$m=65536,t=3,p=4$c29tZXNhbHQ$..."

const isValid = await verifyPassword('my-secure-password', hash);
// true</code></pre>

            <h3>Python: bcrypt and Argon2</h3>

            <div class="code-label">python &mdash; bcrypt</div>
<pre><code>import bcrypt

def hash_password(plaintext: str) -> str:
    salt = bcrypt.gensalt(rounds=12)
    hashed = bcrypt.hashpw(plaintext.encode('utf-8'), salt)
    return hashed.decode('utf-8')

def verify_password(plaintext: str, stored_hash: str) -> bool:
    return bcrypt.checkpw(
        plaintext.encode('utf-8'),
        stored_hash.encode('utf-8')
    )</code></pre>

            <div class="code-label">python &mdash; Argon2id</div>
<pre><code>from argon2 import PasswordHasher

ph = PasswordHasher(
    memory_cost=65536,  # 64 MiB
    time_cost=3,
    parallelism=4
)

def hash_password(plaintext: str) -> str:
    return ph.hash(plaintext)

def verify_password(plaintext: str, stored_hash: str) -> bool:
    try:
        return ph.verify(stored_hash, plaintext)
    except Exception:
        return False</code></pre>

            <h3>Go: bcrypt</h3>

            <div class="code-label">go &mdash; bcrypt with golang.org/x/crypto</div>
<pre><code>package main

import (
    "fmt"
    "golang.org/x/crypto/bcrypt"
)

func hashPassword(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword(
        []byte(password),
        12, // cost factor
    )
    return string(bytes), err
}

func verifyPassword(password, hash string) bool {
    err := bcrypt.CompareHashAndPassword(
        []byte(hash),
        []byte(password),
    )
    return err == nil
}

func main() {
    hash, _ := hashPassword("my-secure-password")
    fmt.Println("Hash:", hash)
    fmt.Println("Valid:", verifyPassword("my-secure-password", hash))
}</code></pre>

            <p>To quickly generate hash values for testing, use NexTool's <a href="/free-tools/hash-generator.html">Hash Generator</a> which supports MD5, SHA-1, SHA-256, SHA-512, and more &mdash; all computed client-side without sending your data anywhere.</p>

            <h2 id="password-policies">Password Policies That Actually Work</h2>

            <p>NIST Special Publication 800-63B (Digital Identity Guidelines, updated 2024) fundamentally changed password policy recommendations. Many of the rules developers have enforced for decades are now explicitly discouraged.</p>

            <h3>What NIST Recommends</h3>

            <ul>
                <li><strong>Minimum 8 characters</strong>, but 15+ is strongly encouraged. Length is the single most important factor in password strength.</li>
                <li><strong>Maximum at least 64 characters.</strong> Never set a low maximum. Let users use passphrases.</li>
                <li><strong>Allow all characters.</strong> All printable ASCII, spaces, and Unicode (including emoji). Do not restrict special characters.</li>
                <li><strong>Check against breached password lists.</strong> Reject any password that appears in known breaches (e.g., the HIBP database).</li>
                <li><strong>Check against a blocklist.</strong> Block common passwords ("password", "123456"), context-specific terms (your site's name), and repetitive patterns ("aaaaaa", "abcabc").</li>
            </ul>

            <h3>What NIST Explicitly Discourages</h3>

            <ul>
                <li><strong>Composition rules.</strong> Do not require "at least one uppercase, one lowercase, one digit, one symbol." These rules produce predictable patterns: <code>Password1!</code> satisfies every rule and is in every breach database.</li>
                <li><strong>Periodic password rotation.</strong> Do not force users to change passwords every 30/60/90 days. This leads to incremental changes (<code>Password1</code>, <code>Password2</code>, <code>Password3</code>) that attackers predict trivially.</li>
                <li><strong>Password hints.</strong> Do not store or display password hints. They leak information.</li>
                <li><strong>Security questions.</strong> Do not use them for account recovery. The answers are often publicly available or guessable.</li>
            </ul>

            <div class="info-box">
                <div class="info-box-title">Password Entropy in Practice</div>
                <p>A random 8-character password using all 95 printable ASCII characters has ~52 bits of entropy. A random 4-word passphrase from a 7,776-word list (diceware) has ~51 bits. But the passphrase is far easier to remember. Check the entropy of any password instantly with NexTool's <a href="/free-tools/password-strength-checker.html">Password Strength Checker</a>.</p>
            </div>

            <h2 id="breach-checking">Checking Against Known Breaches</h2>

            <p>The Have I Been Pwned (HIBP) Passwords API lets you check if a password has appeared in any known data breach without ever transmitting the password or its full hash.</p>

            <div class="code-label">javascript &mdash; Check Password Against HIBP (k-Anonymity)</div>
<pre><code>async function isPasswordBreached(password) {
  // 1. SHA-1 hash the password
  const encoder = new TextEncoder();
  const data = encoder.encode(password);
  const hashBuffer = await crypto.subtle.digest('SHA-1', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('').toUpperCase();

  // 2. Send only the first 5 characters
  const prefix = hashHex.slice(0, 5);
  const suffix = hashHex.slice(5);

  // 3. Get all matching hashes from HIBP
  const response = await fetch(`https://api.pwnedpasswords.com/range/${prefix}`);
  const text = await response.text();

  // 4. Check if our full hash suffix appears
  const lines = text.split('\n');
  for (const line of lines) {
    const [hashSuffix, count] = line.split(':');
    if (hashSuffix.trim() === suffix) {
      return { breached: true, count: parseInt(count) };
    }
  }

  return { breached: false, count: 0 };
}

// Usage
const result = await isPasswordBreached('password123');
// { breached: true, count: 247543 }</code></pre>

            <p>Integrate this check at two points: <strong>registration</strong> (block the password) and <strong>password change</strong> (block or warn). Some teams also check at login and prompt users to change compromised passwords, though this requires careful UX to avoid locking users out.</p>

            <h2 id="2fa">Two-Factor Authentication (2FA)</h2>

            <p>A strong password hash protects against database breaches. Two-factor authentication protects against stolen passwords &mdash; phishing, keyloggers, credential stuffing, and social engineering. Every application that handles sensitive data should offer 2FA.</p>

            <h3>TOTP (Time-Based One-Time Password)</h3>

            <p>TOTP is the most widely supported 2FA method. The user scans a QR code with an authenticator app (Google Authenticator, Authy, 1Password). The app generates a 6-digit code that changes every 30 seconds.</p>

            <div class="code-label">javascript &mdash; TOTP Setup with otpauth</div>
<pre><code>import { TOTP } from 'otpauth';
import QRCode from 'qrcode';

// Generate a secret for the user (at 2FA enrollment)
function createTOTPSecret(userEmail) {
  const totp = new TOTP({
    issuer: 'YourApp',
    label: userEmail,
    algorithm: 'SHA1',
    digits: 6,
    period: 30
  });

  return {
    secret: totp.secret.base32,     // Store encrypted in DB
    uri: totp.toString(),           // For QR code
    qrCode: QRCode.toDataURL(totp.toString()) // QR image
  };
}

// Validate a code (at login)
function verifyTOTP(secret, userCode) {
  const totp = new TOTP({
    secret: OTPAuth.Secret.fromBase32(secret),
    algorithm: 'SHA1',
    digits: 6,
    period: 30
  });

  // Allow 1 step of drift (previous + current + next period)
  const delta = totp.validate({ token: userCode, window: 1 });
  return delta !== null; // null means invalid
}</code></pre>

            <h3>Backup Codes</h3>

            <p>Always generate 8-10 single-use backup codes during 2FA enrollment. Store them hashed (bcrypt) in the database. When a user enters a backup code, verify it, then mark it as used. Display them once during setup and instruct the user to store them securely. This is the recovery path when a user loses their authenticator device.</p>

            <h3>WebAuthn / Security Keys</h3>

            <p>WebAuthn (FIDO2) provides the strongest second factor: hardware security keys (YubiKey, Google Titan) or platform authenticators (Touch ID, Windows Hello). WebAuthn is phishing-resistant by design because the browser verifies the origin domain before signing the challenge.</p>

            <div class="info-box warning">
                <div class="info-box-title">Avoid SMS-Based 2FA as the Only Option</div>
                <p>SIM swapping attacks are well-documented and have compromised high-value accounts. Offer TOTP or WebAuthn as the primary 2FA method. SMS is still better than no 2FA at all, but it should not be the only option for security-sensitive applications.</p>
            </div>

            <h2 id="passkeys">Passkeys: The Future of Authentication</h2>

            <p>Passkeys are a passwordless authentication standard built on WebAuthn/FIDO2. Instead of typing a password, users authenticate with their device's biometric sensor, a PIN, or a security key. The private key never leaves the device (or is synced via the platform's encrypted cloud keychain).</p>

            <h3>How Passkeys Work</h3>

            <ol>
                <li><strong>Registration:</strong> The server sends a challenge. The browser creates a public/private key pair. The private key is stored on the device. The public key is sent to the server.</li>
                <li><strong>Authentication:</strong> The server sends a challenge. The browser signs it with the private key (after biometric/PIN verification). The server verifies the signature with the stored public key.</li>
            </ol>

            <h3>Platform Support (February 2026)</h3>

            <ul>
                <li><strong>Apple:</strong> iCloud Keychain syncs passkeys across all Apple devices. Safari, Chrome, Firefox on macOS/iOS.</li>
                <li><strong>Google:</strong> Google Password Manager syncs passkeys across Android devices and Chrome on all platforms.</li>
                <li><strong>Microsoft:</strong> Windows Hello stores passkeys locally. Cross-device sync via Microsoft Account.</li>
                <li><strong>Third-party:</strong> 1Password, Dashlane, and Bitwarden support passkey storage and sync across all platforms.</li>
            </ul>

            <div class="code-label">javascript &mdash; Passkey Registration (SimpleWebAuthn)</div>
<pre><code>import {
  generateRegistrationOptions,
  verifyRegistrationResponse
} from '@simplewebauthn/server';

// Server: Generate registration options
const options = await generateRegistrationOptions({
  rpName: 'Your App',
  rpID: 'yourapp.com',
  userName: user.email,
  attestationType: 'none',
  authenticatorSelection: {
    residentKey: 'preferred',
    userVerification: 'preferred'
  }
});

// Client: navigator.credentials.create(options)
// Server: Verify the response
const verification = await verifyRegistrationResponse({
  response: clientResponse,
  expectedChallenge: options.challenge,
  expectedOrigin: 'https://yourapp.com',
  expectedRPID: 'yourapp.com'
});

if (verification.verified) {
  // Store verification.registrationInfo in your database
}</code></pre>

            <p>Generate secure test passwords while implementing these features with NexTool's <a href="/free-tools/password-generator.html">Password Generator</a>, which creates cryptographically random passwords of any length and character set.</p>

            <h2 id="storage">Secure Storage and Transmission</h2>

            <h3>In Transit</h3>

            <ul>
                <li><strong>Always use HTTPS.</strong> Passwords must never travel over unencrypted HTTP. Use HSTS headers to enforce HTTPS.</li>
                <li><strong>Hash on the server, not the client.</strong> Client-side hashing does not replace server-side hashing. If you hash on the client, the hash becomes the password &mdash; an attacker who steals the hash can replay it.</li>
                <li><strong>Rate-limit login attempts.</strong> After 5-10 failed attempts, enforce a delay (exponential backoff) or temporary lockout. This blocks brute-force attacks against live endpoints.</li>
            </ul>

            <h3>At Rest</h3>

            <ul>
                <li><strong>Store only the hash.</strong> Never store plaintext passwords, encrypted passwords (encryption is reversible), or unsalted hashes.</li>
                <li><strong>Encrypt the hash column.</strong> Defense in depth: even the hashes should be encrypted at the database level (AES-256). If the DB file is stolen but the encryption key is not, the hashes are unusable.</li>
                <li><strong>Isolate the auth database.</strong> Separate the authentication database from the application database. Apply stricter access controls, monitoring, and backups.</li>
                <li><strong>Log authentication events, not credentials.</strong> Log login attempts (success/failure, IP, timestamp) but never log the password or hash.</li>
            </ul>

            <div class="cta-box">
                <h3>Test Your Password Strength</h3>
                <p>NexTool's Password Strength Checker estimates crack time, calculates entropy, and checks against breach databases. Entirely client-side &mdash; your password never leaves your browser.</p>
                <a href="/free-tools/password-strength-checker.html" class="cta-button">Check Password Strength</a>
                <a href="/free-tools/password-generator.html" class="cta-button secondary">Generate Passwords</a>
            </div>

            <h2 id="tools">Security Tools</h2>

            <div class="tool-grid">
                <a href="/free-tools/password-generator.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F511;</div>
                    <div class="tool-card-name">Password Generator</div>
                    <div class="tool-card-desc">Generate cryptographically random passwords with custom length, character sets, and entropy display.</div>
                </a>
                <a href="/free-tools/password-strength-checker.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F6E1;</div>
                    <div class="tool-card-name">Password Strength Checker</div>
                    <div class="tool-card-desc">Estimate crack time, calculate entropy, and check against breach databases. 100% client-side.</div>
                </a>
                <a href="/free-tools/hash-generator.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F523;</div>
                    <div class="tool-card-name">Hash Generator</div>
                    <div class="tool-card-desc">Generate MD5, SHA-1, SHA-256, SHA-512, and other hash values. Runs entirely in your browser.</div>
                </a>
                <a href="/free-tools/jwt-decoder.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F50F;</div>
                    <div class="tool-card-name">JWT Decoder</div>
                    <div class="tool-card-desc">Decode and inspect JWT tokens. Verify signatures and check expiration dates.</div>
                </a>
                <a href="/free-tools/encode-decode-multi.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F504;</div>
                    <div class="tool-card-name">Encoder / Decoder</div>
                    <div class="tool-card-desc">Encode and decode Base64, URL encoding, HTML entities, and more. Essential for security testing.</div>
                </a>
                <a href="/free-tools/uuid-generator.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F194;</div>
                    <div class="tool-card-name">UUID Generator</div>
                    <div class="tool-card-desc">Generate UUIDs v4 (random) and v7 (time-sorted). Useful for session tokens and user identifiers.</div>
                </a>
            </div>

            <hr>

            <div class="faq-section" id="faq">
                <h2>Frequently Asked Questions</h2>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>Should I use bcrypt or Argon2 for password hashing in 2026?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Argon2id is the recommended choice for new projects in 2026. It won the Password Hashing Competition in 2015 and has been the OWASP recommendation since 2023. Argon2id is memory-hard, making it resistant to both GPU and ASIC attacks, and it lets you configure memory usage, parallelism, and iteration count independently. However, bcrypt remains a solid choice if your platform does not have a well-tested Argon2 library. bcrypt has been battle-tested for over 25 years and is supported everywhere. The most important thing is to use any of the recommended algorithms (Argon2id, bcrypt, or scrypt) rather than MD5, SHA-1, SHA-256, or any unsalted/fast hash.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>What is password salting and why is it important?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>A salt is a random string that is appended or prepended to a password before hashing. Each user gets a unique salt, which is stored alongside the hash in the database. Salting prevents two users with the same password from having the same hash (defeating rainbow table attacks), and it makes precomputed hash tables useless. Without salting, an attacker who obtains your database can look up common password hashes in a rainbow table and crack millions of passwords instantly. With unique salts, each password must be attacked individually. Modern hashing functions like bcrypt and Argon2 generate and embed the salt automatically, so you do not need to manage salts manually.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>What password length and complexity rules should I enforce?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>NIST SP 800-63B recommends: minimum 8 characters (15+ is better), maximum at least 64 characters, allow all printable ASCII characters plus Unicode, check against a list of known breached passwords (like the Have I Been Pwned database), do NOT require specific character classes (uppercase, lowercase, digit, symbol), and do NOT force periodic password changes. The reasoning is that complexity rules lead users to create predictable patterns like "Password1!" while a long passphrase like "correct horse battery staple" is both stronger and easier to remember.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>How do I implement two-factor authentication (2FA) correctly?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Implement TOTP (Time-based One-Time Password) as the baseline 2FA method. Use a library that generates a shared secret, creates a QR code for authenticator apps, and validates 6-digit codes with a time window of plus or minus one step (30 seconds). Store the shared secret encrypted in your database. Always provide backup codes (8-10 single-use codes) during setup. For higher security, support WebAuthn/FIDO2 security keys. Avoid SMS-based 2FA as the primary option because SIM swapping attacks are well-documented, though SMS is still better than no 2FA at all.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>What are passkeys and should I support them?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Passkeys are a passwordless authentication standard built on WebAuthn/FIDO2. Instead of a password, users authenticate with their device's biometric sensor (fingerprint, face), a PIN, or a security key. The cryptographic key pair is stored on the user's device (or synced via their platform's cloud keychain), and only the public key is stored on the server. Passkeys are phishing-resistant by design because the browser verifies the domain. As of 2026, passkeys are supported by Apple, Google, Microsoft, and all major browsers. You should support passkeys alongside traditional passwords.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>How do I check if a password has been exposed in a data breach?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Use the Have I Been Pwned (HIBP) Passwords API with k-anonymity. Hash the password with SHA-1, send only the first 5 characters of the hash to the API, and receive a list of matching hash suffixes. Check if the full hash appears in the response. This approach never sends the actual password or the full hash to any external service. The API is free and returns the number of times each password has appeared in known breaches. Block any password that has appeared in more than 0 breaches, or at minimum warn the user and require confirmation.</p>
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <!-- Author -->
        <div class="author-box">
            <div class="author-avatar">NT</div>
            <div class="author-info">
                <h4>NexTool Team</h4>
                <p>We build free developer tools including password generators, hash tools, and security utilities. Over 150 tools, all browser-based, no signup required.</p>
            </div>
        </div>

        <!-- Bottom CTA -->
        <div class="cta-box">
            <h3>150+ Developer Tools, One Place</h3>
            <p>NexTool Pro ($29) unlocks clean output, enhanced features, and unlimited workspace. One payment, lifetime access.</p>
            <a href="https://nextool.app/free-tools/pro-upgrade.html" class="cta-button">Get NexTool Pro &mdash; $29</a>
            <a href="/free-tools/" class="cta-button secondary">Try Free Tools</a>
        </div>

    </article>

    <!-- Footer -->
    <footer class="footer">
        <div class="footer-inner">
            <div class="footer-links">
                <a href="https://nextool.app">Home</a>
                <a href="https://nextool.app/#services">Tools</a>
                <a href="https://nextool.app/free-tools/">Free Tools</a>
                <a href="https://nextool.app/blog/">Blog</a>
                <a href="https://nextool.app/#contact">Contact</a>
            </div>
            <p>&copy; 2026 NexTool. All rights reserved. 227+ free developer tools.</p>
        </div>
    </footer>

    <!-- FAQ Script -->
    <script>
        function toggleFAQ(button) {
            const item = button.parentElement;
            const answer = item.querySelector('.faq-answer');
            const isOpen = item.classList.contains('open');

            document.querySelectorAll('.faq-item').forEach(faq => {
                faq.classList.remove('open');
                faq.querySelector('.faq-answer').style.maxHeight = null;
            });

            if (!isOpen) {
                item.classList.add('open');
                answer.style.maxHeight = answer.scrollHeight + 'px';
            }
        }
    </script>

    <!-- Revenue Scripts -->
    <script defer src="/js/analytics-lite.js"></script>
    <script defer src="/js/revenue.js"></script>
    <script defer src="/js/lead-capture.js"></script>
</body>
</html>