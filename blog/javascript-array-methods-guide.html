<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/svg+xml" href="/img/favicon.svg">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Array Methods: map, filter, reduce, forEach and 15 More Explained (2026) | NexTool</title>
    <meta name="description" content="Complete guide to JavaScript array methods. map, filter, reduce, forEach, find, some, every, flat, includes, sort, and more. Each method explained with examples, performance tips, and chaining patterns.">
    <meta name="keywords" content="javascript array methods, js array methods, map filter reduce, array map, array filter, array reduce, foreach javascript, javascript sort array, array find, array includes, es6 array methods">
    <meta name="author" content="NexTool">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://nextool.app/blog/javascript-array-methods-guide.html">

    <meta property="og:type" content="article">
    <meta property="og:title" content="JavaScript Array Methods: map, filter, reduce, forEach and 15 More Explained">
    <meta property="og:description" content="Every JavaScript array method explained with clear examples. map, filter, reduce, forEach, find, some, every, flat, sort, and advanced chaining patterns.">
    <meta property="og:url" content="https://nextool.app/blog/javascript-array-methods-guide.html">
    <meta property="og:site_name" content="NexTool">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="JavaScript Array Methods: map, filter, reduce and 15 More Explained">
    <meta name="twitter:description" content="Every JS array method with examples. map, filter, reduce, forEach, find, some, every, flat, sort, and chaining patterns.">

    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Article",
        "headline": "JavaScript Array Methods: map, filter, reduce, forEach and 15 More Explained (2026)",
        "description": "Complete guide to JavaScript array methods with examples, performance tips, and chaining patterns.",
        "author": { "@type": "Organization", "name": "NexTool", "url": "https://nextool.app" },
        "publisher": { "@type": "Organization", "name": "NexTool", "logo": { "@type": "ImageObject", "url": "https://nextool.app/assets/images/logo.png" } },
        "datePublished": "2026-02-21T10:00:00Z",
        "dateModified": "2026-02-21T10:00:00Z",
        "mainEntityOfPage": { "@type": "WebPage", "@id": "https://nextool.app/blog/javascript-array-methods-guide.html" },
        "wordCount": 1800,
        "keywords": ["javascript array methods", "map filter reduce", "array methods", "es6 array", "forEach", "find", "sort"]
    }
    </script>

    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BreadcrumbList",
        "itemListElement": [
            { "@type": "ListItem", "position": 1, "name": "Home", "item": "https://nextool.app" },
            { "@type": "ListItem", "position": 2, "name": "Blog", "item": "https://nextool.app/blog/" },
            { "@type": "ListItem", "position": 3, "name": "JavaScript Array Methods Guide", "item": "https://nextool.app/blog/javascript-array-methods-guide.html" }
        ]
    }
    </script>

    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "FAQPage",
        "mainEntity": [
            {
                "@type": "Question",
                "name": "What is the difference between map and forEach in JavaScript?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "map() creates and returns a new array with the results of calling a function on every element. forEach() executes a function on every element but returns undefined. Use map() when you need to transform data and use the resulting array. Use forEach() when you want to perform side effects like logging, updating the DOM, or making API calls for each element. Because map() returns a new array, you can chain it with other array methods like filter() and reduce(). forEach() cannot be chained since it returns undefined."
                }
            },
            {
                "@type": "Question",
                "name": "How does reduce work in JavaScript?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "reduce() iterates over an array and accumulates a single result value. It takes two arguments: a callback function and an optional initial value. The callback receives four parameters: the accumulator (the running total or accumulated result), the current element, the current index, and the original array. On each iteration, the callback's return value becomes the new accumulator for the next iteration. Always provide an initial value to avoid unexpected behavior with empty arrays. Common uses include summing numbers (reduce((sum, n) => sum + n, 0)), flattening arrays, counting occurrences, and grouping objects by a property."
                }
            },
            {
                "@type": "Question",
                "name": "Does sort mutate the original array in JavaScript?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Yes, Array.sort() mutates the original array in place and also returns the sorted array. This is a common source of bugs. If you need to sort without modifying the original, create a copy first using the spread operator ([...arr].sort()), Array.from(arr).sort(), or arr.slice().sort(). As of ES2023, you can use the new toSorted() method which returns a sorted copy without mutating the original. Also note that sort() without a compare function converts elements to strings and sorts them lexicographically, which means [10, 9, 80].sort() produces [10, 80, 9]. Always pass a compare function for numbers: arr.sort((a, b) => a - b)."
                }
            },
            {
                "@type": "Question",
                "name": "What is the difference between find and filter in JavaScript?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "find() returns the first element that matches a condition, or undefined if no match is found. It stops searching as soon as it finds a match. filter() returns a new array containing all elements that match a condition, or an empty array if nothing matches. Use find() when you expect one result and want to stop early, like looking up a user by ID. Use filter() when you want all matching results, like getting all users in a specific city. find() is more efficient when you only need one result because it does not process the remaining elements after finding a match."
                }
            },
            {
                "@type": "Question",
                "name": "What are the new array methods in ES2023 and ES2024?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "ES2023 introduced non-mutating versions of existing methods: toSorted() (like sort() but returns a new array), toReversed() (like reverse() but non-mutating), toSpliced() (like splice() but non-mutating), and with(index, value) which returns a new array with one element replaced. These are supported in all modern browsers. ES2024 added Object.groupBy(array, callback) which groups array elements by a key returned by the callback function, replacing the common reduce-based grouping pattern. It returns a null-prototype object with arrays as values."
                }
            }
        ]
    }
    </script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <style>
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #030303; --surface: #0a0a0a; --surface-2: #161616; --surface-3: #222222;
            --primary: #7c3aed; --primary-hover: #6d28d9; --accent: #a78bfa; --accent-hover: #c4b5fd;
            --text: #e8e8e8; --text-secondary: #a0a0a0; --text-muted: #666666; --border: #1e1e1e;
            --success: #22c55e; --warning: #f59e0b; --error: #ef4444; --code-bg: #0d0d0d;
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --font-mono: 'JetBrains Mono', 'Fira Code', monospace;
            --max-width: 800px; --header-height: 64px;
        }
        html { scroll-behavior: smooth; -webkit-text-size-adjust: 100%; }
        body { font-family: var(--font-sans); background: var(--bg); color: var(--text); line-height: 1.75; font-size: 16px; -webkit-font-smoothing: antialiased; overflow-x: hidden; }
        ::-webkit-scrollbar { width: 8px; } ::-webkit-scrollbar-track { background: var(--bg); } ::-webkit-scrollbar-thumb { background: var(--surface-3); border-radius: 4px; }
        .nav { position: fixed; top: 0; left: 0; right: 0; height: var(--header-height); background: rgba(3,3,3,0.85); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-bottom: 1px solid var(--border); z-index: 1000; display: flex; align-items: center; justify-content: center; }
        .nav-inner { width: 100%; max-width: 1200px; padding: 0 24px; display: flex; align-items: center; justify-content: space-between; }
        .nav-logo { display: flex; align-items: center; gap: 10px; text-decoration: none; color: var(--text); font-weight: 700; font-size: 1.25rem; }
        .nav-logo-icon { width: 32px; height: 32px; background: linear-gradient(135deg, var(--primary), var(--accent)); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 0.875rem; font-weight: 800; color: #fff; }
        .nav-links { display: flex; align-items: center; gap: 28px; list-style: none; }
        .nav-links a { color: var(--text-secondary); text-decoration: none; font-size: 0.9rem; font-weight: 500; transition: color 0.2s; }
        .nav-links a:hover { color: var(--text); }
        .nav-cta { background: var(--primary); color: #fff !important; padding: 8px 20px; border-radius: 8px; font-weight: 600; }
        .article-wrapper { max-width: var(--max-width); margin: 0 auto; padding: calc(var(--header-height) + 48px) 24px 80px; }
        .breadcrumb { display: flex; align-items: center; gap: 8px; margin-bottom: 32px; font-size: 0.85rem; color: var(--text-muted); flex-wrap: wrap; }
        .breadcrumb a { color: var(--text-secondary); text-decoration: none; } .breadcrumb a:hover { color: var(--primary); }
        .article-header { margin-bottom: 48px; padding-bottom: 32px; border-bottom: 1px solid var(--border); }
        .article-category { display: inline-block; background: rgba(124,58,237,0.12); color: var(--accent); padding: 4px 14px; border-radius: 20px; font-size: 0.8rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 16px; }
        .article-title { font-size: clamp(2rem, 5vw, 3rem); font-weight: 800; line-height: 1.15; color: var(--text); margin-bottom: 16px; letter-spacing: -0.03em; }
        .article-subtitle { font-size: 1.2rem; color: var(--text-secondary); line-height: 1.6; margin-bottom: 24px; }
        .article-meta { display: flex; align-items: center; gap: 20px; color: var(--text-muted); font-size: 0.875rem; flex-wrap: wrap; }
        .article-meta-item { display: flex; align-items: center; gap: 6px; }
        .article-meta-item svg { width: 16px; height: 16px; opacity: 0.7; }
        .toc { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 24px 28px; margin-bottom: 48px; }
        .toc-title { font-size: 0.85rem; font-weight: 700; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 16px; }
        .toc-list { list-style: none; counter-reset: toc; }
        .toc-list li { counter-increment: toc; margin-bottom: 8px; }
        .toc-list li a { color: var(--text-secondary); text-decoration: none; font-size: 0.925rem; display: flex; align-items: baseline; gap: 10px; padding: 4px 0; }
        .toc-list li a::before { content: counter(toc, decimal-leading-zero); color: var(--text-muted); font-size: 0.8rem; font-family: var(--font-mono); min-width: 20px; }
        .toc-list li a:hover { color: var(--primary); padding-left: 4px; }
        .article-content h2 { font-size: 1.75rem; font-weight: 700; color: var(--text); margin-top: 56px; margin-bottom: 20px; letter-spacing: -0.02em; line-height: 1.3; padding-top: 16px; border-top: 1px solid var(--border); }
        .article-content h2:first-child { margin-top: 0; padding-top: 0; border-top: none; }
        .article-content h3 { font-size: 1.3rem; font-weight: 600; color: var(--text); margin-top: 36px; margin-bottom: 14px; }
        .article-content p { margin-bottom: 20px; color: var(--text-secondary); line-height: 1.8; }
        .article-content a { color: var(--primary); text-decoration: none; border-bottom: 1px solid transparent; } .article-content a:hover { border-bottom-color: var(--primary); }
        .article-content strong { color: var(--text); font-weight: 600; }
        .article-content ul, .article-content ol { margin-bottom: 20px; padding-left: 24px; color: var(--text-secondary); }
        .article-content li { margin-bottom: 10px; line-height: 1.7; } .article-content li::marker { color: var(--primary); }
        .article-content hr { border: none; border-top: 1px solid var(--border); margin: 48px 0; }
        .article-content pre { background: var(--code-bg); border: 1px solid var(--border); border-radius: 12px; padding: 20px 24px; overflow-x: auto; margin: 24px 0; }
        .article-content pre code { font-family: var(--font-mono); font-size: 0.875rem; line-height: 1.65; color: var(--text); background: none; padding: 0; }
        .article-content code { font-family: var(--font-mono); font-size: 0.85em; background: var(--surface); color: var(--accent); padding: 2px 8px; border-radius: 5px; }
        .code-label { display: inline-block; background: var(--surface-2); color: var(--text-muted); font-family: var(--font-mono); font-size: 0.75rem; padding: 2px 10px; border-radius: 6px 6px 0 0; margin-bottom: -1px; position: relative; top: 1px; }
        .info-box { background: rgba(124,58,237,0.08); border: 1px solid rgba(124,58,237,0.2); border-radius: 12px; padding: 20px 24px; margin: 28px 0; }
        .info-box.warning { background: rgba(245,158,11,0.08); border-color: rgba(245,158,11,0.2); }
        .info-box.success { background: rgba(34,197,94,0.08); border-color: rgba(34,197,94,0.2); }
        .info-box-title { font-weight: 700; margin-bottom: 8px; font-size: 0.9rem; }
        .info-box p { color: var(--text-secondary); font-size: 0.925rem; margin-bottom: 0; }
        .tool-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 16px; margin: 28px 0; }
        .tool-card { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 20px; text-decoration: none; color: var(--text); transition: border-color 0.2s, transform 0.2s; display: flex; flex-direction: column; gap: 8px; }
        .tool-card:hover { border-color: var(--primary); transform: translateY(-2px); box-shadow: 0 8px 24px rgba(124,58,237,0.1); }
        .tool-card-icon { font-size: 1.5rem; margin-bottom: 4px; } .tool-card-name { font-weight: 600; font-size: 0.95rem; } .tool-card-desc { font-size: 0.825rem; color: var(--text-muted); line-height: 1.5; }
        .cta-box { background: linear-gradient(135deg, rgba(124,58,237,0.1), rgba(167,139,250,0.1)); border: 1px solid rgba(124,58,237,0.25); border-radius: 16px; padding: 40px 32px; text-align: center; margin: 48px 0; }
        .cta-box h3 { font-size: 1.5rem; font-weight: 700; margin-bottom: 12px; color: var(--text); }
        .cta-box p { color: var(--text-secondary); margin-bottom: 24px; max-width: 500px; margin-left: auto; margin-right: auto; }
        .cta-button { display: inline-flex; align-items: center; gap: 8px; background: var(--primary); color: #fff; padding: 14px 32px; border-radius: 10px; text-decoration: none; font-weight: 600; font-size: 1rem; transition: background 0.2s, transform 0.2s; }
        .cta-button:hover { background: var(--primary-hover); transform: translateY(-2px); box-shadow: 0 8px 32px rgba(124,58,237,0.3); }
        .cta-button.secondary { background: transparent; border: 1px solid var(--primary); color: var(--primary); margin-left: 12px; }
        .cta-button.secondary:hover { background: rgba(124,58,237,0.1); }
        .faq-section { margin-top: 56px; padding-top: 32px; border-top: 1px solid var(--border); }
        .faq-section h2 { margin-top: 0 !important; padding-top: 0 !important; border-top: none !important; }
        .faq-item { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; margin-bottom: 12px; overflow: hidden; }
        .faq-question { width: 100%; background: none; border: none; color: var(--text); padding: 20px 24px; font-size: 1rem; font-weight: 600; text-align: left; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-family: var(--font-sans); transition: background 0.2s; }
        .faq-question:hover { background: var(--surface-2); }
        .faq-question .icon { transition: transform 0.3s; font-size: 1.25rem; color: var(--text-muted); flex-shrink: 0; margin-left: 16px; }
        .faq-item.open .faq-question .icon { transform: rotate(45deg); }
        .faq-answer { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; }
        .faq-answer-inner { padding: 0 24px 20px; color: var(--text-secondary); line-height: 1.7; }
        .author-box { display: flex; align-items: center; gap: 20px; background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 24px; margin: 48px 0; }
        .author-avatar { width: 64px; height: 64px; background: linear-gradient(135deg, var(--primary), var(--accent)); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; font-weight: 700; color: #fff; flex-shrink: 0; }
        .author-info h4 { font-weight: 600; margin-bottom: 4px; } .author-info p { color: var(--text-muted); font-size: 0.875rem; margin: 0; line-height: 1.5; }
        .footer { border-top: 1px solid var(--border); padding: 48px 24px; text-align: center; color: var(--text-muted); font-size: 0.85rem; }
        .footer-inner { max-width: 1200px; margin: 0 auto; }
        .footer-links { display: flex; justify-content: center; gap: 24px; margin-bottom: 20px; flex-wrap: wrap; }
        .footer-links a { color: var(--text-secondary); text-decoration: none; } .footer-links a:hover { color: var(--primary); }
        @media (max-width: 768px) {
            .nav-links { display: none; } .article-wrapper { padding: calc(var(--header-height) + 24px) 16px 60px; }
            .article-title { font-size: 1.75rem; } .tool-grid { grid-template-columns: 1fr; }
            .cta-box { padding: 28px 20px; } .cta-button.secondary { margin-left: 0; margin-top: 12px; }
            .author-box { flex-direction: column; text-align: center; }
            .article-content pre { padding: 16px; border-radius: 8px; } .article-content h2 { font-size: 1.4rem; }
        }
        @media (max-width: 480px) { .article-title { font-size: 1.5rem; } .toc { padding: 18px 20px; } }
    </style>
</head>
<body>

    <nav class="nav">
        <div class="nav-inner">
            <a href="https://nextool.app" class="nav-logo"><div class="nav-logo-icon">N</div> NexTool</a>
            <ul class="nav-links">
                <li><a href="/">Home</a></li>
                <li><a href="/free-tools/">Free Tools</a></li>
                <li><a href="/blog/">Blog</a></li>
                <li><a href="/free-tools/" class="nav-cta">Browse Tools</a></li>
            </ul>
        </div>
    </nav>

    <article class="article-wrapper" itemscope itemtype="https://schema.org/Article">
        <nav class="breadcrumb" aria-label="Breadcrumb">
            <a href="/">Home</a><span>/</span><a href="/blog/">Blog</a><span>/</span><span>JavaScript Array Methods</span>
        </nav>

        <header class="article-header">
            <span class="article-category">JavaScript</span>
            <h1 class="article-title" itemprop="headline">JavaScript Array Methods: map, filter, reduce, forEach and 15 More Explained</h1>
            <p class="article-subtitle">A practical reference for every JavaScript array method you will actually use. Each method explained with clear examples, return values, mutation behavior, and the chaining patterns that make your code cleaner.</p>
            <div class="article-meta">
                <div class="article-meta-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>
                    <span>19 min read</span>
                </div>
                <div class="article-meta-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
                    <span>Feb 21, 2026</span>
                </div>
            </div>
        </header>

        <div class="toc">
            <div class="toc-title">Table of Contents</div>
            <ol class="toc-list">
                <li><a href="#transform">Transforming: map</a></li>
                <li><a href="#filter">Filtering: filter</a></li>
                <li><a href="#reduce">Accumulating: reduce</a></li>
                <li><a href="#iterate">Iterating: forEach</a></li>
                <li><a href="#search">Searching: find, findIndex, indexOf, includes</a></li>
                <li><a href="#test">Testing: some, every</a></li>
                <li><a href="#sort">Sorting: sort, toSorted, reverse, toReversed</a></li>
                <li><a href="#modify">Adding and Removing: push, pop, shift, unshift, splice</a></li>
                <li><a href="#combine">Combining: concat, flat, flatMap, spread</a></li>
                <li><a href="#create">Creating: from, of, Array constructor, fill</a></li>
                <li><a href="#es2023">ES2023+ New Methods</a></li>
                <li><a href="#chaining">Method Chaining Patterns</a></li>
                <li><a href="#performance">Performance Considerations</a></li>
                <li><a href="#tools">Related Free Tools</a></li>
                <li><a href="#faq">Frequently Asked Questions</a></li>
            </ol>
        </div>

        <div class="article-content" itemprop="articleBody">

            <h2 id="transform">Transforming: map</h2>

            <p><code>map()</code> creates a new array by calling a function on every element. It does not mutate the original array. The returned array always has the same length as the original.</p>

            <div class="code-label">javascript &mdash; map examples</div>
<pre><code>const numbers = [1, 2, 3, 4, 5];

// Double each number
const doubled = numbers.map(n => n * 2);
// [2, 4, 6, 8, 10]

// Extract a property from objects
const users = [
  { name: "Alice", age: 30 },
  { name: "Bob", age: 25 },
  { name: "Charlie", age: 35 }
];
const names = users.map(user => user.name);
// ["Alice", "Bob", "Charlie"]

// Transform with index
const indexed = ["a", "b", "c"].map((letter, i) => `${i}: ${letter}`);
// ["0: a", "1: b", "2: c"]

// Parse strings to numbers
const strings = ["1", "2", "3"];
const nums = strings.map(Number);
// [1, 2, 3]</code></pre>

            <p>When working with complex transformations, you can format and minify your JavaScript with the <a href="/free-tools/javascript-minifier.html">JavaScript Minifier</a> for production-ready output.</p>

            <h2 id="filter">Filtering: filter</h2>

            <p><code>filter()</code> creates a new array containing only elements that pass a test. The callback must return <code>true</code> to keep the element or <code>false</code> to exclude it.</p>

            <div class="code-label">javascript &mdash; filter examples</div>
<pre><code>const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Even numbers only
const evens = numbers.filter(n => n % 2 === 0);
// [2, 4, 6, 8, 10]

// Filter objects by property
const users = [
  { name: "Alice", active: true },
  { name: "Bob", active: false },
  { name: "Charlie", active: true }
];
const activeUsers = users.filter(u => u.active);
// [{ name: "Alice", active: true }, { name: "Charlie", active: true }]

// Remove falsy values (null, undefined, 0, "", false)
const messy = [0, 1, null, "hello", undefined, "", false, 42];
const clean = messy.filter(Boolean);
// [1, "hello", 42]

// Remove duplicates (simple values)
const dupes = [1, 2, 2, 3, 3, 3, 4];
const unique = dupes.filter((val, i, arr) => arr.indexOf(val) === i);
// [1, 2, 3, 4]
// Better: [...new Set(dupes)]</code></pre>

            <h2 id="reduce">Accumulating: reduce</h2>

            <p><code>reduce()</code> processes every element and accumulates a single result. It is the most powerful and flexible array method, capable of implementing map, filter, and nearly any other array operation.</p>

            <div class="code-label">javascript &mdash; reduce examples</div>
<pre><code>const numbers = [1, 2, 3, 4, 5];

// Sum all numbers
const sum = numbers.reduce((acc, n) => acc + n, 0);
// 15

// Find maximum value
const max = numbers.reduce((a, b) => a > b ? a : b);
// 5

// Count occurrences
const fruits = ["apple", "banana", "apple", "cherry", "banana", "apple"];
const counts = fruits.reduce((acc, fruit) => {
  acc[fruit] = (acc[fruit] || 0) + 1;
  return acc;
}, {});
// { apple: 3, banana: 2, cherry: 1 }

// Group by property
const people = [
  { name: "Alice", dept: "Engineering" },
  { name: "Bob", dept: "Marketing" },
  { name: "Charlie", dept: "Engineering" }
];
const byDept = people.reduce((acc, person) => {
  const key = person.dept;
  (acc[key] = acc[key] || []).push(person);
  return acc;
}, {});

// Flatten nested arrays
const nested = [[1, 2], [3, 4], [5, 6]];
const flat = nested.reduce((acc, arr) => acc.concat(arr), []);
// [1, 2, 3, 4, 5, 6]
// Better: nested.flat()</code></pre>

            <div class="info-box warning">
                <div class="info-box-title">Always Provide an Initial Value</div>
                <p>Calling <code>reduce()</code> on an empty array without an initial value throws a TypeError. Always pass an initial value as the second argument: <code>arr.reduce(fn, initialValue)</code>. This also makes the code more readable because the return type is obvious from the initial value.</p>
            </div>

            <h2 id="iterate">Iterating: forEach</h2>

            <p><code>forEach()</code> executes a function on every element but returns <code>undefined</code>. Use it for side effects, not for creating new arrays.</p>

            <div class="code-label">javascript &mdash; forEach examples</div>
<pre><code>const items = ["apple", "banana", "cherry"];

// Log each item
items.forEach(item => console.log(item));

// Update DOM elements
document.querySelectorAll(".card").forEach(card => {
  card.classList.add("visible");
});

// forEach with index
items.forEach((item, index) => {
  console.log(`${index + 1}. ${item}`);
});</code></pre>

            <div class="info-box">
                <div class="info-box-title">forEach vs. map</div>
                <p>Use <code>map()</code> when you need the returned array. Use <code>forEach()</code> when you are performing side effects (logging, DOM updates, API calls). Never use <code>map()</code> and ignore the result &mdash; that creates an unnecessary array in memory.</p>
            </div>

            <h2 id="search">Searching: find, findIndex, indexOf, includes</h2>

            <div class="code-label">javascript &mdash; Search methods</div>
<pre><code>const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
  { id: 3, name: "Charlie" }
];

// find: returns first matching element (or undefined)
const bob = users.find(u => u.name === "Bob");
// { id: 2, name: "Bob" }

// findIndex: returns index of first match (or -1)
const bobIndex = users.findIndex(u => u.name === "Bob");
// 1

// findLast / findLastIndex (ES2023): search from the end
const numbers = [1, 2, 3, 2, 1];
const lastTwo = numbers.findLast(n => n === 2);    // 2 (at index 3)
const lastTwoIdx = numbers.findLastIndex(n => n === 2); // 3

// indexOf: find index of a primitive value
const colors = ["red", "green", "blue"];
colors.indexOf("green");  // 1
colors.indexOf("purple"); // -1

// includes: check if a value exists (returns boolean)
colors.includes("blue");   // true
colors.includes("yellow"); // false</code></pre>

            <h2 id="test">Testing: some, every</h2>

            <div class="code-label">javascript &mdash; Testing methods</div>
<pre><code>const numbers = [2, 4, 6, 8, 10];

// every: do ALL elements pass the test?
const allEven = numbers.every(n => n % 2 === 0); // true

// some: does ANY element pass the test?
const hasLarge = numbers.some(n => n > 7); // true

// Practical: check if form is valid
const fields = [
  { name: "email", valid: true },
  { name: "password", valid: false }
];
const formValid = fields.every(f => f.valid); // false

// Practical: check if any task is overdue
const tasks = [
  { title: "Deploy", due: "2026-02-20" },
  { title: "Test", due: "2026-03-01" }
];
const hasOverdue = tasks.some(t => new Date(t.due) < new Date());</code></pre>

            <h2 id="sort">Sorting: sort, toSorted, reverse, toReversed</h2>

            <div class="code-label">javascript &mdash; Sorting methods</div>
<pre><code>// CAUTION: sort() MUTATES the original array
const nums = [10, 1, 21, 2];
nums.sort(); // [1, 10, 2, 21] -- lexicographic, NOT numeric!

// Numeric sort (ascending)
[10, 1, 21, 2].sort((a, b) => a - b); // [1, 2, 10, 21]

// Numeric sort (descending)
[10, 1, 21, 2].sort((a, b) => b - a); // [21, 10, 2, 1]

// Sort objects by property
const users = [
  { name: "Charlie", age: 35 },
  { name: "Alice", age: 30 },
  { name: "Bob", age: 25 }
];
users.sort((a, b) => a.age - b.age);

// Sort strings (locale-aware)
["charlie", "Alice", "bob"].sort((a, b) => a.localeCompare(b));

// NON-MUTATING alternatives (ES2023)
const original = [3, 1, 2];
const sortedCopy = original.toSorted((a, b) => a - b);
// original: [3, 1, 2] (unchanged)
// sortedCopy: [1, 2, 3]

const reversed = original.toReversed();
// original: [3, 1, 2] (unchanged)
// reversed: [2, 1, 3]</code></pre>

            <h2 id="modify">Adding and Removing: push, pop, shift, unshift, splice</h2>

            <p>These methods mutate the original array. For non-mutating alternatives, use spread syntax or <code>toSpliced()</code>.</p>

            <div class="code-label">javascript &mdash; Mutation methods</div>
<pre><code>const arr = [1, 2, 3];

arr.push(4);         // Add to end. arr = [1, 2, 3, 4]
arr.pop();           // Remove from end. Returns 4
arr.unshift(0);      // Add to beginning. arr = [0, 1, 2, 3]
arr.shift();         // Remove from beginning. Returns 0

// splice: remove/insert at any position
arr.splice(1, 1);          // Remove 1 element at index 1
arr.splice(1, 0, 2);       // Insert 2 at index 1
arr.splice(1, 1, 20, 30);  // Replace 1 element with two

// toSpliced (ES2023): non-mutating splice
const original = [1, 2, 3, 4];
const modified = original.toSpliced(1, 2, 20, 30);
// original: [1, 2, 3, 4]   (unchanged)
// modified: [1, 20, 30, 4]</code></pre>

            <h2 id="combine">Combining: concat, flat, flatMap, spread</h2>

            <div class="code-label">javascript &mdash; Combining arrays</div>
<pre><code>// concat: merge arrays (non-mutating)
const merged = [1, 2].concat([3, 4]);   // [1, 2, 3, 4]
const merged2 = [...[1, 2], ...[3, 4]]; // Same with spread

// flat: flatten nested arrays
[[1, 2], [3, [4, 5]]].flat();   // [1, 2, 3, [4, 5]]
[[1, 2], [3, [4, 5]]].flat(2);  // [1, 2, 3, 4, 5]
nested.flat(Infinity);            // Flatten all levels

// flatMap: map then flatten one level (single pass)
const sentences = ["Hello world", "foo bar"];
const words = sentences.flatMap(s => s.split(" "));
// ["Hello", "world", "foo", "bar"]

// Practical flatMap: expand items
const orders = [
  { id: 1, items: ["apple", "banana"] },
  { id: 2, items: ["cherry"] }
];
const allItems = orders.flatMap(o => o.items);
// ["apple", "banana", "cherry"]</code></pre>

            <h2 id="create">Creating: from, of, Array constructor, fill</h2>

            <div class="code-label">javascript &mdash; Creating arrays</div>
<pre><code>// Array.from: convert iterable/array-like to array
Array.from("hello");           // ["h", "e", "l", "l", "o"]
Array.from({ length: 5 }, (_, i) => i); // [0, 1, 2, 3, 4]
Array.from(document.querySelectorAll("div"));

// Array.of: create array from arguments
Array.of(1, 2, 3); // [1, 2, 3]
Array.of(5);        // [5] (not [undefined x 5])

// fill: fill array with a value
new Array(5).fill(0);          // [0, 0, 0, 0, 0]
[1, 2, 3, 4].fill(0, 1, 3);   // [1, 0, 0, 4]

// with (ES2023): replace one element (non-mutating)
const arr = [1, 2, 3, 4];
const updated = arr.with(2, 99);
// arr: [1, 2, 3, 4]       (unchanged)
// updated: [1, 2, 99, 4]</code></pre>

            <h2 id="es2023">ES2023+ New Methods</h2>

            <p>Recent ECMAScript versions added non-mutating alternatives and new utility methods supported in all modern browsers and Node.js 20+.</p>

            <div class="code-label">javascript &mdash; Object.groupBy (ES2024)</div>
<pre><code>const inventory = [
  { name: "asparagus", type: "vegetables" },
  { name: "bananas", type: "fruit" },
  { name: "cherries", type: "fruit" },
  { name: "goat", type: "meat" }
];

const grouped = Object.groupBy(inventory, item => item.type);
// {
//   vegetables: [{ name: "asparagus", ... }],
//   fruit: [{ name: "bananas", ... }, { name: "cherries", ... }],
//   meat: [{ name: "goat", ... }]
// }</code></pre>

            <div class="info-box success">
                <div class="info-box-title">Mutation Quick Reference</div>
                <p><strong>Mutates:</strong> push, pop, shift, unshift, splice, sort, reverse, fill. <strong>Does not mutate:</strong> map, filter, reduce, concat, flat, flatMap, slice, toSorted, toReversed, toSpliced, with. When in doubt, prefer non-mutating methods to avoid side-effect bugs.</p>
            </div>

            <h2 id="chaining">Method Chaining Patterns</h2>

            <p>Because map, filter, and other methods return arrays, you can chain them into data processing pipelines:</p>

            <div class="code-label">javascript &mdash; Chaining patterns</div>
<pre><code>const transactions = [
  { id: 1, amount: 50, type: "income" },
  { id: 2, amount: 30, type: "expense" },
  { id: 3, amount: 100, type: "income" },
  { id: 4, amount: 20, type: "expense" },
  { id: 5, amount: 200, type: "income" }
];

// Pipeline: filter -> map -> reduce
const totalIncome = transactions
  .filter(t => t.type === "income")
  .map(t => t.amount)
  .reduce((sum, amount) => sum + amount, 0);
// 350

// Get sorted, formatted list of expensive items
const products = [
  { name: "Laptop", price: 999 },
  { name: "Mouse", price: 29 },
  { name: "Monitor", price: 499 },
  { name: "Keyboard", price: 79 }
];

const expensiveFormatted = products
  .filter(p => p.price > 50)
  .toSorted((a, b) => b.price - a.price)
  .map(p => `${p.name}: $${p.price}`);
// ["Laptop: $999", "Monitor: $499", "Keyboard: $79"]</code></pre>

            <h2 id="performance">Performance Considerations</h2>

            <ul>
                <li><strong>Chaining creates intermediate arrays.</strong> <code>arr.filter().map()</code> iterates twice and creates two arrays. For very large arrays (100k+ elements), consider a single <code>reduce()</code> or a <code>for</code> loop.</li>
                <li><strong>for loops are faster</strong> for pure computation on large datasets. The difference is negligible for arrays under 10,000 elements.</li>
                <li><strong>find() and some() stop early.</strong> They return as soon as they find a match, making them efficient for large arrays.</li>
                <li><strong>Avoid creating arrays you do not need.</strong> Use <code>forEach()</code> for side effects, not <code>map()</code>. Use <code>some()</code> instead of <code>filter().length > 0</code>.</li>
                <li><strong>Set has O(1) lookup.</strong> If you call <code>includes()</code> repeatedly on the same array, convert it to a <code>Set</code> first.</li>
            </ul>

            <hr>

            <h2 id="tools">Related Free Tools</h2>

            <div class="tool-grid">
                <a href="/free-tools/javascript-minifier.html" class="tool-card">
                    <div class="tool-card-icon">&#x26A1;</div>
                    <div class="tool-card-name">JavaScript Minifier</div>
                    <div class="tool-card-desc">Minify and compress JavaScript for production. Removes whitespace, comments, and shortens variable names.</div>
                </a>
                <a href="/free-tools/json-formatter.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F4CB;</div>
                    <div class="tool-card-name">JSON Formatter</div>
                    <div class="tool-card-desc">Format, validate, and explore JSON data. Perfect for API responses and config files.</div>
                </a>
                <a href="/free-tools/regex-tester.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F50D;</div>
                    <div class="tool-card-name">Regex Tester</div>
                    <div class="tool-card-desc">Test JavaScript regular expressions with real-time matching and group highlighting.</div>
                </a>
                <a href="/free-tools/typescript-converter.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F1F9;</div>
                    <div class="tool-card-name">TypeScript Converter</div>
                    <div class="tool-card-desc">Convert JavaScript to TypeScript with automatic type inference and interface generation.</div>
                </a>
                <a href="/free-tools/code-screenshot.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F4F7;</div>
                    <div class="tool-card-name">Code Screenshot</div>
                    <div class="tool-card-desc">Create beautiful code screenshots for documentation, presentations, and social media.</div>
                </a>
            </div>

            <hr>

            <div class="faq-section" id="faq">
                <h2>Frequently Asked Questions</h2>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>What is the difference between map and forEach in JavaScript?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p><code>map()</code> creates and returns a new array with the results of calling a function on every element. <code>forEach()</code> executes a function on every element but returns <code>undefined</code>. Use <code>map()</code> when you need to transform data and use the resulting array. Use <code>forEach()</code> when you want to perform side effects like logging, updating the DOM, or making API calls for each element. Because <code>map()</code> returns a new array, you can chain it with other array methods like <code>filter()</code> and <code>reduce()</code>. <code>forEach()</code> cannot be chained since it returns <code>undefined</code>.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>How does reduce work in JavaScript?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p><code>reduce()</code> iterates over an array and accumulates a single result value. It takes two arguments: a callback function and an optional initial value. The callback receives four parameters: the accumulator (the running total or accumulated result), the current element, the current index, and the original array. On each iteration, the callback's return value becomes the new accumulator for the next iteration. Always provide an initial value to avoid unexpected behavior with empty arrays. Common uses include summing numbers (<code>reduce((sum, n) => sum + n, 0)</code>), flattening arrays, counting occurrences, and grouping objects by a property.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>Does sort mutate the original array in JavaScript?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Yes, <code>Array.sort()</code> mutates the original array in place and also returns the sorted array. This is a common source of bugs. If you need to sort without modifying the original, create a copy first using the spread operator (<code>[...arr].sort()</code>), <code>Array.from(arr).sort()</code>, or <code>arr.slice().sort()</code>. As of ES2023, you can use the new <code>toSorted()</code> method which returns a sorted copy without mutating the original. Also note that <code>sort()</code> without a compare function converts elements to strings and sorts them lexicographically, which means <code>[10, 9, 80].sort()</code> produces <code>[10, 80, 9]</code>. Always pass a compare function for numbers: <code>arr.sort((a, b) => a - b)</code>.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>What is the difference between find and filter in JavaScript?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p><code>find()</code> returns the first element that matches a condition, or <code>undefined</code> if no match is found. It stops searching as soon as it finds a match. <code>filter()</code> returns a new array containing all elements that match a condition, or an empty array if nothing matches. Use <code>find()</code> when you expect one result and want to stop early, like looking up a user by ID. Use <code>filter()</code> when you want all matching results, like getting all users in a specific city. <code>find()</code> is more efficient when you only need one result because it does not process the remaining elements after finding a match.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>What are the new array methods in ES2023 and ES2024?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>ES2023 introduced non-mutating versions of existing methods: <code>toSorted()</code> (like <code>sort()</code> but returns a new array), <code>toReversed()</code> (like <code>reverse()</code> but non-mutating), <code>toSpliced()</code> (like <code>splice()</code> but non-mutating), and <code>with(index, value)</code> which returns a new array with one element replaced. These are supported in all modern browsers. ES2024 added <code>Object.groupBy(array, callback)</code> which groups array elements by a key returned by the callback function, replacing the common reduce-based grouping pattern. It returns a null-prototype object with arrays as values.</p>
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <div class="author-box">
            <div class="author-avatar">NT</div>
            <div class="author-info">
                <h4>NexTool</h4>
                <p>We build free, browser-based developer tools. Over 250 tools for JavaScript, web development, and everyday coding. All client-side, no signup required.</p>
            </div>
        </div>

        <div class="cta-box">
            <h3>250+ Developer Tools, Zero Signup</h3>
            <p>NexTool Pro gives you clean output, enhanced features, and unlimited workspace. $29 founding member price (regular $49). One payment, lifetime access.</p>
            <a href="/free-tools/" class="cta-button">Browse Free Tools</a>
            <a href="/blog/" class="cta-button secondary">Read More Articles</a>
        </div>
    </article>

    <footer class="footer">
        <div class="footer-inner">
            <div class="footer-links">
                <a href="https://nextool.app">Home</a>
                <a href="/free-tools/">Free Tools</a>
                <a href="/blog/">Blog</a>
            </div>
            <p>&copy; 2026 NexTool. All rights reserved. 250+ free developer tools.</p>
        </div>
    </footer>

    <script>
        function toggleFAQ(button) {
            const item = button.parentElement;
            const answer = item.querySelector('.faq-answer');
            const isOpen = item.classList.contains('open');
            document.querySelectorAll('.faq-item').forEach(faq => {
                faq.classList.remove('open');
                faq.querySelector('.faq-answer').style.maxHeight = null;
            });
            if (!isOpen) {
                item.classList.add('open');
                answer.style.maxHeight = answer.scrollHeight + 'px';
            }
        }
    </script>

    <script defer src="/js/analytics-lite.js"></script>
    <script defer src="/js/revenue.js"></script>
    <script defer src="/js/lead-capture.js"></script>
</body>
</html>