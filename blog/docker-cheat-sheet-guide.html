<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Docker Cheat Sheet: Essential Commands for 2026 | ANIMA</title>
    <meta name="description" content="The complete Docker cheat sheet for 2026. Every command for images, containers, volumes, networks, docker-compose, multi-stage builds, debugging, optimization, and security best practices.">
    <meta name="keywords" content="docker cheat sheet, docker commands, docker-compose, dockerfile, docker volumes, docker networks, multi-stage builds, docker security, docker optimization, docker tutorial 2026">
    <meta name="author" content="Christian Bucher">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://nextool.app/blog/docker-cheat-sheet-guide.html">

    <!-- Open Graph -->
    <meta property="og:type" content="article">
    <meta property="og:title" content="Docker Cheat Sheet: Commands Every Developer Should Know">
    <meta property="og:description" content="Every Docker command you need in one place. Images, containers, volumes, networks, compose, multi-stage builds, debugging, and security.">
    <meta property="og:url" content="https://nextool.app/blog/docker-cheat-sheet-guide.html">
    <meta property="og:site_name" content="ANIMA by Christian Bucher">
    <meta property="og:image" content="https://nextool.app/assets/images/blog/docker-cheat-sheet-guide-og.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="article:published_time" content="2026-02-14T09:00:00Z">
    <meta property="article:modified_time" content="2026-02-14T09:00:00Z">
    <meta property="article:author" content="Christian Bucher">
    <meta property="article:section" content="Reference">
    <meta property="article:tag" content="Docker">
    <meta property="article:tag" content="DevOps">
    <meta property="article:tag" content="Containers">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Docker Cheat Sheet: Commands Every Developer Should Know">
    <meta name="twitter:description" content="Every Docker command you need in one place. Images, containers, volumes, networks, compose, multi-stage builds, and security.">
    <meta name="twitter:image" content="https://nextool.app/assets/images/blog/docker-cheat-sheet-guide-og.png">

    <!-- JSON-LD: Article -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Article",
        "headline": "Docker Cheat Sheet: Commands Every Developer Should Know",
        "description": "The complete Docker cheat sheet for 2026. Every command for images, containers, volumes, networks, docker-compose, multi-stage builds, debugging, optimization, and security best practices.",
        "image": "https://nextool.app/assets/images/blog/docker-cheat-sheet-guide-og.png",
        "author": {
            "@type": "Organization",
            "name": "Christian Bucher",
            "url": "https://nextool.app"
        },
        "publisher": {
            "@type": "Organization",
            "name": "ANIMA",
            "logo": {
                "@type": "ImageObject",
                "url": "https://nextool.app/assets/images/logo.png"
            }
        },
        "datePublished": "2026-02-14T09:00:00Z",
        "dateModified": "2026-02-14T09:00:00Z",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://nextool.app/blog/docker-cheat-sheet-guide.html"
        },
        "wordCount": 2900,
        "keywords": ["docker cheat sheet", "docker commands", "docker-compose", "dockerfile", "multi-stage builds", "docker volumes", "docker networks", "docker security", "docker optimization"]
    }
    </script>

    <!-- JSON-LD: BreadcrumbList -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BreadcrumbList",
        "itemListElement": [
            {
                "@type": "ListItem",
                "position": 1,
                "name": "Home",
                "item": "https://nextool.app"
            },
            {
                "@type": "ListItem",
                "position": 2,
                "name": "Blog",
                "item": "https://nextool.app/blog/"
            },
            {
                "@type": "ListItem",
                "position": 3,
                "name": "Docker Cheat Sheet",
                "item": "https://nextool.app/blog/docker-cheat-sheet-guide.html"
            }
        ]
    }
    </script>

    <!-- JSON-LD: FAQPage -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "FAQPage",
        "mainEntity": [
            {
                "@type": "Question",
                "name": "What is the difference between a Docker image and a container?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "A Docker image is a read-only template that contains the application code, runtime, libraries, and configuration needed to run software. Think of it as a blueprint or a snapshot. A container is a running instance of an image. When you run docker run, Docker creates a writable layer on top of the image and starts a process inside an isolated environment. You can run multiple containers from the same image, and each container has its own filesystem, network, and process space. Images are built with docker build and stored in registries. Containers are created with docker run and managed with docker start, docker stop, and docker rm."
                }
            },
            {
                "@type": "Question",
                "name": "How do I reduce Docker image size?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Use multi-stage builds to separate the build environment from the runtime image. Start FROM a large image with build tools, compile your application, then COPY only the compiled output into a minimal base image like alpine or distroless. Combine RUN commands with && to reduce layers. Use .dockerignore to exclude node_modules, .git, and other unnecessary files from the build context. Choose the smallest base image that works: alpine images are typically 5-10MB compared to 100MB+ for ubuntu-based images. Remove package manager caches in the same layer that installs packages (for example, rm -rf /var/lib/apt/lists/* in the same RUN command as apt-get install). Order Dockerfile instructions from least to most frequently changed so Docker can cache intermediate layers effectively."
                }
            },
            {
                "@type": "Question",
                "name": "What is docker-compose and when should I use it?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Docker Compose is a tool for defining and running multi-container applications using a YAML file (docker-compose.yml or compose.yaml). Instead of running multiple docker run commands with long argument lists, you declare all your services, networks, and volumes in one file and start everything with docker compose up. Use Compose when your application has multiple services that need to communicate (for example, a web server, a database, and a cache), when you want reproducible development environments that match across team members, or when you need to define environment variables, port mappings, volume mounts, and health checks in a version-controlled file. Compose is standard for local development and testing. For production orchestration at scale, teams typically use Kubernetes or Docker Swarm, though Compose is increasingly used in production for simpler deployments."
                }
            },
            {
                "@type": "Question",
                "name": "How do I persist data in Docker containers?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Use Docker volumes. Containers have writable layers, but any data written inside a container is lost when the container is removed. Volumes store data outside the container's filesystem and persist across container restarts and removals. There are three approaches: named volumes (docker volume create mydata, then mount with -v mydata:/app/data) are managed by Docker and stored in /var/lib/docker/volumes; bind mounts (-v /host/path:/container/path) map a specific host directory into the container; and tmpfs mounts (--tmpfs /tmp) store data in memory only. Named volumes are preferred for databases and persistent application data because they work across platforms and can be backed up with docker volume commands. Bind mounts are useful for development when you want live code reloading from your host filesystem."
                }
            },
            {
                "@type": "Question",
                "name": "How do I debug a Docker container that keeps crashing?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Start with docker logs <container> to see stdout and stderr output, adding --tail 100 to see the last 100 lines or -f to follow logs in real time. If the container exits immediately, run it interactively with docker run -it <image> /bin/sh to get a shell and inspect the environment. Use docker inspect <container> to see the full configuration including environment variables, mounts, and network settings. Check docker events for system-level events. If the container runs but the application is not working, use docker exec -it <container> /bin/sh to open a shell inside the running container. For resource issues, docker stats shows live CPU, memory, and I/O usage. To see what changed in the filesystem since the container started, use docker diff <container>. For networking issues, docker network inspect <network> shows the network configuration and connected containers."
                }
            },
            {
                "@type": "Question",
                "name": "Should I run containers as root or a non-root user?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Always run containers as a non-root user in production. By default, the process inside a Docker container runs as root, which means if an attacker escapes the container, they have root access to the host. Add a USER instruction to your Dockerfile to switch to a non-root user after installing dependencies. For example: RUN addgroup -S appgroup && adduser -S appuser -G appgroup, then USER appuser. Install packages and copy files before switching users since those operations need root. You can also enforce this at runtime with docker run --user 1000:1000. Many official images like node and python already include a non-root user. Additionally, use read-only file systems (--read-only flag) where possible, drop all Linux capabilities (--cap-drop ALL) and add back only what is needed, and never store secrets in environment variables or image layers."
                }
            }
        ]
    }
    </script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <style>
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #050508;
            --surface: #0a0a0f;
            --surface-2: #1a1a24;
            --surface-3: #232330;
            --primary: #00d4ff;
            --primary-hover: #818cf8;
            --accent: #a855f7;
            --accent-hover: #c084fc;
            --text: #e2e8f0;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --border: #1e1e2e;
            --success: #22c55e;
            --warning: #f59e0b;
            --error: #ef4444;
            --code-bg: #0d0d14;
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --font-mono: 'JetBrains Mono', 'Fira Code', monospace;
            --max-width: 800px;
            --header-height: 64px;
        }

        html { scroll-behavior: smooth; -webkit-text-size-adjust: 100%; }
        body { font-family: var(--font-sans); background: var(--bg); color: var(--text); line-height: 1.75; font-size: 16px; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; overflow-x: hidden; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg); }
        ::-webkit-scrollbar-thumb { background: var(--surface-3); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

        .nav { position: fixed; top: 0; left: 0; right: 0; height: var(--header-height); background: rgba(5, 5, 8, 0.85); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-bottom: 1px solid var(--border); z-index: 1000; display: flex; align-items: center; justify-content: center; }
        .nav-inner { width: 100%; max-width: 1200px; padding: 0 24px; display: flex; align-items: center; justify-content: space-between; }
        .nav-logo { display: flex; align-items: center; gap: 10px; text-decoration: none; color: var(--text); font-weight: 700; font-size: 1.25rem; }
        .nav-logo-icon { width: 32px; height: 32px; background: linear-gradient(135deg, var(--primary), var(--accent)); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 0.875rem; font-weight: 800; color: #fff; }
        .nav-links { display: flex; align-items: center; gap: 28px; list-style: none; }
        .nav-links a { color: var(--text-secondary); text-decoration: none; font-size: 0.9rem; font-weight: 500; transition: color 0.2s; }
        .nav-links a:hover { color: var(--text); }
        .nav-cta { background: var(--primary); color: #fff !important; padding: 8px 20px; border-radius: 8px; font-weight: 600; transition: background 0.2s, transform 0.2s; }
        .nav-cta:hover { background: var(--primary-hover); transform: translateY(-1px); }

        .article-wrapper { max-width: var(--max-width); margin: 0 auto; padding: calc(var(--header-height) + 48px) 24px 80px; }
        .breadcrumb { display: flex; align-items: center; gap: 8px; margin-bottom: 32px; font-size: 0.85rem; color: var(--text-muted); flex-wrap: wrap; }
        .breadcrumb a { color: var(--text-secondary); text-decoration: none; transition: color 0.2s; }
        .breadcrumb a:hover { color: var(--primary); }

        .article-header { margin-bottom: 48px; padding-bottom: 32px; border-bottom: 1px solid var(--border); }
        .article-category { display: inline-block; background: rgba(168, 85, 247, 0.12); color: var(--accent); padding: 4px 14px; border-radius: 20px; font-size: 0.8rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 16px; }
        .article-title { font-size: clamp(2rem, 5vw, 3rem); font-weight: 800; line-height: 1.15; color: var(--text); margin-bottom: 16px; letter-spacing: -0.03em; }
        .article-subtitle { font-size: 1.2rem; color: var(--text-secondary); line-height: 1.6; margin-bottom: 24px; }
        .article-meta { display: flex; align-items: center; gap: 20px; color: var(--text-muted); font-size: 0.875rem; flex-wrap: wrap; }
        .article-meta-item { display: flex; align-items: center; gap: 6px; }
        .article-meta-item svg { width: 16px; height: 16px; opacity: 0.7; }

        .toc { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 24px 28px; margin-bottom: 48px; }
        .toc-title { font-size: 0.85rem; font-weight: 700; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 16px; }
        .toc-list { list-style: none; counter-reset: toc; }
        .toc-list li { counter-increment: toc; margin-bottom: 8px; }
        .toc-list li a { color: var(--text-secondary); text-decoration: none; font-size: 0.925rem; display: flex; align-items: baseline; gap: 10px; transition: color 0.2s, padding-left 0.2s; padding: 4px 0; }
        .toc-list li a::before { content: counter(toc, decimal-leading-zero); color: var(--text-muted); font-size: 0.8rem; font-family: var(--font-mono); min-width: 20px; }
        .toc-list li a:hover { color: var(--primary); padding-left: 4px; }

        .article-content h2 { font-size: 1.75rem; font-weight: 700; color: var(--text); margin-top: 56px; margin-bottom: 20px; letter-spacing: -0.02em; line-height: 1.3; padding-top: 16px; border-top: 1px solid var(--border); }
        .article-content h2:first-child { margin-top: 0; padding-top: 0; border-top: none; }
        .article-content h3 { font-size: 1.3rem; font-weight: 600; color: var(--text); margin-top: 36px; margin-bottom: 14px; line-height: 1.35; }
        .article-content h4 { font-size: 1.1rem; font-weight: 600; color: var(--text-secondary); margin-top: 28px; margin-bottom: 12px; }
        .article-content p { margin-bottom: 20px; color: var(--text-secondary); line-height: 1.8; }
        .article-content a { color: var(--primary); text-decoration: none; border-bottom: 1px solid transparent; transition: border-color 0.2s; }
        .article-content a:hover { border-bottom-color: var(--primary); }
        .article-content strong { color: var(--text); font-weight: 600; }
        .article-content ul, .article-content ol { margin-bottom: 20px; padding-left: 24px; color: var(--text-secondary); }
        .article-content li { margin-bottom: 10px; line-height: 1.7; }
        .article-content li::marker { color: var(--primary); }
        .article-content blockquote { border-left: 3px solid var(--accent); background: var(--surface); padding: 16px 24px; margin: 28px 0; border-radius: 0 8px 8px 0; font-style: italic; color: var(--text-secondary); }
        .article-content blockquote p:last-child { margin-bottom: 0; }
        .article-content hr { border: none; border-top: 1px solid var(--border); margin: 48px 0; }

        .article-content pre { background: var(--code-bg); border: 1px solid var(--border); border-radius: 12px; padding: 20px 24px; overflow-x: auto; margin: 24px 0; }
        .article-content pre code { font-family: var(--font-mono); font-size: 0.875rem; line-height: 1.65; color: var(--text); background: none; padding: 0; border-radius: 0; }
        .article-content code { font-family: var(--font-mono); font-size: 0.85em; background: var(--surface); color: var(--accent); padding: 2px 8px; border-radius: 5px; }
        .code-label { display: inline-block; background: var(--surface-2); color: var(--text-muted); font-family: var(--font-mono); font-size: 0.75rem; padding: 2px 10px; border-radius: 6px 6px 0 0; margin-bottom: -1px; position: relative; top: 1px; }

        .article-content table { width: 100%; border-collapse: collapse; margin: 24px 0; font-size: 0.925rem; }
        .article-content thead th { background: var(--surface); color: var(--text); font-weight: 600; text-align: left; padding: 12px 16px; border-bottom: 2px solid var(--border); }
        .article-content tbody td { padding: 12px 16px; border-bottom: 1px solid var(--border); color: var(--text-secondary); }
        .article-content tbody tr:hover { background: var(--surface); }

        .info-box { background: rgba(0, 212, 255, 0.08); border: 1px solid rgba(0, 212, 255, 0.2); border-radius: 12px; padding: 20px 24px; margin: 28px 0; }
        .info-box.warning { background: rgba(245, 158, 11, 0.08); border-color: rgba(245, 158, 11, 0.2); }
        .info-box.danger { background: rgba(239, 68, 68, 0.08); border-color: rgba(239, 68, 68, 0.2); }
        .info-box.success { background: rgba(34, 197, 94, 0.08); border-color: rgba(34, 197, 94, 0.2); }
        .info-box-title { font-weight: 700; margin-bottom: 8px; font-size: 0.9rem; display: flex; align-items: center; gap: 8px; }
        .info-box p { color: var(--text-secondary); font-size: 0.925rem; margin-bottom: 0; }

        .tool-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 16px; margin: 28px 0; }
        .tool-card { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 20px; text-decoration: none; color: var(--text); transition: border-color 0.2s, transform 0.2s, box-shadow 0.2s; display: flex; flex-direction: column; gap: 8px; }
        .tool-card:hover { border-color: var(--primary); transform: translateY(-2px); box-shadow: 0 8px 24px rgba(0, 212, 255, 0.1); }
        .tool-card-icon { font-size: 1.5rem; margin-bottom: 4px; }
        .tool-card-name { font-weight: 600; font-size: 0.95rem; }
        .tool-card-desc { font-size: 0.825rem; color: var(--text-muted); line-height: 1.5; }

        .cta-box { background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(168, 85, 247, 0.1)); border: 1px solid rgba(0, 212, 255, 0.25); border-radius: 16px; padding: 40px 32px; text-align: center; margin: 48px 0; }
        .cta-box h3 { font-size: 1.5rem; font-weight: 700; margin-bottom: 12px; color: var(--text); }
        .cta-box p { color: var(--text-secondary); margin-bottom: 24px; max-width: 500px; margin-left: auto; margin-right: auto; }
        .cta-button { display: inline-flex; align-items: center; gap: 8px; background: var(--primary); color: #fff; padding: 14px 32px; border-radius: 10px; text-decoration: none; font-weight: 600; font-size: 1rem; transition: background 0.2s, transform 0.2s, box-shadow 0.2s; }
        .cta-button:hover { background: var(--primary-hover); transform: translateY(-2px); box-shadow: 0 8px 32px rgba(0, 212, 255, 0.3); }
        .cta-button.secondary { background: transparent; border: 1px solid var(--primary); color: var(--primary); margin-left: 12px; }
        .cta-button.secondary:hover { background: rgba(0, 212, 255, 0.1); }

        .faq-section { margin-top: 56px; padding-top: 32px; border-top: 1px solid var(--border); }
        .faq-section h2 { margin-top: 0 !important; padding-top: 0 !important; border-top: none !important; }
        .faq-item { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; margin-bottom: 12px; overflow: hidden; }
        .faq-question { width: 100%; background: none; border: none; color: var(--text); padding: 20px 24px; font-size: 1rem; font-weight: 600; text-align: left; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-family: var(--font-sans); transition: background 0.2s; }
        .faq-question:hover { background: var(--surface-2); }
        .faq-question .icon { transition: transform 0.3s; font-size: 1.25rem; color: var(--text-muted); flex-shrink: 0; margin-left: 16px; }
        .faq-item.open .faq-question .icon { transform: rotate(45deg); }
        .faq-answer { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; }
        .faq-answer-inner { padding: 0 24px 20px; color: var(--text-secondary); line-height: 1.7; }

        .author-box { display: flex; align-items: center; gap: 20px; background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 24px; margin: 48px 0; }
        .author-avatar { width: 64px; height: 64px; background: linear-gradient(135deg, var(--primary), var(--accent)); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; font-weight: 700; color: #fff; flex-shrink: 0; }
        .author-info h4 { font-weight: 600; margin-bottom: 4px; }
        .author-info p { color: var(--text-muted); font-size: 0.875rem; margin: 0; line-height: 1.5; }

        .footer { border-top: 1px solid var(--border); padding: 48px 24px; text-align: center; color: var(--text-muted); font-size: 0.85rem; }
        .footer-inner { max-width: 1200px; margin: 0 auto; }
        .footer-links { display: flex; justify-content: center; gap: 24px; margin-bottom: 20px; flex-wrap: wrap; }
        .footer-links a { color: var(--text-secondary); text-decoration: none; transition: color 0.2s; }
        .footer-links a:hover { color: var(--primary); }

        @media (max-width: 768px) {
            .nav-links { display: none; }
            .article-wrapper { padding: calc(var(--header-height) + 24px) 16px 60px; }
            .article-title { font-size: 1.75rem; }
            .tool-grid { grid-template-columns: 1fr; }
            .cta-box { padding: 28px 20px; }
            .cta-button.secondary { margin-left: 0; margin-top: 12px; }
            .author-box { flex-direction: column; text-align: center; }
            .article-content pre { padding: 16px; border-radius: 8px; }
            .article-content h2 { font-size: 1.4rem; }
            .article-content h3 { font-size: 1.15rem; }
            .article-content table { display: block; overflow-x: auto; }
        }
        @media (max-width: 480px) {
            .article-title { font-size: 1.5rem; }
            .toc { padding: 18px 20px; }
        }
    </style>
</head>
<body>

    <!-- Navigation -->
    <nav class="nav">
        <div class="nav-inner">
            <a href="https://nextool.app" class="nav-logo">
                <div class="nav-logo-icon">N</div>
                ANIMA
            </a>
            <ul class="nav-links">
                <li><a href="https://nextool.app/#services">Tools</a></li>
                <li><a href="https://nextool.app/free-tools/">Free Tools</a></li>
                <li><a href="https://nextool.app/blog/">Blog</a></li>
                <li><a href="https://nextool.app/#contact" class="nav-cta">Browse Tools</a></li>
            </ul>
        </div>
    </nav>

    <!-- Article -->
    <article class="article-wrapper" itemscope itemtype="https://schema.org/Article">
        <!-- Breadcrumb -->
        <nav class="breadcrumb" aria-label="Breadcrumb">
            <a href="https://nextool.app">Home</a>
            <span class="separator">/</span>
            <a href="https://nextool.app/blog/">Blog</a>
            <span class="separator">/</span>
            <span>Docker Cheat Sheet</span>
        </nav>

        <!-- Header -->
        <header class="article-header">
            <span class="article-category">Reference</span>
            <h1 class="article-title" itemprop="headline">Docker Cheat Sheet: Commands Every Developer Should Know</h1>
            <p class="article-subtitle">Every Docker command worth memorizing &mdash; from basic container management to multi-stage builds, volume strategies, network configuration, and the security practices that keep production safe.</p>
            <div class="article-meta">
                <div class="article-meta-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>
                    <span>20 min read</span>
                </div>
                <div class="article-meta-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
                    <time datetime="2026-02-14" itemprop="datePublished">February 14, 2026</time>
                </div>
                <div class="article-meta-item">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>
                    <span itemprop="author">Christian Bucher</span>
                </div>
            </div>
        </header>

        <!-- TOC -->
        <nav class="toc" aria-label="Table of Contents">
            <div class="toc-title">Table of Contents</div>
            <ol class="toc-list">
                <li><a href="#images">Image Commands</a></li>
                <li><a href="#containers">Container Commands</a></li>
                <li><a href="#volumes">Volumes and Data Persistence</a></li>
                <li><a href="#networks">Network Commands</a></li>
                <li><a href="#dockerfile">Dockerfile Best Practices</a></li>
                <li><a href="#multistage">Multi-Stage Builds</a></li>
                <li><a href="#compose">Docker Compose</a></li>
                <li><a href="#debugging">Debugging and Inspection</a></li>
                <li><a href="#optimization">Image Optimization</a></li>
                <li><a href="#security">Security Best Practices</a></li>
                <li><a href="#tools">Docker Developer Tools</a></li>
                <li><a href="#faq">Frequently Asked Questions</a></li>
            </ol>
        </nav>

        <!-- Content -->
        <div class="article-content" itemprop="articleBody">

            <h2 id="images">Image Commands</h2>

            <p>Images are the building blocks of Docker. Every container starts from an image, and every deployment begins with building or pulling one. These are the commands you will use most.</p>

            <h3>Building Images</h3>

            <div class="code-label">bash &mdash; Build commands</div>
<pre><code># Build from Dockerfile in current directory
docker build -t myapp:latest .

# Build with a specific Dockerfile
docker build -f Dockerfile.prod -t myapp:prod .

# Build with build arguments
docker build --build-arg NODE_ENV=production -t myapp:prod .

# Build without using cache (force rebuild all layers)
docker build --no-cache -t myapp:latest .

# Build for a specific platform
docker build --platform linux/amd64 -t myapp:amd64 .

# Build for multiple platforms (requires buildx)
docker buildx build --platform linux/amd64,linux/arm64 -t myapp:multi .</code></pre>

            <h3>Managing Images</h3>

            <div class="code-label">bash &mdash; Image management</div>
<pre><code># List all local images
docker images

# List images with size and details
docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}\t{{.CreatedAt}}"

# Pull an image from a registry
docker pull node:22-alpine

# Push an image to a registry
docker push myregistry.com/myapp:latest

# Tag an image (create an alias)
docker tag myapp:latest myregistry.com/myapp:v1.2.3

# Remove an image
docker rmi myapp:latest

# Remove all unused images (dangling)
docker image prune

# Remove ALL unused images (not just dangling)
docker image prune -a

# Inspect image layers and metadata
docker inspect node:22-alpine

# View the history of an image (see each layer)
docker history myapp:latest</code></pre>

            <div class="info-box">
                <div class="info-box-title">Image Naming Convention</div>
                <p>Use the format <code>registry/namespace/name:tag</code>. For production, always use specific version tags (<code>node:22.2-alpine</code>) instead of <code>latest</code>. The <code>latest</code> tag is mutable and can point to different images at different times, making builds non-reproducible.</p>
            </div>

            <h2 id="containers">Container Commands</h2>

            <p>Containers are running instances of images. These commands cover the full lifecycle from creation to removal.</p>

            <h3>Running Containers</h3>

            <div class="code-label">bash &mdash; Run commands</div>
<pre><code># Run a container in the foreground
docker run myapp:latest

# Run in detached mode (background)
docker run -d --name myapp myapp:latest

# Run with port mapping (host:container)
docker run -d -p 3000:3000 myapp:latest

# Run with multiple port mappings
docker run -d -p 3000:3000 -p 9229:9229 myapp:latest

# Run with environment variables
docker run -d -e NODE_ENV=production -e DB_HOST=db myapp:latest

# Run with an env file
docker run -d --env-file .env myapp:latest

# Run with a volume mount
docker run -d -v mydata:/app/data myapp:latest

# Run interactively with a shell
docker run -it node:22-alpine /bin/sh

# Run with automatic removal when stopped
docker run --rm myapp:latest

# Run with resource limits
docker run -d --memory=512m --cpus=1.5 myapp:latest

# Run with a restart policy
docker run -d --restart=unless-stopped myapp:latest</code></pre>

            <p>When managing environment variables across multiple containers and environments, the <a href="/free-tools/env-file-editor.html">.env File Editor</a> helps you create and validate <code>.env</code> files without syntax errors.</p>

            <h3>Managing Running Containers</h3>

            <div class="code-label">bash &mdash; Container lifecycle</div>
<pre><code># List running containers
docker ps

# List ALL containers (including stopped)
docker ps -a

# Stop a container gracefully (SIGTERM, then SIGKILL after 10s)
docker stop myapp

# Stop with a custom timeout
docker stop -t 30 myapp

# Start a stopped container
docker start myapp

# Restart a container
docker restart myapp

# Kill a container immediately (SIGKILL)
docker kill myapp

# Remove a stopped container
docker rm myapp

# Force remove a running container
docker rm -f myapp

# Remove all stopped containers
docker container prune

# Rename a container
docker rename old_name new_name</code></pre>

            <h2 id="volumes">Volumes and Data Persistence</h2>

            <p>Containers are ephemeral. When a container is removed, its writable layer is gone. Volumes solve this by storing data outside the container filesystem.</p>

            <div class="code-label">bash &mdash; Volume commands</div>
<pre><code># Create a named volume
docker volume create mydata

# List all volumes
docker volume ls

# Inspect a volume (see mount point, driver, etc.)
docker volume inspect mydata

# Remove a volume
docker volume rm mydata

# Remove all unused volumes
docker volume prune

# Run a container with a named volume
docker run -d -v mydata:/app/data myapp:latest

# Run with a bind mount (host directory)
docker run -d -v $(pwd)/src:/app/src myapp:latest

# Run with a read-only bind mount
docker run -d -v $(pwd)/config:/app/config:ro myapp:latest

# Copy files between host and container
docker cp myapp:/app/logs ./logs
docker cp ./config.json myapp:/app/config.json</code></pre>

            <h3>Volume Types Compared</h3>

            <table>
                <thead>
                    <tr>
                        <th>Type</th>
                        <th>Syntax</th>
                        <th>Best For</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Named Volume</strong></td>
                        <td><code>-v mydata:/app/data</code></td>
                        <td>Database storage, persistent app data</td>
                    </tr>
                    <tr>
                        <td><strong>Bind Mount</strong></td>
                        <td><code>-v /host/path:/container/path</code></td>
                        <td>Development (live code reloading)</td>
                    </tr>
                    <tr>
                        <td><strong>tmpfs Mount</strong></td>
                        <td><code>--tmpfs /tmp</code></td>
                        <td>Temporary data, secrets in memory</td>
                    </tr>
                    <tr>
                        <td><strong>Anonymous Volume</strong></td>
                        <td><code>-v /app/data</code></td>
                        <td>Avoid (hard to manage, no name)</td>
                    </tr>
                </tbody>
            </table>

            <h2 id="networks">Network Commands</h2>

            <p>Docker networks let containers communicate with each other and with the outside world. By default, containers on the same network can reach each other by container name.</p>

            <div class="code-label">bash &mdash; Network commands</div>
<pre><code># List all networks
docker network ls

# Create a custom bridge network
docker network create mynetwork

# Create a network with a specific subnet
docker network create --subnet=172.20.0.0/16 mynetwork

# Run a container on a specific network
docker run -d --network mynetwork --name api myapp:latest

# Connect a running container to a network
docker network connect mynetwork myapp

# Disconnect a container from a network
docker network disconnect mynetwork myapp

# Inspect a network (see connected containers, IPs)
docker network inspect mynetwork

# Remove a network
docker network rm mynetwork

# Remove all unused networks
docker network prune</code></pre>

            <div class="info-box success">
                <div class="info-box-title">DNS Resolution in Custom Networks</div>
                <p>Containers on the default <code>bridge</code> network can only reach each other by IP address. Containers on a custom bridge network get automatic DNS resolution by container name. Always create a custom network for multi-container applications.</p>
            </div>

            <h2 id="dockerfile">Dockerfile Best Practices</h2>

            <p>A well-structured Dockerfile produces smaller images, builds faster, and is easier to maintain. These patterns apply to most languages and frameworks.</p>

            <div class="code-label">Dockerfile &mdash; Node.js production image</div>
<pre><code># Use specific version, not 'latest'
FROM node:22-alpine AS base

# Set working directory
WORKDIR /app

# Copy dependency files first (cache optimization)
COPY package.json package-lock.json ./

# Install production dependencies only
RUN npm ci --only=production &amp;&amp; npm cache clean --force

# Copy application code
COPY . .

# Create non-root user
RUN addgroup -S appgroup &amp;&amp; adduser -S appuser -G appgroup

# Switch to non-root user
USER appuser

# Expose port (documentation, not enforcement)
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:3000/health || exit 1

# Use exec form for CMD (PID 1 signal handling)
CMD ["node", "server.js"]</code></pre>

            <h3>Layer Caching Rules</h3>

            <p>Docker caches each layer. When a layer changes, all subsequent layers are rebuilt. This means order matters:</p>

            <ol>
                <li><strong>System dependencies</strong> first (rarely change)</li>
                <li><strong>Language dependencies</strong> second (change occasionally)</li>
                <li><strong>Application code</strong> last (changes frequently)</li>
            </ol>

            <p>By copying <code>package.json</code> and running <code>npm ci</code> before copying the rest of the code, Docker can reuse the cached dependency layer whenever only your application code changes.</p>

            <h3>The .dockerignore File</h3>

            <div class="code-label">.dockerignore</div>
<pre><code>node_modules
npm-debug.log
.git
.gitignore
.env
.env.*
Dockerfile
docker-compose*.yml
.dockerignore
README.md
.vscode
.idea
coverage
dist
*.md</code></pre>

            <p>Without <code>.dockerignore</code>, the entire directory (including <code>node_modules</code>, <code>.git</code>, and other large directories) is sent to the Docker daemon as build context. This slows builds dramatically and can leak secrets into image layers.</p>

            <h2 id="multistage">Multi-Stage Builds</h2>

            <p>Multi-stage builds use multiple <code>FROM</code> statements in a single Dockerfile. Each stage can use a different base image and only the final stage becomes the output image. This separates build tools from the runtime, producing much smaller images.</p>

            <div class="code-label">Dockerfile &mdash; Multi-stage build</div>
<pre><code># Stage 1: Build
FROM node:22-alpine AS builder
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
RUN npm run build

# Stage 2: Production
FROM node:22-alpine AS production
WORKDIR /app

# Only install production dependencies
COPY package.json package-lock.json ./
RUN npm ci --only=production &amp;&amp; npm cache clean --force

# Copy only the build output from stage 1
COPY --from=builder /app/dist ./dist

# Non-root user
RUN addgroup -S app &amp;&amp; adduser -S app -G app
USER app

EXPOSE 3000
CMD ["node", "dist/server.js"]</code></pre>

            <p>The builder stage includes TypeScript, Webpack, and all dev dependencies. The production stage contains only the compiled JavaScript and runtime dependencies. A typical Node.js image drops from 400MB+ to under 100MB with this pattern.</p>

            <div class="info-box">
                <div class="info-box-title">Target Specific Stages</div>
                <p>Build a specific stage with <code>docker build --target builder -t myapp:build .</code>. This is useful for CI pipelines where you want to run tests in the builder stage before building the production image.</p>
            </div>

            <div class="cta-box">
                <h3>Generate Docker Compose Configs Instantly</h3>
                <p>The ANIMA Docker Compose Generator builds complete compose files for common stacks. Select your services, configure ports and volumes, and copy the result.</p>
                <a href="/free-tools/docker-compose-generator.html" class="cta-button">Open Compose Generator</a>
                <a href="/free-tools/yaml-formatter.html" class="cta-button secondary">YAML Formatter</a>
            </div>

            <h2 id="compose">Docker Compose</h2>

            <p>Docker Compose defines multi-container applications in a single YAML file. Instead of running five <code>docker run</code> commands with complex arguments, you declare everything once and run <code>docker compose up</code>.</p>

            <div class="code-label">compose.yaml &mdash; Full-stack application</div>
<pre><code>services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgres://user:pass@db:5432/mydb
      - REDIS_URL=redis://cache:6379
    depends_on:
      db:
        condition: service_healthy
      cache:
        condition: service_started
    restart: unless-stopped
    networks:
      - backend

  db:
    image: postgres:16-alpine
    volumes:
      - pgdata:/var/lib/postgresql/data
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
      POSTGRES_DB: mydb
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user -d mydb"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - backend

  cache:
    image: redis:7-alpine
    volumes:
      - redisdata:/data
    command: redis-server --appendonly yes
    networks:
      - backend

volumes:
  pgdata:
  redisdata:

networks:
  backend:
    driver: bridge</code></pre>

            <h3>Compose Commands</h3>

            <div class="code-label">bash &mdash; Docker Compose commands</div>
<pre><code># Start all services (foreground)
docker compose up

# Start in detached mode
docker compose up -d

# Start and rebuild images
docker compose up -d --build

# Stop all services
docker compose down

# Stop and remove volumes (deletes data!)
docker compose down -v

# View logs from all services
docker compose logs

# Follow logs from a specific service
docker compose logs -f app

# Scale a service to multiple instances
docker compose up -d --scale app=3

# Execute a command in a running service
docker compose exec app /bin/sh

# View service status
docker compose ps

# Pull latest images for all services
docker compose pull

# Restart a single service
docker compose restart app</code></pre>

            <p>When validating your compose files, the <a href="/free-tools/yaml-formatter.html">YAML Formatter</a> catches syntax errors and inconsistent indentation before Docker does.</p>

            <h2 id="debugging">Debugging and Inspection</h2>

            <p>When containers misbehave, these commands help you understand what is happening inside them.</p>

            <div class="code-label">bash &mdash; Debugging commands</div>
<pre><code># View container logs
docker logs myapp
docker logs myapp --tail 100
docker logs myapp -f              # Follow in real time
docker logs myapp --since 1h      # Last hour only

# Execute a shell inside a running container
docker exec -it myapp /bin/sh
docker exec -it myapp /bin/bash

# Run a specific command inside a container
docker exec myapp cat /etc/hosts
docker exec myapp env              # View environment variables

# Inspect container details (JSON)
docker inspect myapp

# View resource usage (live)
docker stats
docker stats myapp                 # Single container

# View filesystem changes since container started
docker diff myapp

# View running processes inside a container
docker top myapp

# View Docker system-wide events
docker events
docker events --filter type=container

# Export a container's filesystem as a tar archive
docker export myapp &gt; myapp-fs.tar

# View system disk usage
docker system df
docker system df -v                # Verbose, per-image breakdown</code></pre>

            <div class="info-box warning">
                <div class="info-box-title">Debugging Crashed Containers</div>
                <p>If a container exits immediately, <code>docker exec</code> will not work because there is no running process to attach to. Instead, start a new container from the same image with an interactive shell: <code>docker run -it myapp:latest /bin/sh</code>. This lets you inspect the filesystem, test commands, and find the root cause.</p>
            </div>

            <h2 id="optimization">Image Optimization</h2>

            <p>Smaller images mean faster pulls, faster deploys, and less attack surface. Here are the techniques that make the biggest difference.</p>

            <h3>Choose the Right Base Image</h3>

            <table>
                <thead>
                    <tr>
                        <th>Base Image</th>
                        <th>Size</th>
                        <th>Use Case</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>alpine</code></td>
                        <td>~5 MB</td>
                        <td>Minimal Linux with apk package manager</td>
                    </tr>
                    <tr>
                        <td><code>node:22-alpine</code></td>
                        <td>~50 MB</td>
                        <td>Node.js apps (smallest official Node image)</td>
                    </tr>
                    <tr>
                        <td><code>node:22-slim</code></td>
                        <td>~80 MB</td>
                        <td>Node.js when alpine causes compatibility issues</td>
                    </tr>
                    <tr>
                        <td><code>node:22</code></td>
                        <td>~350 MB</td>
                        <td>Node.js with full Debian (build tools included)</td>
                    </tr>
                    <tr>
                        <td><code>gcr.io/distroless/nodejs</code></td>
                        <td>~40 MB</td>
                        <td>No shell, no package manager (maximum security)</td>
                    </tr>
                    <tr>
                        <td><code>scratch</code></td>
                        <td>0 MB</td>
                        <td>Statically compiled binaries (Go, Rust)</td>
                    </tr>
                </tbody>
            </table>

            <h3>Reduce Layer Count</h3>

            <div class="code-label">Dockerfile &mdash; Combining commands</div>
<pre><code># Bad: 3 separate layers
RUN apt-get update
RUN apt-get install -y curl wget
RUN rm -rf /var/lib/apt/lists/*

# Good: 1 layer, smaller image
RUN apt-get update &amp;&amp; \
    apt-get install -y --no-install-recommends curl wget &amp;&amp; \
    rm -rf /var/lib/apt/lists/*</code></pre>

            <p>Each <code>RUN</code> instruction creates a new layer. If you install packages in one layer and delete caches in another, the cache still exists in the first layer &mdash; deletion in a later layer only hides it with a whiteout file. Combine related operations in a single <code>RUN</code> statement.</p>

            <p>When you need to inspect the JSON configuration files that Docker commands produce, the <a href="/free-tools/json-formatter.html">JSON Formatter</a> makes <code>docker inspect</code> output readable.</p>

            <h2 id="security">Security Best Practices</h2>

            <p>Container security is not optional. A single misconfigured container can expose your entire infrastructure. These practices should be the default for every production deployment.</p>

            <h3>Run as Non-Root</h3>

            <div class="code-label">Dockerfile &mdash; Non-root user</div>
<pre><code># Create a dedicated user and group
RUN addgroup -S appgroup &amp;&amp; adduser -S appuser -G appgroup

# Set ownership of application files
COPY --chown=appuser:appgroup . /app

# Switch to non-root user
USER appuser</code></pre>

            <h3>Security Flags at Runtime</h3>

            <div class="code-label">bash &mdash; Security-hardened run</div>
<pre><code># Drop all capabilities, add only what's needed
docker run -d \
  --cap-drop ALL \
  --cap-add NET_BIND_SERVICE \
  --read-only \
  --tmpfs /tmp \
  --security-opt no-new-privileges \
  --user 1000:1000 \
  myapp:latest</code></pre>

            <h3>Security Checklist</h3>

            <ul>
                <li><strong>Scan images for vulnerabilities</strong> with <code>docker scout cves myapp:latest</code> or integrate Trivy/Snyk into CI</li>
                <li><strong>Pin base image digests</strong> in production (<code>FROM node:22-alpine@sha256:abc...</code>)</li>
                <li><strong>Never store secrets in images</strong> &mdash; use Docker secrets, environment variables from orchestration, or a vault</li>
                <li><strong>Use <code>COPY</code> instead of <code>ADD</code></strong> unless you specifically need URL fetching or tar extraction</li>
                <li><strong>Set <code>HEALTHCHECK</code></strong> so orchestrators can detect unhealthy containers and replace them</li>
                <li><strong>Use read-only filesystem</strong> (<code>--read-only</code>) and explicitly mount writable directories</li>
                <li><strong>Limit resources</strong> with <code>--memory</code> and <code>--cpus</code> to prevent a single container from consuming the host</li>
            </ul>

            <div class="info-box danger">
                <div class="info-box-title">Never Do This in Production</div>
                <p>Running <code>docker run --privileged</code> gives the container full access to the host kernel. It disables all security isolation. There is almost never a legitimate reason to use it in production. If you think you need it, you probably need a specific Linux capability (<code>--cap-add</code>) instead.</p>
            </div>

            <p>For reverse proxy configuration in front of your Docker containers, the <a href="/free-tools/nginx-config-generator.html">Nginx Config Generator</a> produces production-ready configs with SSL, caching, and upstream blocks.</p>

            <h2 id="tools">Docker Developer Tools</h2>

            <div class="tool-grid">
                <a href="/free-tools/docker-compose-generator.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F433;</div>
                    <div class="tool-card-name">Docker Compose Generator</div>
                    <div class="tool-card-desc">Build complete docker-compose.yml files visually. Select services, configure ports, volumes, and networks.</div>
                </a>
                <a href="/free-tools/yaml-formatter.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F4C4;</div>
                    <div class="tool-card-name">YAML Formatter</div>
                    <div class="tool-card-desc">Format, validate, and fix indentation in YAML files. Catches syntax errors in compose files and Kubernetes manifests.</div>
                </a>
                <a href="/free-tools/nginx-config-generator.html" class="tool-card">
                    <div class="tool-card-icon">&#x2699;</div>
                    <div class="tool-card-name">Nginx Config Generator</div>
                    <div class="tool-card-desc">Generate Nginx configurations for reverse proxying Docker containers with SSL, caching, and load balancing.</div>
                </a>
                <a href="/free-tools/env-file-editor.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F511;</div>
                    <div class="tool-card-name">.env File Editor</div>
                    <div class="tool-card-desc">Create and validate .env files for Docker containers. Syntax highlighting, duplicate detection, and format validation.</div>
                </a>
                <a href="/free-tools/json-formatter.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F4CB;</div>
                    <div class="tool-card-name">JSON Formatter</div>
                    <div class="tool-card-desc">Format docker inspect output, container configs, and API responses. Syntax highlighting and tree view.</div>
                </a>
            </div>

            <hr>

            <div class="faq-section" id="faq">
                <h2>Frequently Asked Questions</h2>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>What is the difference between a Docker image and a container?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>A Docker image is a read-only template that contains the application code, runtime, libraries, and configuration needed to run software. Think of it as a blueprint or a snapshot. A container is a running instance of an image. When you run docker run, Docker creates a writable layer on top of the image and starts a process inside an isolated environment. You can run multiple containers from the same image, and each container has its own filesystem, network, and process space. Images are built with docker build and stored in registries. Containers are created with docker run and managed with docker start, docker stop, and docker rm.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>How do I reduce Docker image size?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Use multi-stage builds to separate the build environment from the runtime image. Start FROM a large image with build tools, compile your application, then COPY only the compiled output into a minimal base image like alpine or distroless. Combine RUN commands with &amp;&amp; to reduce layers. Use .dockerignore to exclude node_modules, .git, and other unnecessary files from the build context. Choose the smallest base image that works: alpine images are typically 5-10MB compared to 100MB+ for ubuntu-based images. Remove package manager caches in the same layer that installs packages (for example, rm -rf /var/lib/apt/lists/* in the same RUN command as apt-get install). Order Dockerfile instructions from least to most frequently changed so Docker can cache intermediate layers effectively.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>What is docker-compose and when should I use it?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Docker Compose is a tool for defining and running multi-container applications using a YAML file (docker-compose.yml or compose.yaml). Instead of running multiple docker run commands with long argument lists, you declare all your services, networks, and volumes in one file and start everything with docker compose up. Use Compose when your application has multiple services that need to communicate (for example, a web server, a database, and a cache), when you want reproducible development environments that match across team members, or when you need to define environment variables, port mappings, volume mounts, and health checks in a version-controlled file. Compose is standard for local development and testing. For production orchestration at scale, teams typically use Kubernetes or Docker Swarm, though Compose is increasingly used in production for simpler deployments.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>How do I persist data in Docker containers?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Use Docker volumes. Containers have writable layers, but any data written inside a container is lost when the container is removed. Volumes store data outside the container's filesystem and persist across container restarts and removals. There are three approaches: named volumes (docker volume create mydata, then mount with -v mydata:/app/data) are managed by Docker and stored in /var/lib/docker/volumes; bind mounts (-v /host/path:/container/path) map a specific host directory into the container; and tmpfs mounts (--tmpfs /tmp) store data in memory only. Named volumes are preferred for databases and persistent application data because they work across platforms and can be backed up with docker volume commands. Bind mounts are useful for development when you want live code reloading from your host filesystem.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>How do I debug a Docker container that keeps crashing?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Start with docker logs &lt;container&gt; to see stdout and stderr output, adding --tail 100 to see the last 100 lines or -f to follow logs in real time. If the container exits immediately, run it interactively with docker run -it &lt;image&gt; /bin/sh to get a shell and inspect the environment. Use docker inspect &lt;container&gt; to see the full configuration including environment variables, mounts, and network settings. Check docker events for system-level events. If the container runs but the application is not working, use docker exec -it &lt;container&gt; /bin/sh to open a shell inside the running container. For resource issues, docker stats shows live CPU, memory, and I/O usage. To see what changed in the filesystem since the container started, use docker diff &lt;container&gt;. For networking issues, docker network inspect &lt;network&gt; shows the network configuration and connected containers.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>Should I run containers as root or a non-root user?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Always run containers as a non-root user in production. By default, the process inside a Docker container runs as root, which means if an attacker escapes the container, they have root access to the host. Add a USER instruction to your Dockerfile to switch to a non-root user after installing dependencies. For example: RUN addgroup -S appgroup &amp;&amp; adduser -S appuser -G appgroup, then USER appuser. Install packages and copy files before switching users since those operations need root. You can also enforce this at runtime with docker run --user 1000:1000. Many official images like node and python already include a non-root user. Additionally, use read-only file systems (--read-only flag) where possible, drop all Linux capabilities (--cap-drop ALL) and add back only what is needed, and never store secrets in environment variables or image layers.</p>
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <!-- Author -->
        <div class="author-box">
            <div class="author-avatar">NT</div>
            <div class="author-info">
                <h4>Christian Bucher</h4>
                <p>We build free developer tools for Docker, DevOps, and web development. Over 150 tools, all browser-based, no signup required.</p>
            </div>
        </div>

        <!-- Bottom CTA -->
        <div class="cta-box">
            <h3>150+ Developer Tools, One Place</h3>
            <p>ANIMA (free) unlocks clean output, enhanced features, and unlimited workspace. One payment, lifetime access.</p>
            <a href="https://nextool.app/free-tools/pro-upgrade.html" class="cta-button">Open Source &mdash; Free Forever</a>
            <a href="/free-tools/" class="cta-button secondary">Try Free Tools</a>
        </div>

    </article>

    <!-- Footer -->
    
<!-- AUTO-LINKED by ANIMA Engine -->
<div style="margin:2rem 0;padding:1.5rem;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius)">
<p style="font-weight:600;margin-bottom:.5rem">Related Tools</p>
<p><a href="/free-tools/box-shadow-generator.html" style="color:var(--primary);text-decoration:none">CSS Box Shadow Generator</a>  <a href="/free-tools/emoji-picker.html" style="color:var(--primary);text-decoration:none">Emoji Picker & Search</a>  <a href="/free-tools/git-diff-viewer.html" style="color:var(--primary);text-decoration:none">Free Git Diff Viewer</a></p>
</div>

<!-- AUTO-LINKED by ANIMA Engine -->
<div style="margin:2rem 0;padding:1.5rem;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius)">
<p style="font-weight:600;margin-bottom:.5rem">Related Tools</p>
<p><a href="/free-tools/api-mock-server.html" style="color:var(--primary);text-decoration:none">Free API Mock Server</a>  <a href="/free-tools/code-screenshot.html" style="color:var(--primary);text-decoration:none">Code Screenshot Generator - Beautiful Code Images</a>  <a href="/free-tools/color-palette-generator.html" style="color:var(--primary);text-decoration:none">Free Color Palette Generator</a></p>
</div>
<footer class="footer">
        <div class="footer-inner">
            <div class="footer-links">
                <a href="https://nextool.app">Home</a>
                <a href="https://nextool.app/#services">Tools</a>
                <a href="https://nextool.app/free-tools/">Free Tools</a>
                <a href="https://nextool.app/blog/">Blog</a>
                <a href="https://nextool.app/#contact">Contact</a>
            </div>
            <p>&copy; 2026 ANIMA. All rights reserved. 227+ free developer tools.</p>
        </div>
    </footer>

    <!-- FAQ Script -->
    <script>
        function toggleFAQ(button) {
            const item = button.parentElement;
            const answer = item.querySelector('.faq-answer');
            const isOpen = item.classList.contains('open');

            document.querySelectorAll('.faq-item').forEach(faq => {
                faq.classList.remove('open');
                faq.querySelector('.faq-answer').style.maxHeight = null;
            });

            if (!isOpen) {
                item.classList.add('open');
                answer.style.maxHeight = answer.scrollHeight + 'px';
            }
        }
    </script>

    <!-- Revenue Scripts -->
    <script defer src="/js/analytics-lite.js"></script>
    <script defer src="/js/revenue.js"></script>
    <script defer src="/js/lead-capture.js"></script>
</body>
</html>