<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Node.js Best Practices: Performance &amp; Security (2026) | NexTool</title>
    <meta name="description" content="Production-ready Node.js best practices for 2026. Project structure, error handling, security hardening, performance with clustering and streams, async patterns, testing, and deployment.">
    <meta name="keywords" content="node.js best practices, node.js security, node.js performance, node.js error handling, node.js project structure, node.js clustering, node.js streams, node.js testing, node.js 2026">
    <meta name="author" content="NexTool Team">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://nextool.app/blog/node-js-best-practices.html">

    <!-- Open Graph -->
    <meta property="og:type" content="article">
    <meta property="og:title" content="Node.js Best Practices: Performance &amp; Security Guide (2026)">
    <meta property="og:description" content="Production-ready Node.js patterns for project structure, error handling, security, performance, async code, testing, and deployment.">
    <meta property="og:url" content="https://nextool.app/blog/node-js-best-practices.html">
    <meta property="og:site_name" content="NexTool">
    <meta property="og:image" content="https://nextool.app/assets/images/blog/node-js-best-practices-og.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="article:published_time" content="2026-02-14T10:00:00Z">
    <meta property="article:modified_time" content="2026-02-14T10:00:00Z">
    <meta property="article:author" content="NexTool Team">
    <meta property="article:section" content="Guide">
    <meta property="article:tag" content="Node.js">
    <meta property="article:tag" content="JavaScript">
    <meta property="article:tag" content="Backend">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Node.js Best Practices: Performance &amp; Security Guide (2026)">
    <meta name="twitter:description" content="Production-ready Node.js patterns: project structure, error handling, security, performance, async code, testing, and deployment.">
    <meta name="twitter:image" content="https://nextool.app/assets/images/blog/node-js-best-practices-og.png">

    <!-- JSON-LD: Article -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Article",
        "headline": "Node.js Best Practices: Performance & Security Guide (2026)",
        "description": "Production-ready Node.js best practices for 2026. Project structure, error handling, security hardening, performance with clustering and streams, async patterns, testing, and deployment.",
        "image": "https://nextool.app/assets/images/blog/node-js-best-practices-og.png",
        "author": {
            "@type": "Organization",
            "name": "NexTool Team",
            "url": "https://nextool.app"
        },
        "publisher": {
            "@type": "Organization",
            "name": "NexTool",
            "logo": {
                "@type": "ImageObject",
                "url": "https://nextool.app/assets/images/logo.png"
            }
        },
        "datePublished": "2026-02-14T10:00:00Z",
        "dateModified": "2026-02-14T10:00:00Z",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://nextool.app/blog/node-js-best-practices.html"
        },
        "wordCount": 3100,
        "keywords": ["node.js best practices", "node.js security", "node.js performance", "node.js error handling", "node.js project structure", "node.js clustering", "node.js streams", "node.js 2026"]
    }
    </script>

    <!-- JSON-LD: BreadcrumbList -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BreadcrumbList",
        "itemListElement": [
            {
                "@type": "ListItem",
                "position": 1,
                "name": "Home",
                "item": "https://nextool.app"
            },
            {
                "@type": "ListItem",
                "position": 2,
                "name": "Blog",
                "item": "https://nextool.app/blog/"
            },
            {
                "@type": "ListItem",
                "position": 3,
                "name": "Node.js Best Practices",
                "item": "https://nextool.app/blog/node-js-best-practices.html"
            }
        ]
    }
    </script>

    <!-- JSON-LD: FAQPage -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "FAQPage",
        "mainEntity": [
            {
                "@type": "Question",
                "name": "What is the recommended project structure for a Node.js application?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "A production Node.js project should separate concerns into distinct layers. Use a src directory containing routes (HTTP layer), controllers (request handling), services (business logic), models (data access), middleware (cross-cutting concerns), and utils (shared helpers). Keep configuration in a dedicated config directory that reads from environment variables. Place tests in a parallel test directory that mirrors the src structure. This separation makes code testable, allows teams to work on different layers independently, and makes it clear where new functionality belongs."
                }
            },
            {
                "@type": "Question",
                "name": "How should I handle errors in Node.js?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Use a centralized error-handling strategy. Create custom error classes that extend the built-in Error class with properties like statusCode and isOperational. Catch all async errors using try-catch in async functions or a wrapper middleware like express-async-errors. Register a global error-handling middleware in Express that formats the response based on the error type. For unhandled rejections and uncaught exceptions, log the error, notify your monitoring system, and perform a graceful shutdown. Operational errors like validation failures should return appropriate HTTP status codes. Programming errors should log a stack trace and restart the process."
                }
            },
            {
                "@type": "Question",
                "name": "What are the most important security practices for Node.js?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "The most critical Node.js security practices are: use Helmet to set secure HTTP headers including Content-Security-Policy and X-Content-Type-Options; implement rate limiting with a library like express-rate-limit to prevent brute-force and DDoS attacks; validate and sanitize all user input using a schema validation library such as Joi or Zod; use parameterized queries or an ORM to prevent SQL injection; store secrets in environment variables and never commit them to version control; keep dependencies updated and audit them regularly with npm audit; implement proper authentication with bcrypt for password hashing and JWTs with short expiration times; and use HTTPS in production with TLS 1.3."
                }
            },
            {
                "@type": "Question",
                "name": "How can I improve Node.js performance in production?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Use the cluster module or PM2 to run one worker process per CPU core, multiplying throughput on multi-core machines. Implement caching at multiple levels: in-memory with a Map or LRU cache for hot data, Redis for shared cache across instances, and HTTP caching headers for client-side caching. Use Node.js streams for processing large files or data sets instead of loading everything into memory. Enable gzip or Brotli compression for HTTP responses. Use connection pooling for database connections. Profile your application with the built-in inspector or clinic.js to find actual bottlenecks before optimizing. Avoid synchronous operations on the main thread and offload CPU-intensive work to worker threads."
                }
            },
            {
                "@type": "Question",
                "name": "Should I use callbacks, Promises, or async/await in Node.js?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Use async/await for virtually all asynchronous code in modern Node.js. It produces code that reads like synchronous logic, makes error handling straightforward with try-catch, and avoids callback nesting. Promises are the underlying mechanism and are still useful for concurrent operations with Promise.all, Promise.allSettled, and Promise.race. Callbacks should only appear when working with older libraries that have not been promisified, and you can convert them using util.promisify or the built-in promise-based APIs that Node.js now provides for fs, timers, streams, and other core modules. All new Node.js core APIs ship with promise support by default."
                }
            },
            {
                "@type": "Question",
                "name": "What is the best way to deploy a Node.js application?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Containerize your application with Docker using a multi-stage build: a build stage that installs all dependencies and compiles TypeScript, and a production stage that copies only the built output and production dependencies. Use a .dockerignore file to exclude node_modules, tests, and development files. Run the container with a non-root user for security. In production, use an orchestrator like Kubernetes or a managed platform like AWS ECS, Google Cloud Run, or Railway. Set up health check endpoints for liveness and readiness probes. Use environment variables for configuration and a process manager like PM2 inside the container only if you are not using an orchestrator that handles restarts. Implement graceful shutdown by listening for SIGTERM and draining active connections before exiting."
                }
            }
        ]
    }
    </script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <style>
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        :root { --bg:#050508;--surface:#0a0a0f;--surface-2:#1a1a24;--surface-3:#232330;--primary:#6366f1;--primary-hover:#818cf8;--accent:#a855f7;--accent-hover:#c084fc;--text:#e2e8f0;--text-secondary:#94a3b8;--text-muted:#64748b;--border:#1e1e2e;--success:#22c55e;--warning:#f59e0b;--error:#ef4444;--code-bg:#0d0d14;--font-sans:'Inter',-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;--font-mono:'JetBrains Mono','Fira Code',monospace;--max-width:800px;--header-height:64px; }
        html { scroll-behavior:smooth;-webkit-text-size-adjust:100%; }
        body { font-family:var(--font-sans);background:var(--bg);color:var(--text);line-height:1.75;font-size:16px;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;overflow-x:hidden; }
        ::-webkit-scrollbar{width:8px}::-webkit-scrollbar-track{background:var(--bg)}::-webkit-scrollbar-thumb{background:var(--surface-3);border-radius:4px}::-webkit-scrollbar-thumb:hover{background:var(--text-muted)}
        .nav{position:fixed;top:0;left:0;right:0;height:var(--header-height);background:rgba(5,5,8,.85);backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);border-bottom:1px solid var(--border);z-index:1000;display:flex;align-items:center;justify-content:center}.nav-inner{width:100%;max-width:1200px;padding:0 24px;display:flex;align-items:center;justify-content:space-between}.nav-logo{display:flex;align-items:center;gap:10px;text-decoration:none;color:var(--text);font-weight:700;font-size:1.25rem}.nav-logo-icon{width:32px;height:32px;background:linear-gradient(135deg,var(--primary),var(--accent));border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:.875rem;font-weight:800;color:#fff}.nav-links{display:flex;align-items:center;gap:28px;list-style:none}.nav-links a{color:var(--text-secondary);text-decoration:none;font-size:.9rem;font-weight:500;transition:color .2s}.nav-links a:hover{color:var(--text)}.nav-cta{background:var(--primary);color:#fff!important;padding:8px 20px;border-radius:8px;font-weight:600;transition:background .2s,transform .2s}.nav-cta:hover{background:var(--primary-hover);transform:translateY(-1px)}
        .article-wrapper{max-width:var(--max-width);margin:0 auto;padding:calc(var(--header-height) + 48px) 24px 80px}.breadcrumb{display:flex;align-items:center;gap:8px;margin-bottom:32px;font-size:.85rem;color:var(--text-muted);flex-wrap:wrap}.breadcrumb a{color:var(--text-secondary);text-decoration:none;transition:color .2s}.breadcrumb a:hover{color:var(--primary)}
        .article-header{margin-bottom:48px;padding-bottom:32px;border-bottom:1px solid var(--border)}.article-category{display:inline-block;background:rgba(168,85,247,.12);color:var(--accent);padding:4px 14px;border-radius:20px;font-size:.8rem;font-weight:600;text-transform:uppercase;letter-spacing:.5px;margin-bottom:16px}.article-title{font-size:clamp(2rem,5vw,3rem);font-weight:800;line-height:1.15;color:var(--text);margin-bottom:16px;letter-spacing:-.03em}.article-subtitle{font-size:1.2rem;color:var(--text-secondary);line-height:1.6;margin-bottom:24px}.article-meta{display:flex;align-items:center;gap:20px;color:var(--text-muted);font-size:.875rem;flex-wrap:wrap}.article-meta-item{display:flex;align-items:center;gap:6px}
        .toc{background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:24px 28px;margin-bottom:48px}.toc-title{font-size:.85rem;font-weight:700;color:var(--text-secondary);text-transform:uppercase;letter-spacing:.5px;margin-bottom:16px}.toc-list{list-style:none;counter-reset:toc}.toc-list li{counter-increment:toc;margin-bottom:8px}.toc-list li a{color:var(--text-secondary);text-decoration:none;font-size:.925rem;display:flex;align-items:baseline;gap:10px;transition:color .2s,padding-left .2s;padding:4px 0}.toc-list li a::before{content:counter(toc,decimal-leading-zero);color:var(--text-muted);font-size:.8rem;font-family:var(--font-mono);min-width:20px}.toc-list li a:hover{color:var(--primary);padding-left:4px}
        .article-content h2{font-size:1.75rem;font-weight:700;color:var(--text);margin-top:56px;margin-bottom:20px;letter-spacing:-.02em;line-height:1.3;padding-top:16px;border-top:1px solid var(--border)}.article-content h2:first-child{margin-top:0;padding-top:0;border-top:none}.article-content h3{font-size:1.3rem;font-weight:600;color:var(--text);margin-top:36px;margin-bottom:14px;line-height:1.35}.article-content h4{font-size:1.1rem;font-weight:600;color:var(--text-secondary);margin-top:28px;margin-bottom:12px}.article-content p{margin-bottom:20px;color:var(--text-secondary);line-height:1.8}.article-content a{color:var(--primary);text-decoration:none;border-bottom:1px solid transparent;transition:border-color .2s}.article-content a:hover{border-bottom-color:var(--primary)}.article-content strong{color:var(--text);font-weight:600}.article-content ul,.article-content ol{margin-bottom:20px;padding-left:24px;color:var(--text-secondary)}.article-content li{margin-bottom:10px;line-height:1.7}.article-content li::marker{color:var(--primary)}.article-content blockquote{border-left:3px solid var(--accent);background:var(--surface);padding:16px 24px;margin:28px 0;border-radius:0 8px 8px 0;font-style:italic;color:var(--text-secondary)}.article-content blockquote p:last-child{margin-bottom:0}.article-content hr{border:none;border-top:1px solid var(--border);margin:48px 0}
        .article-content pre{background:var(--code-bg);border:1px solid var(--border);border-radius:12px;padding:20px 24px;overflow-x:auto;margin:24px 0}.article-content pre code{font-family:var(--font-mono);font-size:.875rem;line-height:1.65;color:var(--text);background:none;padding:0;border-radius:0}.article-content code{font-family:var(--font-mono);font-size:.85em;background:var(--surface);color:var(--accent);padding:2px 8px;border-radius:5px}
        .info-box{background:rgba(99,102,241,.08);border:1px solid rgba(99,102,241,.2);border-radius:12px;padding:20px 24px;margin:28px 0}.info-box.warning{background:rgba(245,158,11,.08);border-color:rgba(245,158,11,.2)}.info-box.danger{background:rgba(239,68,68,.08);border-color:rgba(239,68,68,.2)}.info-box.success{background:rgba(34,197,94,.08);border-color:rgba(34,197,94,.2)}.info-box-title{font-weight:700;margin-bottom:8px;font-size:.9rem;display:flex;align-items:center;gap:8px}.info-box p{color:var(--text-secondary);font-size:.925rem;margin-bottom:0}
        .tool-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:16px;margin:28px 0}.tool-card{background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:20px;text-decoration:none;color:var(--text);transition:border-color .2s,transform .2s,box-shadow .2s;display:flex;flex-direction:column;gap:8px}.tool-card:hover{border-color:var(--primary);transform:translateY(-2px);box-shadow:0 8px 24px rgba(99,102,241,.1)}.tool-card-icon{font-size:1.5rem;margin-bottom:4px}.tool-card-name{font-weight:600;font-size:.95rem}.tool-card-desc{font-size:.825rem;color:var(--text-muted);line-height:1.5}
        .cta-box{background:linear-gradient(135deg,rgba(99,102,241,.1),rgba(168,85,247,.1));border:1px solid rgba(99,102,241,.25);border-radius:16px;padding:40px 32px;text-align:center;margin:48px 0}.cta-box h3{font-size:1.5rem;font-weight:700;margin-bottom:12px;color:var(--text)}.cta-box p{color:var(--text-secondary);margin-bottom:24px;max-width:500px;margin-left:auto;margin-right:auto}.cta-button{display:inline-flex;align-items:center;gap:8px;background:var(--primary);color:#fff;padding:14px 32px;border-radius:10px;text-decoration:none;font-weight:600;font-size:1rem;transition:background .2s,transform .2s,box-shadow .2s}.cta-button:hover{background:var(--primary-hover);transform:translateY(-2px);box-shadow:0 8px 32px rgba(99,102,241,.3)}.cta-button.secondary{background:transparent;border:1px solid var(--primary);color:var(--primary);margin-left:12px}.cta-button.secondary:hover{background:rgba(99,102,241,.1)}
        .faq-section{margin-top:56px;padding-top:32px;border-top:1px solid var(--border)}.faq-section h2{margin-top:0!important;padding-top:0!important;border-top:none!important}.faq-item{background:var(--surface);border:1px solid var(--border);border-radius:12px;margin-bottom:12px;overflow:hidden}.faq-question{width:100%;background:none;border:none;color:var(--text);padding:20px 24px;font-size:1rem;font-weight:600;text-align:left;cursor:pointer;display:flex;justify-content:space-between;align-items:center;font-family:var(--font-sans);transition:background .2s}.faq-question:hover{background:var(--surface-2)}.faq-question .icon{transition:transform .3s;font-size:1.25rem;color:var(--text-muted);flex-shrink:0;margin-left:16px}.faq-item.open .faq-question .icon{transform:rotate(45deg)}.faq-answer{max-height:0;overflow:hidden;transition:max-height .3s ease}.faq-answer-inner{padding:0 24px 20px;color:var(--text-secondary);line-height:1.7}
        .author-box{display:flex;align-items:center;gap:20px;background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:24px;margin:48px 0}.author-avatar{width:64px;height:64px;background:linear-gradient(135deg,var(--primary),var(--accent));border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:1.5rem;font-weight:700;color:#fff;flex-shrink:0}.author-info h4{font-weight:600;margin-bottom:4px}.author-info p{color:var(--text-muted);font-size:.875rem;margin:0;line-height:1.5}
        .footer{border-top:1px solid var(--border);padding:48px 24px;text-align:center;color:var(--text-muted);font-size:.85rem}.footer-inner{max-width:1200px;margin:0 auto}.footer-links{display:flex;justify-content:center;gap:24px;margin-bottom:20px;flex-wrap:wrap}.footer-links a{color:var(--text-secondary);text-decoration:none;transition:color .2s}.footer-links a:hover{color:var(--primary)}
        .code-label{display:inline-block;background:var(--surface-2);color:var(--text-muted);padding:4px 12px;border-radius:6px 6px 0 0;font-size:.8rem;font-family:var(--font-mono);margin-bottom:-1px;position:relative;z-index:1}
        @media(max-width:768px){.nav-links{display:none}.article-wrapper{padding:calc(var(--header-height) + 24px) 16px 60px}.article-title{font-size:1.75rem}.tool-grid{grid-template-columns:1fr}.cta-box{padding:28px 20px}.cta-button.secondary{margin-left:0;margin-top:12px}.author-box{flex-direction:column;text-align:center}.article-content pre{padding:16px;border-radius:8px}.article-content h2{font-size:1.4rem}.article-content h3{font-size:1.15rem}}
        @media(max-width:480px){.article-title{font-size:1.5rem}.toc{padding:18px 20px}}
    </style>
</head>
<body>

    <nav class="nav"><div class="nav-inner"><a href="/" class="nav-logo"><span class="nav-logo-icon">NT</span>NexTool</a><ul class="nav-links"><li><a href="/">Home</a></li><li><a href="/free-tools/">Free Tools</a></li><li><a href="/blog/" class="active">Blog</a></li><li><a href="/free-tools/pro-upgrade.html" class="nav-cta">Get Pro</a></li></ul></div></nav>

    <article class="article-wrapper">

        <div class="breadcrumb">
            <a href="/">Home</a> <span>/</span>
            <a href="/blog/">Blog</a> <span>/</span>
            <span>Node.js Best Practices</span>
        </div>

        <header class="article-header">
            <span class="article-category">Node.js</span>
            <h1 class="article-title">Node.js Best Practices: Performance &amp; Security Guide (2026)</h1>
            <p class="article-subtitle">A practical, production-tested guide to Node.js project structure, error handling, security hardening, performance optimization, async patterns, testing strategies, and deployment workflows used by teams shipping real software in 2026.</p>
            <div class="article-meta">
                <span class="article-meta-item">February 14, 2026</span>
                <span class="article-meta-item">24 min read</span>
                <span class="article-meta-item">NexTool Team</span>
            </div>
        </header>

        <div class="toc">
            <div class="toc-title">In This Guide</div>
            <ol class="toc-list">
                <li><a href="#project-structure">Project Structure That Scales</a></li>
                <li><a href="#error-handling">Error Handling Done Right</a></li>
                <li><a href="#security">Security: Helmet, Rate Limiting, Input Validation</a></li>
                <li><a href="#performance">Performance: Clustering, Caching, Streams</a></li>
                <li><a href="#async-patterns">Async Patterns and Concurrency</a></li>
                <li><a href="#testing">Testing Strategy</a></li>
                <li><a href="#environment">Environment Variables and Configuration</a></li>
                <li><a href="#deployment">Production Deployment</a></li>
                <li><a href="#monitoring">Logging and Monitoring</a></li>
                <li><a href="#tools">Related Developer Tools</a></li>
                <li><a href="#faq">Frequently Asked Questions</a></li>
            </ol>
        </div>

        <div class="article-content">

            <p>Node.js powers backends at Netflix, PayPal, LinkedIn, and Walmart. Its event-driven, non-blocking architecture handles concurrent connections efficiently, but building a production-grade Node.js application requires more than just writing code that works. It requires patterns that keep working under load, under attack, and under the pressure of a growing codebase.</p>

            <p>This guide covers the practices that separate a side project from a production system. Every recommendation is something you can apply today, with code examples you can adapt for your own stack.</p>

            <div class="info-box">
                <p><strong>Validate your JSON configs.</strong> The <a href="/free-tools/json-formatter.html">JSON Formatter</a> validates and formats package.json, tsconfig.json, and other config files instantly in your browser.</p>
            </div>

            <h2 id="project-structure">Project Structure That Scales</h2>

            <p>A well-organized project is easier to navigate, test, and maintain. The goal is to separate concerns so that changes in one layer do not ripple through others.</p>

<pre><code>project-root/
  src/
    routes/          # HTTP route definitions
    controllers/     # Request/response handling
    services/        # Business logic
    models/          # Data access and schemas
    middleware/       # Express middleware
    utils/           # Shared helpers
    config/          # Configuration loaders
    types/           # TypeScript type definitions
  test/
    unit/
    integration/
    e2e/
  scripts/           # Build and deploy scripts
  docker/            # Dockerfiles and compose
  package.json
  tsconfig.json
  .env.example</code></pre>

            <h3>Layer Responsibilities</h3>

            <p><strong>Routes</strong> define endpoints and wire them to controllers. They should contain no business logic. <strong>Controllers</strong> parse the request, call the appropriate service, and format the response. <strong>Services</strong> contain the actual business logic and are framework-agnostic, meaning they do not import Express or any HTTP library. <strong>Models</strong> handle data persistence and validation at the schema level.</p>

<pre><code>// src/routes/user.routes.js
import { Router } from 'express';
import { getUser, createUser } from '../controllers/user.controller.js';
import { authenticate } from '../middleware/auth.js';
import { validate } from '../middleware/validate.js';
import { createUserSchema } from '../schemas/user.schema.js';

const router = Router();
router.get('/:id', authenticate, getUser);
router.post('/', authenticate, validate(createUserSchema), createUser);

export default router;</code></pre>

<pre><code>// src/controllers/user.controller.js
import * as userService from '../services/user.service.js';

export async function getUser(req, res, next) {
  try {
    const user = await userService.findById(req.params.id);
    if (!user) return res.status(404).json({ error: 'User not found' });
    res.json(user);
  } catch (err) {
    next(err);
  }
}

export async function createUser(req, res, next) {
  try {
    const user = await userService.create(req.body);
    res.status(201).json(user);
  } catch (err) {
    next(err);
  }
}</code></pre>

            <p>This separation means your services can be unit tested without spinning up an HTTP server, and you can swap Express for Fastify without rewriting your business logic.</p>

            <h2 id="error-handling">Error Handling Done Right</h2>

            <p>Unhandled errors crash your process. Poor error handling leaks internal details to attackers. A solid strategy catches everything and responds predictably.</p>

            <h3>Custom Error Classes</h3>

<pre><code>// src/utils/errors.js
export class AppError extends Error {
  constructor(message, statusCode = 500, isOperational = true) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
}

export class NotFoundError extends AppError {
  constructor(resource = 'Resource') {
    super(`${resource} not found`, 404);
  }
}

export class ValidationError extends AppError {
  constructor(message) {
    super(message, 400);
  }
}

export class UnauthorizedError extends AppError {
  constructor(message = 'Authentication required') {
    super(message, 401);
  }
}</code></pre>

            <h3>Global Error Middleware</h3>

<pre><code>// src/middleware/errorHandler.js
import { AppError } from '../utils/errors.js';
import logger from '../utils/logger.js';

export function errorHandler(err, req, res, next) {
  // Default to 500 internal server error
  let statusCode = err.statusCode || 500;
  let message = err.message || 'Internal server error';

  // Log programming errors with full stack trace
  if (!err.isOperational) {
    logger.error('Unexpected error:', { err, stack: err.stack });
    message = 'Internal server error'; // Hide details from client
  }

  res.status(statusCode).json({
    status: 'error',
    message,
    ...(process.env.NODE_ENV === 'development' &amp;&amp; { stack: err.stack })
  });
}</code></pre>

            <h3>Process-Level Safety</h3>

<pre><code>// src/index.js
process.on('unhandledRejection', (reason) =&gt; {
  logger.error('Unhandled Rejection:', reason);
  // Graceful shutdown
  server.close(() =&gt; process.exit(1));
});

process.on('uncaughtException', (err) =&gt; {
  logger.error('Uncaught Exception:', err);
  // Must exit - state is unreliable
  server.close(() =&gt; process.exit(1));
});</code></pre>

            <div class="info-box warning">
                <div class="info-box-title">Never Swallow Errors Silently</div>
                <p>An empty <code>catch {}</code> block hides bugs. Always log the error at minimum. In production, send it to your monitoring system before deciding whether to recover or terminate.</p>
            </div>

            <h2 id="security">Security: Helmet, Rate Limiting, Input Validation</h2>

            <p>Security is not a feature you add at the end. It is a set of defaults you start with.</p>

            <h3>HTTP Security Headers with Helmet</h3>

<pre><code>import helmet from 'helmet';

app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "https:"],
    }
  },
  crossOriginEmbedderPolicy: true,
  crossOriginOpenerPolicy: true,
  crossOriginResourcePolicy: { policy: "same-origin" },
  hsts: { maxAge: 31536000, includeSubDomains: true, preload: true }
}));</code></pre>

            <h3>Rate Limiting</h3>

<pre><code>import rateLimit from 'express-rate-limit';

const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100,                  // 100 requests per window
  standardHeaders: true,
  legacyHeaders: false,
  message: { error: 'Too many requests, try again later' }
});

const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5,  // Strict limit on auth endpoints
  message: { error: 'Too many login attempts' }
});

app.use('/api/', apiLimiter);
app.use('/api/auth/login', authLimiter);</code></pre>

            <h3>Input Validation with Zod</h3>

<pre><code>import { z } from 'zod';

const createUserSchema = z.object({
  email: z.string().email().max(255),
  password: z.string().min(8).max(128),
  name: z.string().min(1).max(100).trim(),
});

// Validation middleware
function validate(schema) {
  return (req, res, next) =&gt; {
    const result = schema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({
        error: 'Validation failed',
        details: result.error.flatten().fieldErrors
      });
    }
    req.body = result.data; // Use parsed and cleaned data
    next();
  };
}</code></pre>

            <p>Use the <a href="/free-tools/jwt-decoder.html">JWT Decoder</a> to inspect token payloads during development without exposing secrets or using third-party websites.</p>

            <h2 id="performance">Performance: Clustering, Caching, Streams</h2>

            <p>Node.js runs on a single thread by default. To use all CPU cores, you need clustering. To avoid redundant work, you need caching. To handle large data efficiently, you need streams.</p>

            <h3>Clustering with the Cluster Module</h3>

<pre><code>import cluster from 'node:cluster';
import { availableParallelism } from 'node:os';

const numCPUs = availableParallelism();

if (cluster.isPrimary) {
  console.log(`Primary ${process.pid} starting ${numCPUs} workers`);

  for (let i = 0; i &lt; numCPUs; i++) {
    cluster.fork();
  }

  cluster.on('exit', (worker, code) =&gt; {
    console.log(`Worker ${worker.process.pid} exited (code: ${code})`);
    cluster.fork(); // Replace dead workers
  });
} else {
  // Workers share the TCP connection
  app.listen(3000, () =&gt; {
    console.log(`Worker ${process.pid} listening`);
  });
}</code></pre>

            <h3>In-Memory Caching</h3>

<pre><code>import { LRUCache } from 'lru-cache';

const cache = new LRUCache({
  max: 500,               // Maximum 500 entries
  ttl: 1000 * 60 * 5,     // 5-minute TTL
  allowStale: false,
});

async function getCachedUser(id) {
  const cacheKey = `user:${id}`;
  const cached = cache.get(cacheKey);
  if (cached) return cached;

  const user = await db.users.findById(id);
  if (user) cache.set(cacheKey, user);
  return user;
}</code></pre>

            <h3>Streams for Large Data</h3>

<pre><code>import { createReadStream } from 'node:fs';
import { pipeline } from 'node:stream/promises';
import { createGzip } from 'node:zlib';

// Stream a large file instead of loading it into memory
app.get('/export/:id', async (req, res) =&gt; {
  const filePath = await getExportPath(req.params.id);

  res.setHeader('Content-Type', 'application/gzip');
  res.setHeader('Content-Disposition', 'attachment; filename="export.csv.gz"');

  await pipeline(
    createReadStream(filePath),
    createGzip(),
    res
  );
});</code></pre>

            <h2 id="async-patterns">Async Patterns and Concurrency</h2>

            <p>Modern Node.js uses <code>async/await</code> for virtually all asynchronous operations. The remaining skill is knowing how to run things concurrently without overwhelming external services.</p>

            <h3>Concurrent Operations</h3>

<pre><code>// Run independent operations concurrently
const [user, orders, notifications] = await Promise.all([
  userService.findById(userId),
  orderService.findByUser(userId),
  notificationService.getUnread(userId),
]);

// Handle partial failures
const results = await Promise.allSettled([
  sendEmail(user.email),
  sendSMS(user.phone),
  sendPushNotification(user.deviceToken),
]);

const failures = results
  .filter(r =&gt; r.status === 'rejected')
  .map(r =&gt; r.reason);

if (failures.length) logger.warn('Notification failures:', failures);</code></pre>

            <h3>Controlled Concurrency</h3>

<pre><code>// Process items in batches to avoid overwhelming a database
async function processBatch(items, batchSize, fn) {
  const results = [];
  for (let i = 0; i &lt; items.length; i += batchSize) {
    const batch = items.slice(i, i + batchSize);
    const batchResults = await Promise.all(batch.map(fn));
    results.push(...batchResults);
  }
  return results;
}

// Process 1000 users, 50 at a time
await processBatch(userIds, 50, async (id) =&gt; {
  return userService.syncProfile(id);
});</code></pre>

            <p>For validating the configuration files that control your async workers and job queues, the <a href="/free-tools/yaml-editor.html">YAML Editor</a> catches syntax errors before they hit production.</p>

            <h2 id="testing">Testing Strategy</h2>

            <p>A reliable test suite has three layers: fast unit tests for business logic, integration tests for service interactions, and a thin layer of end-to-end tests for critical paths.</p>

<pre><code>// test/unit/services/user.service.test.js
import { describe, it, expect, vi } from 'vitest';
import * as userService from '../../../src/services/user.service.js';
import * as userModel from '../../../src/models/user.model.js';

vi.mock('../../../src/models/user.model.js');

describe('userService.create', () =&gt; {
  it('hashes the password before saving', async () =&gt; {
    userModel.create.mockResolvedValue({ id: '1', email: 'a@b.com' });

    const result = await userService.create({
      email: 'a@b.com',
      password: 'securepass123'
    });

    const savedArg = userModel.create.mock.calls[0][0];
    expect(savedArg.password).not.toBe('securepass123');
    expect(savedArg.password).toMatch(/^\$2[aby]\$/); // bcrypt hash
    expect(result.id).toBe('1');
  });

  it('throws on duplicate email', async () =&gt; {
    userModel.create.mockRejectedValue({ code: 11000 });
    await expect(userService.create({ email: 'dup@b.com', password: 'x' }))
      .rejects.toThrow('Email already exists');
  });
});</code></pre>

<pre><code>// test/integration/routes/user.routes.test.js
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import request from 'supertest';
import { app } from '../../../src/app.js';
import { setupTestDB, teardownTestDB } from '../../helpers/db.js';

beforeAll(() =&gt; setupTestDB());
afterAll(() =&gt; teardownTestDB());

describe('POST /api/users', () =&gt; {
  it('returns 201 with valid data', async () =&gt; {
    const res = await request(app)
      .post('/api/users')
      .send({ email: 'new@example.com', password: 'Str0ng!Pass', name: 'Test' })
      .set('Authorization', `Bearer ${testToken}`);

    expect(res.status).toBe(201);
    expect(res.body).toHaveProperty('id');
    expect(res.body.email).toBe('new@example.com');
  });

  it('returns 400 for invalid email', async () =&gt; {
    const res = await request(app)
      .post('/api/users')
      .send({ email: 'not-an-email', password: 'test', name: 'Test' })
      .set('Authorization', `Bearer ${testToken}`);

    expect(res.status).toBe(400);
  });
});</code></pre>

            <p>Scaffold your ESLint configuration with testing rules using the <a href="/free-tools/eslint-config-generator.html">ESLint Config Generator</a>. It supports Vitest, Jest, and Mocha presets.</p>

            <h2 id="environment">Environment Variables and Configuration</h2>

            <p>Configuration should come from the environment, not from hardcoded values. This lets the same code run in development, staging, and production with different settings.</p>

<pre><code>// src/config/index.js
import { z } from 'zod';

const envSchema = z.object({
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  PORT: z.coerce.number().default(3000),
  DATABASE_URL: z.string().url(),
  REDIS_URL: z.string().url().optional(),
  JWT_SECRET: z.string().min(32),
  JWT_EXPIRY: z.string().default('15m'),
  CORS_ORIGIN: z.string().default('http://localhost:3000'),
  LOG_LEVEL: z.enum(['error', 'warn', 'info', 'debug']).default('info'),
});

const parsed = envSchema.safeParse(process.env);

if (!parsed.success) {
  console.error('Invalid environment variables:', parsed.error.flatten());
  process.exit(1);
}

export const config = Object.freeze(parsed.data);</code></pre>

            <p>The <a href="/free-tools/env-file-editor.html">Env File Editor</a> helps you manage .env files with syntax highlighting, validation, and the ability to compare different environment configurations side by side.</p>

            <div class="info-box success">
                <div class="info-box-title">Ship a .env.example</div>
                <p>Always include a <code>.env.example</code> file in your repository with all required variables and placeholder values. New developers and CI systems can use it as a template without guessing what variables are needed.</p>
            </div>

            <h2 id="deployment">Production Deployment</h2>

            <h3>Multi-Stage Dockerfile</h3>

<pre><code>FROM node:22-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:22-alpine AS production
WORKDIR /app
RUN addgroup -g 1001 appgroup &amp;&amp; adduser -u 1001 -G appgroup -s /bin/sh -D appuser
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/package*.json ./
RUN npm ci --only=production &amp;&amp; npm cache clean --force
USER appuser
EXPOSE 3000
HEALTHCHECK --interval=30s --timeout=3s CMD wget -qO- http://localhost:3000/health || exit 1
CMD ["node", "dist/index.js"]</code></pre>

            <h3>Graceful Shutdown</h3>

<pre><code>function gracefulShutdown(signal) {
  console.log(`${signal} received. Starting graceful shutdown...`);

  server.close(async () =&gt; {
    console.log('HTTP server closed');

    // Close database connections
    await db.disconnect();
    console.log('Database disconnected');

    // Close Redis
    await redis.quit();
    console.log('Redis disconnected');

    process.exit(0);
  });

  // Force exit after 30 seconds
  setTimeout(() =&gt; {
    console.error('Forced shutdown after timeout');
    process.exit(1);
  }, 30000);
}

process.on('SIGTERM', () =&gt; gracefulShutdown('SIGTERM'));
process.on('SIGINT', () =&gt; gracefulShutdown('SIGINT'));</code></pre>

            <p>Generate your Docker Compose configuration for Node.js with databases, Redis, and reverse proxies using the <a href="/free-tools/docker-compose-generator.html">Docker Compose Generator</a>.</p>

            <h2 id="monitoring">Logging and Monitoring</h2>

            <p>In production, <code>console.log</code> is not enough. Use a structured logging library that outputs JSON, so your log aggregator can parse, search, and alert on specific fields.</p>

<pre><code>import pino from 'pino';

const logger = pino({
  level: config.LOG_LEVEL,
  transport: config.NODE_ENV === 'development'
    ? { target: 'pino-pretty' }
    : undefined,
  serializers: {
    err: pino.stdSerializers.err,
    req: pino.stdSerializers.req,
    res: pino.stdSerializers.res,
  }
});

// Usage
logger.info({ userId: user.id, action: 'login' }, 'User logged in');
logger.error({ err, orderId }, 'Payment processing failed');</code></pre>

            <h3>Health Check Endpoint</h3>

<pre><code>app.get('/health', async (req, res) =&gt; {
  const checks = {
    uptime: process.uptime(),
    timestamp: Date.now(),
    database: 'unknown',
    redis: 'unknown',
  };

  try {
    await db.raw('SELECT 1');
    checks.database = 'healthy';
  } catch {
    checks.database = 'unhealthy';
  }

  try {
    await redis.ping();
    checks.redis = 'healthy';
  } catch {
    checks.redis = 'unhealthy';
  }

  const isHealthy = checks.database === 'healthy';
  res.status(isHealthy ? 200 : 503).json(checks);
});</code></pre>

            <!-- Tools Section -->
            <h2 id="tools">Related Developer Tools</h2>

            <p>Free browser-based tools for your Node.js development workflow.</p>

            <div class="tool-grid">
                <a href="/free-tools/json-formatter.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F4CB;</div>
                    <div class="tool-card-name">JSON Formatter</div>
                    <div class="tool-card-desc">Format and validate package.json, tsconfig.json, and API response data. Catches syntax errors instantly.</div>
                </a>
                <a href="/free-tools/env-file-editor.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F511;</div>
                    <div class="tool-card-name">Env File Editor</div>
                    <div class="tool-card-desc">Edit .env files with syntax highlighting, validation, and side-by-side environment comparison.</div>
                </a>
                <a href="/free-tools/eslint-config-generator.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F6E0;</div>
                    <div class="tool-card-name">ESLint Config Generator</div>
                    <div class="tool-card-desc">Generate ESLint configurations for Node.js with TypeScript, Prettier, and testing framework presets.</div>
                </a>
                <a href="/free-tools/package-json-generator.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F4E6;</div>
                    <div class="tool-card-name">package.json Generator</div>
                    <div class="tool-card-desc">Scaffold a properly structured package.json with scripts, dependencies, and metadata fields.</div>
                </a>
                <a href="/free-tools/docker-compose-generator.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F433;</div>
                    <div class="tool-card-name">Docker Compose Generator</div>
                    <div class="tool-card-desc">Generate Docker Compose files for Node.js with databases, Redis, and service configurations.</div>
                </a>
                <a href="/free-tools/jwt-decoder.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F50F;</div>
                    <div class="tool-card-name">JWT Decoder</div>
                    <div class="tool-card-desc">Inspect JWT token headers and payloads. Debug authentication issues without exposing secrets.</div>
                </a>
            </div>

            <hr>

            <!-- FAQ Section -->
            <div class="faq-section" id="faq">
                <h2>Frequently Asked Questions</h2>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>What is the recommended project structure for a Node.js application?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>A production Node.js project should separate concerns into distinct layers. Use a src directory containing routes (HTTP layer), controllers (request handling), services (business logic), models (data access), middleware (cross-cutting concerns), and utils (shared helpers). Keep configuration in a dedicated config directory that reads from environment variables. Place tests in a parallel test directory that mirrors the src structure. This separation makes code testable, allows teams to work on different layers independently, and makes it clear where new functionality belongs.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>How should I handle errors in Node.js?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Use a centralized error-handling strategy. Create custom error classes that extend the built-in Error class with properties like statusCode and isOperational. Catch all async errors using try-catch in async functions or a wrapper middleware like express-async-errors. Register a global error-handling middleware in Express that formats the response based on the error type. For unhandled rejections and uncaught exceptions, log the error, notify your monitoring system, and perform a graceful shutdown. Operational errors like validation failures should return appropriate HTTP status codes. Programming errors should log a stack trace and restart the process.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>What are the most important security practices for Node.js?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>The most critical Node.js security practices are: use Helmet to set secure HTTP headers including Content-Security-Policy and X-Content-Type-Options; implement rate limiting with a library like express-rate-limit to prevent brute-force and DDoS attacks; validate and sanitize all user input using a schema validation library such as Joi or Zod; use parameterized queries or an ORM to prevent SQL injection; store secrets in environment variables and never commit them to version control; keep dependencies updated and audit them regularly with npm audit; implement proper authentication with bcrypt for password hashing and JWTs with short expiration times; and use HTTPS in production with TLS 1.3.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>How can I improve Node.js performance in production?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Use the cluster module or PM2 to run one worker process per CPU core, multiplying throughput on multi-core machines. Implement caching at multiple levels: in-memory with a Map or LRU cache for hot data, Redis for shared cache across instances, and HTTP caching headers for client-side caching. Use Node.js streams for processing large files or data sets instead of loading everything into memory. Enable gzip or Brotli compression for HTTP responses. Use connection pooling for database connections. Profile your application with the built-in inspector or clinic.js to find actual bottlenecks before optimizing. Avoid synchronous operations on the main thread and offload CPU-intensive work to worker threads.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>Should I use callbacks, Promises, or async/await in Node.js?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Use async/await for virtually all asynchronous code in modern Node.js. It produces code that reads like synchronous logic, makes error handling straightforward with try-catch, and avoids callback nesting. Promises are the underlying mechanism and are still useful for concurrent operations with Promise.all, Promise.allSettled, and Promise.race. Callbacks should only appear when working with older libraries that have not been promisified, and you can convert them using util.promisify or the built-in promise-based APIs that Node.js now provides for fs, timers, streams, and other core modules. All new Node.js core APIs ship with promise support by default.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>What is the best way to deploy a Node.js application?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Containerize your application with Docker using a multi-stage build: a build stage that installs all dependencies and compiles TypeScript, and a production stage that copies only the built output and production dependencies. Use a .dockerignore file to exclude node_modules, tests, and development files. Run the container with a non-root user for security. In production, use an orchestrator like Kubernetes or a managed platform like AWS ECS, Google Cloud Run, or Railway. Set up health check endpoints for liveness and readiness probes. Use environment variables for configuration and a process manager like PM2 inside the container only if you are not using an orchestrator that handles restarts. Implement graceful shutdown by listening for SIGTERM and draining active connections before exiting.</p>
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <!-- Author -->
        <div class="author-box">
            <div class="author-avatar">NT</div>
            <div class="author-info">
                <h4>NexTool Team</h4>
                <p>We build free developer tools including JSON formatters, environment editors, Docker generators, and 245+ more. All browser-based, no signup required.</p>
            </div>
        </div>

        <!-- Bottom CTA -->
        <div class="cta-box">
            <h3>245+ Developer Tools, One Place</h3>
            <p>NexTool Pro ($29) unlocks clean output, enhanced features, and unlimited workspace across every tool. $29 founding member price (regular $49). One payment, lifetime access.</p>
            <a href="/free-tools/pro-upgrade.html" class="cta-button">Get NexTool Pro &mdash; $29</a>
            <a href="/free-tools/" class="cta-button secondary">Try Free Tools</a>
        </div>

    </article>

    
<!-- AUTO-LINKED by NexTool Engine -->
<div style="margin:2rem 0;padding:1.5rem;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius)">
<p style="font-weight:600;margin-bottom:.5rem">Related Tools</p>
<p><a href="/free-tools/box-shadow-generator.html" style="color:var(--primary);text-decoration:none">CSS Box Shadow Generator</a>  <a href="/free-tools/emoji-picker.html" style="color:var(--primary);text-decoration:none">Emoji Picker & Search</a>  <a href="/free-tools/git-diff-viewer.html" style="color:var(--primary);text-decoration:none">Free Git Diff Viewer</a></p>
</div>
<footer class="footer"><div class="footer-inner"><div class="footer-links"><a href="/">Home</a><a href="/free-tools/">Free Tools</a><a href="/blog/">Blog</a><a href="mailto:christianjunbucher@gmail.com">Contact</a></div><p>&copy; 2026 NexTool. All rights reserved. 245+ free developer tools.</p></div></footer>

    <script>
        function toggleFAQ(button) {
            const item = button.parentElement;
            const answer = item.querySelector('.faq-answer');
            const isOpen = item.classList.contains('open');
            document.querySelectorAll('.faq-item').forEach(faq => {
                faq.classList.remove('open');
                faq.querySelector('.faq-answer').style.maxHeight = null;
            });
            if (!isOpen) {
                item.classList.add('open');
                answer.style.maxHeight = answer.scrollHeight + 'px';
            }
        }
    </script>

    <script defer src="/js/analytics-lite.js"></script>
    <script defer src="/js/revenue.js"></script>
    <script defer src="/js/lead-capture.js"></script>
</body>
</html>