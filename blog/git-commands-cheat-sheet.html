<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Essential Git Commands Every Developer Should Know | NexTool</title>
    <meta name="description" content="Master 15+ essential Git commands with practical examples. Covers init, clone, branch, merge, rebase, stash, cherry-pick, and real-world workflows for feature branches and hotfixes.">
    <meta name="keywords" content="git commands, git cheat sheet, git branch, git merge, git rebase, git stash, git cherry-pick, git workflow, feature branch workflow, git tutorial">
    <meta name="author" content="NexTool Team">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://nextool.app/blog/git-commands-cheat-sheet.html">

    <!-- Open Graph -->
    <meta property="og:type" content="article">
    <meta property="og:title" content="Essential Git Commands Every Developer Should Know">
    <meta property="og:description" content="Master 15+ essential Git commands with practical examples. Covers init, clone, branch, merge, rebase, stash, cherry-pick, and real-world workflows.">
    <meta property="og:url" content="https://nextool.app/blog/git-commands-cheat-sheet.html">
    <meta property="og:site_name" content="NexTool">
    <meta property="og:image" content="https://nextool.app/assets/images/blog/git-commands-cheat-sheet-og.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="article:published_time" content="2026-02-13T09:00:00Z">
    <meta property="article:modified_time" content="2026-02-13T09:00:00Z">
    <meta property="article:author" content="NexTool Team">
    <meta property="article:section" content="Developer Tools">
    <meta property="article:tag" content="Git">
    <meta property="article:tag" content="Version Control">
    <meta property="article:tag" content="Developer Tools">

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Essential Git Commands Every Developer Should Know">
    <meta name="twitter:description" content="Master 15+ essential Git commands with practical examples. Covers branches, merging, rebasing, stashing, and real-world workflows.">
    <meta name="twitter:image" content="https://nextool.app/assets/images/blog/git-commands-cheat-sheet-og.png">

    <!-- JSON-LD: Article -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Article",
        "headline": "Essential Git Commands Every Developer Should Know",
        "description": "Master 15+ essential Git commands with practical examples. Covers init, clone, branch, merge, rebase, stash, cherry-pick, and real-world workflows for feature branches and hotfixes.",
        "image": "https://nextool.app/assets/images/blog/git-commands-cheat-sheet-og.png",
        "author": {
            "@type": "Organization",
            "name": "NexTool Team",
            "url": "https://nextool.app"
        },
        "publisher": {
            "@type": "Organization",
            "name": "NexTool",
            "logo": {
                "@type": "ImageObject",
                "url": "https://nextool.app/assets/images/logo.png"
            }
        },
        "datePublished": "2026-02-13T09:00:00Z",
        "dateModified": "2026-02-13T09:00:00Z",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://nextool.app/blog/git-commands-cheat-sheet.html"
        },
        "wordCount": 2800,
        "keywords": ["git", "git commands", "git cheat sheet", "git branch", "git merge", "git rebase", "git stash", "git workflow"]
    }
    </script>

    <!-- JSON-LD: BreadcrumbList -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BreadcrumbList",
        "itemListElement": [
            {
                "@type": "ListItem",
                "position": 1,
                "name": "Home",
                "item": "https://nextool.app"
            },
            {
                "@type": "ListItem",
                "position": 2,
                "name": "Blog",
                "item": "https://nextool.app/blog/"
            },
            {
                "@type": "ListItem",
                "position": 3,
                "name": "Git Commands Cheat Sheet",
                "item": "https://nextool.app/blog/git-commands-cheat-sheet.html"
            }
        ]
    }
    </script>

    <!-- JSON-LD: FAQPage -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "FAQPage",
        "mainEntity": [
            {
                "@type": "Question",
                "name": "What is the difference between git merge and git rebase?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Git merge creates a new merge commit that combines two branches, preserving the full history of both branches. Git rebase replays commits from one branch on top of another, creating a linear history without merge commits. Use merge for shared branches and when you want a complete history of when branches were integrated. Use rebase for local feature branches before merging to keep the history clean. Never rebase commits that have been pushed to a shared remote branch, as it rewrites history and causes conflicts for other developers."
                }
            },
            {
                "@type": "Question",
                "name": "How do I undo the last git commit without losing changes?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Use git reset --soft HEAD~1 to undo the last commit while keeping all changes staged and ready to commit again. Use git reset --mixed HEAD~1 (or just git reset HEAD~1) to undo the commit and unstage the changes, keeping them in your working directory. Use git reset --hard HEAD~1 to completely discard the commit and all changes. If the commit has already been pushed, use git revert HEAD instead, which creates a new commit that undoes the changes without rewriting history."
                }
            },
            {
                "@type": "Question",
                "name": "What is git stash and when should I use it?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Git stash temporarily saves uncommitted changes (both staged and unstaged) so you can switch branches or pull updates without committing incomplete work. Run git stash to save changes, switch branches and do your work, then run git stash pop to restore your changes. Use git stash list to see all stashes, git stash apply stash@{n} to apply a specific stash without removing it, and git stash drop stash@{n} to delete a stash. It is useful when you need to quickly switch context, pull remote changes, or test something on a clean working directory."
                }
            },
            {
                "@type": "Question",
                "name": "What is the difference between git pull and git fetch?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Git fetch downloads new commits and references from the remote repository but does not modify your working directory or current branch. It updates your remote-tracking branches (like origin/main) so you can review changes before integrating them. Git pull is essentially git fetch followed by git merge. It downloads remote changes and immediately merges them into your current branch. Using git fetch first is safer because it lets you inspect incoming changes with git log or git diff before merging. Many teams recommend git fetch followed by git merge or git rebase for more control."
                }
            },
            {
                "@type": "Question",
                "name": "How do I use git cherry-pick?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Git cherry-pick applies a specific commit from one branch onto your current branch. Use git cherry-pick <commit-hash> to apply a single commit. Use git cherry-pick <hash1> <hash2> <hash3> for multiple commits, or git cherry-pick <start>..<end> for a range. Common use cases include applying a bug fix from a development branch to a release branch without merging everything, recovering a commit from a deleted branch, and selectively moving features between branches. If conflicts occur during cherry-pick, resolve them manually, stage the files, and run git cherry-pick --continue."
                }
            },
            {
                "@type": "Question",
                "name": "What is the best Git branching strategy for teams?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "The best strategy depends on team size and release cadence. For most teams, trunk-based development with short-lived feature branches works well: developers create feature branches from main, keep them small (1-3 days of work), and merge via pull requests. GitHub Flow is a lightweight variant: main is always deployable, features branch from main, and merge back via PR. Git Flow (with develop, release, and hotfix branches) suits teams with scheduled releases. The key principles are: keep branches short-lived, merge frequently, protect your main branch with CI checks, and delete branches after merging."
                }
            }
        ]
    }
    </script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

    <style>
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg: #050508;
            --surface: #0a0a0f;
            --surface-2: #1a1a24;
            --surface-3: #232330;
            --primary: #6366f1;
            --primary-hover: #818cf8;
            --accent: #a855f7;
            --accent-hover: #c084fc;
            --text: #e2e8f0;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --border: #1e1e2e;
            --success: #22c55e;
            --warning: #f59e0b;
            --error: #ef4444;
            --code-bg: #0d0d14;
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --font-mono: 'JetBrains Mono', 'Fira Code', monospace;
            --max-width: 800px;
            --header-height: 64px;
        }

        html { scroll-behavior: smooth; -webkit-text-size-adjust: 100%; }
        body { font-family: var(--font-sans); background: var(--bg); color: var(--text); line-height: 1.75; font-size: 16px; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; overflow-x: hidden; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg); }
        ::-webkit-scrollbar-thumb { background: var(--surface-3); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

        .nav { position: fixed; top: 0; left: 0; right: 0; height: var(--header-height); background: rgba(5, 5, 8, 0.85); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-bottom: 1px solid var(--border); z-index: 1000; display: flex; align-items: center; justify-content: center; }
        .nav-inner { width: 100%; max-width: 1200px; padding: 0 24px; display: flex; align-items: center; justify-content: space-between; }
        .nav-logo { display: flex; align-items: center; gap: 10px; text-decoration: none; color: var(--text); font-weight: 700; font-size: 1.25rem; }
        .nav-logo-icon { width: 32px; height: 32px; background: linear-gradient(135deg, var(--primary), var(--accent)); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 0.875rem; font-weight: 800; color: #fff; }
        .nav-links { display: flex; align-items: center; gap: 28px; list-style: none; }
        .nav-links a { color: var(--text-secondary); text-decoration: none; font-size: 0.9rem; font-weight: 500; transition: color 0.2s; }
        .nav-links a:hover { color: var(--text); }
        .nav-cta { background: var(--primary); color: #fff !important; padding: 8px 20px; border-radius: 8px; font-weight: 600; transition: background 0.2s, transform 0.2s; }
        .nav-cta:hover { background: var(--primary-hover); transform: translateY(-1px); }

        .article-wrapper { max-width: var(--max-width); margin: 0 auto; padding: calc(var(--header-height) + 48px) 24px 80px; }
        .breadcrumb { display: flex; align-items: center; gap: 8px; margin-bottom: 32px; font-size: 0.85rem; color: var(--text-muted); flex-wrap: wrap; }
        .breadcrumb a { color: var(--text-secondary); text-decoration: none; transition: color 0.2s; }
        .breadcrumb a:hover { color: var(--primary); }

        .article-header { margin-bottom: 48px; padding-bottom: 32px; border-bottom: 1px solid var(--border); }
        .article-category { display: inline-block; background: rgba(168, 85, 247, 0.12); color: var(--accent); padding: 4px 14px; border-radius: 20px; font-size: 0.8rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 16px; }
        .article-title { font-size: clamp(2rem, 5vw, 3rem); font-weight: 800; line-height: 1.15; color: var(--text); margin-bottom: 16px; letter-spacing: -0.03em; }
        .article-subtitle { font-size: 1.2rem; color: var(--text-secondary); line-height: 1.6; margin-bottom: 24px; }
        .article-meta { display: flex; align-items: center; gap: 20px; color: var(--text-muted); font-size: 0.875rem; flex-wrap: wrap; }
        .article-meta-item { display: flex; align-items: center; gap: 6px; }

        .toc { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 24px 28px; margin-bottom: 48px; }
        .toc-title { font-size: 0.85rem; font-weight: 700; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 16px; }
        .toc-list { list-style: none; counter-reset: toc; }
        .toc-list li { counter-increment: toc; margin-bottom: 8px; }
        .toc-list li a { color: var(--text-secondary); text-decoration: none; font-size: 0.925rem; display: flex; align-items: baseline; gap: 10px; transition: color 0.2s, padding-left 0.2s; padding: 4px 0; }
        .toc-list li a::before { content: counter(toc, decimal-leading-zero); color: var(--text-muted); font-size: 0.8rem; font-family: var(--font-mono); min-width: 20px; }
        .toc-list li a:hover { color: var(--primary); padding-left: 4px; }

        .article-content h2 { font-size: 1.75rem; font-weight: 700; color: var(--text); margin-top: 56px; margin-bottom: 20px; letter-spacing: -0.02em; line-height: 1.3; padding-top: 16px; border-top: 1px solid var(--border); }
        .article-content h2:first-child { margin-top: 0; padding-top: 0; border-top: none; }
        .article-content h3 { font-size: 1.3rem; font-weight: 600; color: var(--text); margin-top: 36px; margin-bottom: 14px; line-height: 1.35; }
        .article-content h4 { font-size: 1.1rem; font-weight: 600; color: var(--text-secondary); margin-top: 28px; margin-bottom: 12px; }
        .article-content p { margin-bottom: 20px; color: var(--text-secondary); line-height: 1.8; }
        .article-content a { color: var(--primary); text-decoration: none; border-bottom: 1px solid transparent; transition: border-color 0.2s; }
        .article-content a:hover { border-bottom-color: var(--primary); }
        .article-content strong { color: var(--text); font-weight: 600; }
        .article-content ul, .article-content ol { margin-bottom: 20px; padding-left: 24px; color: var(--text-secondary); }
        .article-content li { margin-bottom: 10px; line-height: 1.7; }
        .article-content li::marker { color: var(--primary); }
        .article-content blockquote { border-left: 3px solid var(--accent); background: var(--surface); padding: 16px 24px; margin: 28px 0; border-radius: 0 8px 8px 0; font-style: italic; color: var(--text-secondary); }
        .article-content blockquote p:last-child { margin-bottom: 0; }
        .article-content hr { border: none; border-top: 1px solid var(--border); margin: 48px 0; }

        .article-content pre { background: var(--code-bg); border: 1px solid var(--border); border-radius: 12px; padding: 20px 24px; overflow-x: auto; margin: 24px 0; }
        .article-content pre code { font-family: var(--font-mono); font-size: 0.875rem; line-height: 1.65; color: var(--text); background: none; padding: 0; border-radius: 0; }
        .article-content code { font-family: var(--font-mono); font-size: 0.85em; background: var(--surface); color: var(--accent); padding: 2px 8px; border-radius: 5px; }
        .code-label { display: inline-block; background: var(--surface-2); color: var(--text-muted); font-family: var(--font-mono); font-size: 0.75rem; padding: 2px 10px; border-radius: 6px 6px 0 0; margin-bottom: -1px; position: relative; top: 1px; }

        .info-box { background: rgba(99, 102, 241, 0.08); border: 1px solid rgba(99, 102, 241, 0.2); border-radius: 12px; padding: 20px 24px; margin: 28px 0; }
        .info-box.warning { background: rgba(245, 158, 11, 0.08); border-color: rgba(245, 158, 11, 0.2); }
        .info-box.danger { background: rgba(239, 68, 68, 0.08); border-color: rgba(239, 68, 68, 0.2); }
        .info-box.success { background: rgba(34, 197, 94, 0.08); border-color: rgba(34, 197, 94, 0.2); }
        .info-box-title { font-weight: 700; margin-bottom: 8px; font-size: 0.9rem; display: flex; align-items: center; gap: 8px; }
        .info-box p { color: var(--text-secondary); font-size: 0.925rem; margin-bottom: 0; }

        .tool-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 16px; margin: 28px 0; }
        .tool-card { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 20px; text-decoration: none; color: var(--text); transition: border-color 0.2s, transform 0.2s, box-shadow 0.2s; display: flex; flex-direction: column; gap: 8px; }
        .tool-card:hover { border-color: var(--primary); transform: translateY(-2px); box-shadow: 0 8px 24px rgba(99, 102, 241, 0.1); }
        .tool-card-icon { font-size: 1.5rem; margin-bottom: 4px; }
        .tool-card-name { font-weight: 600; font-size: 0.95rem; }
        .tool-card-desc { font-size: 0.825rem; color: var(--text-muted); line-height: 1.5; }

        .cta-box { background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(168, 85, 247, 0.1)); border: 1px solid rgba(99, 102, 241, 0.25); border-radius: 16px; padding: 40px 32px; text-align: center; margin: 48px 0; }
        .cta-box h3 { font-size: 1.5rem; font-weight: 700; margin-bottom: 12px; color: var(--text); }
        .cta-box p { color: var(--text-secondary); margin-bottom: 24px; max-width: 500px; margin-left: auto; margin-right: auto; }
        .cta-button { display: inline-flex; align-items: center; gap: 8px; background: var(--primary); color: #fff; padding: 14px 32px; border-radius: 10px; text-decoration: none; font-weight: 600; font-size: 1rem; transition: background 0.2s, transform 0.2s, box-shadow 0.2s; }
        .cta-button:hover { background: var(--primary-hover); transform: translateY(-2px); box-shadow: 0 8px 32px rgba(99, 102, 241, 0.3); }
        .cta-button.secondary { background: transparent; border: 1px solid var(--primary); color: var(--primary); margin-left: 12px; }
        .cta-button.secondary:hover { background: rgba(99, 102, 241, 0.1); }

        .faq-section { margin-top: 56px; padding-top: 32px; border-top: 1px solid var(--border); }
        .faq-section h2 { margin-top: 0 !important; padding-top: 0 !important; border-top: none !important; }
        .faq-item { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; margin-bottom: 12px; overflow: hidden; }
        .faq-question { width: 100%; background: none; border: none; color: var(--text); padding: 20px 24px; font-size: 1rem; font-weight: 600; text-align: left; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-family: var(--font-sans); transition: background 0.2s; }
        .faq-question:hover { background: var(--surface-2); }
        .faq-question .icon { transition: transform 0.3s; font-size: 1.25rem; color: var(--text-muted); flex-shrink: 0; margin-left: 16px; }
        .faq-item.open .faq-question .icon { transform: rotate(45deg); }
        .faq-answer { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; }
        .faq-answer-inner { padding: 0 24px 20px; color: var(--text-secondary); line-height: 1.7; }

        .author-box { display: flex; align-items: center; gap: 20px; background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 24px; margin: 48px 0; }
        .author-avatar { width: 64px; height: 64px; background: linear-gradient(135deg, var(--primary), var(--accent)); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; font-weight: 700; color: #fff; flex-shrink: 0; }
        .author-info h4 { font-weight: 600; margin-bottom: 4px; }
        .author-info p { color: var(--text-muted); font-size: 0.875rem; margin: 0; line-height: 1.5; }

        .footer { border-top: 1px solid var(--border); padding: 48px 24px; text-align: center; color: var(--text-muted); font-size: 0.85rem; }
        .footer-inner { max-width: 1200px; margin: 0 auto; }
        .footer-links { display: flex; justify-content: center; gap: 24px; margin-bottom: 20px; flex-wrap: wrap; }
        .footer-links a { color: var(--text-secondary); text-decoration: none; transition: color 0.2s; }
        .footer-links a:hover { color: var(--primary); }

        @media (max-width: 768px) {
            .nav-links { display: none; }
            .article-wrapper { padding: calc(var(--header-height) + 24px) 16px 60px; }
            .article-title { font-size: 1.75rem; }
            .tool-grid { grid-template-columns: 1fr; }
            .cta-box { padding: 28px 20px; }
            .cta-button.secondary { margin-left: 0; margin-top: 12px; }
            .author-box { flex-direction: column; text-align: center; }
            .article-content pre { padding: 16px; border-radius: 8px; }
            .article-content h2 { font-size: 1.4rem; }
            .article-content h3 { font-size: 1.15rem; }
        }
        @media (max-width: 480px) {
            .article-title { font-size: 1.5rem; }
            .toc { padding: 18px 20px; }
        }
    </style>
</head>
<body>

    <!-- Navigation -->
    <nav class="nav">
        <div class="nav-inner">
            <a href="/" class="nav-logo">
                <span class="nav-logo-icon">NT</span>
                NexTool
            </a>
            <ul class="nav-links">
                <li><a href="/">Home</a></li>
                <li><a href="/free-tools/">Free Tools</a></li>
                <li><a href="/blog/" class="active">Blog</a></li>
                <li><a href="/free-tools/pro-upgrade.html" class="nav-cta">Get Pro</a></li>
            </ul>
        </div>
    </nav>

    <!-- Article -->
    <article class="article-wrapper">

        <!-- Breadcrumb -->
        <div class="breadcrumb">
            <a href="/">Home</a> <span>/</span>
            <a href="/blog/">Blog</a> <span>/</span>
            <span>Git Commands Cheat Sheet</span>
        </div>

        <!-- Header -->
        <header class="article-header">
            <span class="article-category">Developer Tools</span>
            <h1 class="article-title">Essential Git Commands Every Developer Should Know</h1>
            <p class="article-subtitle">A practical reference covering the 15+ Git commands you will use daily, complete with real-world examples and common workflows for feature branches, hotfixes, and team collaboration.</p>
            <div class="article-meta">
                <span class="article-meta-item">February 13, 2026</span>
                <span class="article-meta-item">24 min read</span>
                <span class="article-meta-item">NexTool Team</span>
            </div>
        </header>

        <!-- Table of Contents -->
        <div class="toc">
            <div class="toc-title">In This Guide</div>
            <ol class="toc-list">
                <li><a href="#setup">Repository Setup: init, clone, remote</a></li>
                <li><a href="#branching">Branching: branch, checkout, switch</a></li>
                <li><a href="#staging">Staging and Committing: add, commit, status</a></li>
                <li><a href="#remote">Remote Operations: push, pull, fetch</a></li>
                <li><a href="#merging">Merging and Rebasing: merge, rebase</a></li>
                <li><a href="#stash">Stashing Changes: stash</a></li>
                <li><a href="#history">History and Inspection: log, diff, show</a></li>
                <li><a href="#undo">Undoing Changes: reset, revert, cherry-pick</a></li>
                <li><a href="#workflows">Real-World Workflows</a></li>
                <li><a href="#tools">Related Developer Tools</a></li>
                <li><a href="#faq">Frequently Asked Questions</a></li>
            </ol>
        </div>

        <!-- Content -->
        <div class="article-content">

            <p>
                Git is the version control system behind virtually every software project. Whether you are working solo or on a team of hundreds, the same core commands handle 95% of your daily work. This guide covers those commands with practical, copy-paste examples instead of abstract theory.
            </p>

            <p>
                Every example in this article uses real directory names, realistic branch names, and common scenarios. If you want to visualize the differences between file versions as you work through these examples, the <a href="/free-tools/diff-checker.html">Diff Checker</a> tool makes that straightforward.
            </p>

            <!-- Section 1: Setup -->
            <h2 id="setup">Repository Setup: init, clone, remote</h2>

            <p>
                Every Git workflow starts with either creating a new repository or cloning an existing one. These three commands handle that.
            </p>

            <h3>git init</h3>

            <p>
                Creates a new Git repository in the current directory. This adds a hidden <code>.git</code> folder that stores all version history.
            </p>

            <pre><code># Create a new project and initialize Git
mkdir my-project
cd my-project
git init

# Output: Initialized empty Git repository in /home/user/my-project/.git/</code></pre>

            <p>
                After initializing, you will typically create a <code>.gitignore</code> file to exclude build artifacts, dependencies, and environment files. You can generate one instantly with the <a href="/free-tools/gitignore-generator.html">Gitignore Generator</a> tool.
            </p>

            <h3>git clone</h3>

            <p>
                Downloads an existing repository, including its full history, and sets up the remote connection automatically.
            </p>

            <pre><code># Clone via HTTPS
git clone https://github.com/user/project.git

# Clone via SSH (requires SSH key setup)
git clone git@github.com:user/project.git

# Clone into a specific directory
git clone https://github.com/user/project.git my-local-name

# Shallow clone (only latest commit, faster for large repos)
git clone --depth 1 https://github.com/user/project.git</code></pre>

            <h3>git remote</h3>

            <p>
                Manages connections to remote repositories. After <code>git clone</code>, a remote named <code>origin</code> is created automatically.
            </p>

            <pre><code># List configured remotes
git remote -v

# Add a new remote
git remote add upstream https://github.com/original/project.git

# Change a remote URL (e.g., HTTPS to SSH)
git remote set-url origin git@github.com:user/project.git

# Remove a remote
git remote remove upstream</code></pre>

            <!-- Section 2: Branching -->
            <h2 id="branching">Branching: branch, checkout, switch</h2>

            <p>
                Branches are Git's mechanism for parallel development. They are lightweight pointers to commits, so creating and switching branches is nearly instant.
            </p>

            <h3>git branch</h3>

            <pre><code># List local branches (asterisk marks current branch)
git branch

# List all branches including remote
git branch -a

# Create a new branch (does not switch to it)
git branch feature/user-auth

# Delete a branch (must not be on that branch)
git branch -d feature/user-auth

# Force delete an unmerged branch
git branch -D feature/abandoned-experiment

# Rename current branch
git branch -m new-branch-name</code></pre>

            <h3>git checkout vs git switch</h3>

            <p>
                The <code>git switch</code> command was introduced in Git 2.23 as a clearer alternative to <code>git checkout</code> for branch operations. Both work, but <code>switch</code> is more explicit about its purpose.
            </p>

            <pre><code># Switch to an existing branch (either command works)
git checkout main
git switch main

# Create and switch to a new branch
git checkout -b feature/shopping-cart
git switch -c feature/shopping-cart

# Switch to previous branch (like cd -)
git checkout -
git switch -

# Checkout a specific file from another branch
git checkout main -- src/config.js</code></pre>

            <div class="info-box">
                <div class="info-box-title">Recommendation</div>
                <p>Use <code>git switch</code> for changing branches and <code>git restore</code> for restoring files. They split the overloaded <code>git checkout</code> into two clear commands. This is especially helpful for newer team members who find checkout confusing.</p>
            </div>

            <!-- Section 3: Staging and Committing -->
            <h2 id="staging">Staging and Committing: add, commit, status</h2>

            <p>
                Git uses a staging area (index) between your working directory and the repository. You explicitly choose which changes go into each commit, giving you fine-grained control over your history.
            </p>

            <h3>git status</h3>

            <pre><code># Full status
git status

# Short format (faster to read)
git status -s

# Output example:
# M  src/app.js        (modified, staged)
#  M src/utils.js      (modified, not staged)
# ?? tests/new-test.js (untracked)</code></pre>

            <h3>git add</h3>

            <pre><code># Stage a specific file
git add src/app.js

# Stage multiple files
git add src/app.js src/utils.js

# Stage all changes in current directory
git add .

# Stage all changes in the entire repo
git add -A

# Stage parts of a file interactively
git add -p src/app.js
# Git shows each hunk and asks: stage this? (y/n/s/e/q)</code></pre>

            <div class="info-box warning">
                <div class="info-box-title">Avoid git add .</div>
                <p>Running <code>git add .</code> blindly can stage files you did not intend to commit, such as debug logs, <code>.env</code> files, or build artifacts. Always run <code>git status</code> first, or use <code>git add -p</code> for critical commits.</p>
            </div>

            <h3>git commit</h3>

            <pre><code># Commit with a message
git commit -m "Add user authentication flow"

# Commit with a multi-line message
git commit -m "Add user authentication flow" -m "Implements JWT-based auth with refresh tokens.
Includes login, logout, and token refresh endpoints."

# Stage all tracked files and commit in one step
git commit -am "Fix typo in login error message"

# Amend the last commit (change message or add files)
git add forgotten-file.js
git commit --amend -m "Add user auth flow with forgotten file"

# Amend without changing the message
git commit --amend --no-edit</code></pre>

            <p>
                Good commit messages follow a consistent format. The conventional commits standard uses prefixes like <code>feat:</code>, <code>fix:</code>, <code>refactor:</code>, <code>docs:</code>, and <code>chore:</code>. This makes history scannable and enables automated changelog generation.
            </p>

            <!-- Section 4: Remote Operations -->
            <h2 id="remote">Remote Operations: push, pull, fetch</h2>

            <p>
                These commands synchronize your local repository with remote repositories. Understanding the difference between fetch and pull is one of the most important Git concepts.
            </p>

            <h3>git push</h3>

            <pre><code># Push current branch to origin
git push

# Push and set upstream (first push of a new branch)
git push -u origin feature/user-auth

# Push a specific branch
git push origin main

# Force push (use with caution, rewrites remote history)
git push --force-with-lease origin feature/user-auth

# Push all branches
git push --all origin

# Push tags
git push --tags</code></pre>

            <div class="info-box danger">
                <div class="info-box-title">Never force push to shared branches</div>
                <p>Using <code>git push --force</code> on <code>main</code> or <code>develop</code> can overwrite other people's work. If you must force push, use <code>--force-with-lease</code> which fails if someone else has pushed since your last fetch.</p>
            </div>

            <h3>git fetch</h3>

            <pre><code># Fetch from origin (default remote)
git fetch

# Fetch from a specific remote
git fetch upstream

# Fetch and prune deleted remote branches
git fetch --prune

# Fetch a specific branch
git fetch origin main</code></pre>

            <h3>git pull</h3>

            <pre><code># Pull (fetch + merge) from tracking branch
git pull

# Pull with rebase instead of merge
git pull --rebase

# Pull from a specific remote/branch
git pull origin main

# Set rebase as default pull strategy
git config --global pull.rebase true</code></pre>

            <p>
                Many teams prefer <code>git pull --rebase</code> because it avoids unnecessary merge commits when pulling updates. Setting <code>pull.rebase true</code> makes this the default behavior.
            </p>

            <!-- Section 5: Merging and Rebasing -->
            <h2 id="merging">Merging and Rebasing: merge, rebase</h2>

            <p>
                Merge and rebase are two strategies for integrating changes from one branch into another. Understanding when to use each is critical for maintaining a clean, useful history.
            </p>

            <h3>git merge</h3>

            <pre><code># Merge feature branch into main
git switch main
git merge feature/user-auth

# Merge with a commit message
git merge feature/user-auth -m "Merge user authentication feature"

# Merge without fast-forward (always create a merge commit)
git merge --no-ff feature/user-auth

# Abort a merge in progress (if conflicts are too complex)
git merge --abort</code></pre>

            <p>
                When merge conflicts occur, Git marks the conflicting sections in the affected files. You can use the <a href="/free-tools/git-diff-viewer.html">Git Diff Viewer</a> to visualize exactly what changed, or the <a href="/free-tools/diff-checker.html">Diff Checker</a> to compare the conflicting versions side by side.
            </p>

            <h3>git rebase</h3>

            <pre><code># Rebase current branch onto main
git switch feature/user-auth
git rebase main

# Interactive rebase (rewrite last 3 commits)
git rebase -i HEAD~3
# Opens editor with options:
# pick   - keep commit as-is
# reword - change commit message
# squash - combine with previous commit
# fixup  - combine, discard this message
# drop   - remove commit entirely

# Continue after resolving conflicts
git rebase --continue

# Abort the rebase
git rebase --abort</code></pre>

            <div class="info-box">
                <div class="info-box-title">The Golden Rule of Rebasing</div>
                <p>Never rebase commits that have been pushed to a shared branch. Rebase rewrites commit hashes, which causes divergent histories for anyone who has pulled the original commits. Rebase is safe for local branches that have not been shared.</p>
            </div>

            <h3>Merge vs Rebase: When to Use Each</h3>

            <p><strong>Use merge when:</strong></p>
            <ul>
                <li>Integrating a shared feature branch into main</li>
                <li>You want to preserve the exact history of when work was integrated</li>
                <li>Multiple people have worked on the branch</li>
            </ul>

            <p><strong>Use rebase when:</strong></p>
            <ul>
                <li>Updating your local feature branch with latest changes from main</li>
                <li>Cleaning up commit history before opening a pull request</li>
                <li>You want a linear, readable history without merge commits</li>
            </ul>

            <!-- Section 6: Stash -->
            <h2 id="stash">Stashing Changes: stash</h2>

            <p>
                Stash saves your uncommitted changes temporarily so you can switch branches or pull updates without committing work in progress.
            </p>

            <pre><code># Stash all uncommitted changes
git stash

# Stash with a descriptive message
git stash push -m "WIP: user profile form validation"

# Stash including untracked files
git stash -u

# Stash only specific files
git stash push -m "API changes" src/api/

# List all stashes
git stash list
# stash@{0}: On feature/auth: WIP: user profile form validation
# stash@{1}: On main: Quick experiment

# Apply the most recent stash (keeps it in stash list)
git stash apply

# Apply and remove the most recent stash
git stash pop

# Apply a specific stash
git stash apply stash@{1}

# Drop a specific stash
git stash drop stash@{0}

# Clear all stashes
git stash clear

# Show what a stash contains
git stash show -p stash@{0}</code></pre>

            <p>
                A common pattern is stashing before pulling remote changes: <code>git stash</code>, <code>git pull --rebase</code>, <code>git stash pop</code>. This avoids committing incomplete work just to sync with the team.
            </p>

            <!-- Section 7: History and Inspection -->
            <h2 id="history">History and Inspection: log, diff, show</h2>

            <p>
                Reading and understanding history is just as important as writing it. These commands help you find what changed, when, and why.
            </p>

            <h3>git log</h3>

            <pre><code># Standard log
git log

# One-line format (most useful for scanning)
git log --oneline

# Graph view (shows branch topology)
git log --oneline --graph --all

# Filter by author
git log --author="Jane"

# Filter by date range
git log --after="2026-01-01" --before="2026-02-01"

# Filter by file
git log -- src/app.js

# Search commit messages
git log --grep="authentication"

# Show last 5 commits
git log -5

# Show commits that changed a specific function
git log -p -S "function calculateTotal"</code></pre>

            <h3>git diff</h3>

            <pre><code># Show unstaged changes
git diff

# Show staged changes (what will be committed)
git diff --staged

# Diff between two branches
git diff main..feature/user-auth

# Diff a specific file
git diff src/app.js

# Diff between commits
git diff abc123..def456

# Show only file names that changed
git diff --name-only main..feature/user-auth

# Show statistics (files changed, insertions, deletions)
git diff --stat main..feature/user-auth</code></pre>

            <p>
                For more complex diff comparisons, the <a href="/free-tools/text-diff-viewer.html">Text Diff Viewer</a> provides a visual, side-by-side view with syntax highlighting. You can paste in two versions and instantly see what changed.
            </p>

            <h3>git show</h3>

            <pre><code># Show the last commit
git show

# Show a specific commit
git show abc123

# Show a file at a specific commit
git show abc123:src/app.js

# Show a tag
git show v1.2.0</code></pre>

            <!-- Section 8: Undo -->
            <h2 id="undo">Undoing Changes: reset, revert, cherry-pick</h2>

            <p>
                Mistakes happen. Git provides multiple ways to undo changes depending on whether the commits are local or have been shared.
            </p>

            <h3>git reset</h3>

            <pre><code># Unstage a file (keep changes in working directory)
git reset HEAD src/app.js

# Undo last commit, keep changes staged
git reset --soft HEAD~1

# Undo last commit, keep changes unstaged
git reset --mixed HEAD~1

# Undo last commit, discard all changes (destructive)
git reset --hard HEAD~1

# Reset to a specific commit
git reset --hard abc123</code></pre>

            <div class="info-box danger">
                <div class="info-box-title">git reset --hard is destructive</div>
                <p>The <code>--hard</code> flag permanently discards changes. If you need to undo a commit that has been pushed to a shared branch, use <code>git revert</code> instead, which creates a new commit that undoes the changes without rewriting history.</p>
            </div>

            <h3>git revert</h3>

            <pre><code># Revert the last commit (creates a new "undo" commit)
git revert HEAD

# Revert a specific commit
git revert abc123

# Revert without committing (stage the revert, review first)
git revert --no-commit abc123

# Revert a merge commit (specify which parent to keep)
git revert -m 1 abc123</code></pre>

            <h3>git cherry-pick</h3>

            <p>
                Cherry-pick applies a specific commit from one branch onto your current branch. It is useful for moving individual fixes between branches.
            </p>

            <pre><code># Apply a specific commit to current branch
git cherry-pick abc123

# Cherry-pick without committing (stage only)
git cherry-pick --no-commit abc123

# Cherry-pick a range of commits
git cherry-pick abc123..def456

# Continue after resolving conflicts
git cherry-pick --continue

# Abort the cherry-pick
git cherry-pick --abort</code></pre>

            <p>
                Common cherry-pick scenario: a bug fix was committed to the <code>develop</code> branch but also needs to go into the <code>release/1.2</code> branch. Instead of merging all of develop, you cherry-pick just the fix commit.
            </p>

            <!-- Section 9: Workflows -->
            <h2 id="workflows">Real-World Workflows</h2>

            <h3>Feature Branch Workflow</h3>

            <p>The most common workflow for teams. Each feature gets its own branch, and changes are integrated via pull requests.</p>

            <pre><code># 1. Start from an updated main
git switch main
git pull --rebase

# 2. Create a feature branch
git switch -c feature/shopping-cart

# 3. Work on the feature (multiple commits)
git add src/cart/
git commit -m "feat: add cart component with add/remove functionality"
git add src/api/cart.js
git commit -m "feat: add cart API integration"
git add tests/cart.test.js
git commit -m "test: add cart component tests"

# 4. Keep up to date with main
git fetch origin
git rebase origin/main

# 5. Push and open a pull request
git push -u origin feature/shopping-cart

# 6. After PR approval, merge (typically done via GitHub/GitLab UI)
# 7. Clean up
git switch main
git pull
git branch -d feature/shopping-cart</code></pre>

            <h3>Hotfix Workflow</h3>

            <p>When a critical bug is found in production, you need to fix it fast without including in-progress feature work.</p>

            <pre><code># 1. Branch from the latest release tag or main
git switch main
git pull
git switch -c hotfix/payment-overflow

# 2. Fix the bug
git add src/payment.js
git commit -m "fix: prevent integer overflow in payment calculation"

# 3. Push and merge via PR (expedited review)
git push -u origin hotfix/payment-overflow

# 4. After merge, tag the release
git switch main
git pull
git tag -a v1.2.1 -m "Hotfix: payment overflow"
git push --tags</code></pre>

            <h3>Rebase Before Merge Workflow</h3>

            <p>Keeps history linear by rebasing feature branches before merging. Produces the cleanest history.</p>

            <pre><code># 1. Before opening a PR, clean up your branch
git switch feature/search
git fetch origin

# 2. Rebase onto latest main
git rebase origin/main

# 3. Squash related commits with interactive rebase
git rebase -i origin/main
# Mark commits as squash/fixup to combine them

# 4. Force push (safe because this is your branch)
git push --force-with-lease

# 5. Open PR - history is now clean and linear</code></pre>

            <p>
                When reviewing changes during any of these workflows, it helps to compare file versions systematically. The <a href="/free-tools/git-diff-viewer.html">Git Diff Viewer</a> shows exactly what changed between any two versions of your code.
            </p>

            <!-- Tools Section -->
            <h2 id="tools">Related Developer Tools</h2>

            <p>These free browser-based tools complement your Git workflow. No installation or signup required.</p>

            <div class="tool-grid">
                <a href="/free-tools/diff-checker.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F50D;</div>
                    <div class="tool-card-name">Diff Checker</div>
                    <div class="tool-card-desc">Compare two text blocks side by side. Spot differences instantly with highlighted additions, deletions, and modifications.</div>
                </a>
                <a href="/free-tools/git-diff-viewer.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F4CA;</div>
                    <div class="tool-card-name">Git Diff Viewer</div>
                    <div class="tool-card-desc">Paste a Git diff output and view it with syntax highlighting, unified or split view, and file-by-file navigation.</div>
                </a>
                <a href="/free-tools/git-command-builder.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F6E0;</div>
                    <div class="tool-card-name">Git Command Builder</div>
                    <div class="tool-card-desc">Build complex Git commands visually. Select options, flags, and arguments to generate the exact command you need.</div>
                </a>
                <a href="/free-tools/gitignore-generator.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F4C4;</div>
                    <div class="tool-card-name">Gitignore Generator</div>
                    <div class="tool-card-desc">Generate .gitignore files for any tech stack. Select your languages, frameworks, and IDEs to get the right exclusions.</div>
                </a>
                <a href="/free-tools/json-formatter.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F4CB;</div>
                    <div class="tool-card-name">JSON Formatter</div>
                    <div class="tool-card-desc">Format, validate, and minify JSON. Essential for cleaning up API responses and config files in your repositories.</div>
                </a>
                <a href="/free-tools/text-diff-viewer.html" class="tool-card">
                    <div class="tool-card-icon">&#x1F4DD;</div>
                    <div class="tool-card-name">Text Diff Viewer</div>
                    <div class="tool-card-desc">Visual text comparison with inline and side-by-side modes. Useful for comparing config files across branches.</div>
                </a>
            </div>

            <hr>

            <!-- FAQ Section -->
            <div class="faq-section" id="faq">
                <h2>Frequently Asked Questions</h2>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>What is the difference between git merge and git rebase?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Git merge creates a new merge commit that combines two branches, preserving the full history of both branches. Git rebase replays commits from one branch on top of another, creating a linear history without merge commits. Use merge for shared branches and when you want a complete history of when branches were integrated. Use rebase for local feature branches before merging to keep the history clean. Never rebase commits that have been pushed to a shared remote branch, as it rewrites history and causes conflicts for other developers.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>How do I undo the last git commit without losing changes?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Use <code>git reset --soft HEAD~1</code> to undo the last commit while keeping all changes staged and ready to commit again. Use <code>git reset --mixed HEAD~1</code> (or just <code>git reset HEAD~1</code>) to undo the commit and unstage the changes, keeping them in your working directory. Use <code>git reset --hard HEAD~1</code> to completely discard the commit and all changes. If the commit has already been pushed, use <code>git revert HEAD</code> instead, which creates a new commit that undoes the changes without rewriting history.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>What is git stash and when should I use it?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Git stash temporarily saves uncommitted changes (both staged and unstaged) so you can switch branches or pull updates without committing incomplete work. Run <code>git stash</code> to save changes, switch branches and do your work, then run <code>git stash pop</code> to restore your changes. Use <code>git stash list</code> to see all stashes, <code>git stash apply stash@{n}</code> to apply a specific stash without removing it, and <code>git stash drop stash@{n}</code> to delete a stash. It is useful when you need to quickly switch context, pull remote changes, or test something on a clean working directory.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>What is the difference between git pull and git fetch?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Git fetch downloads new commits and references from the remote repository but does not modify your working directory or current branch. It updates your remote-tracking branches (like origin/main) so you can review changes before integrating them. Git pull is essentially git fetch followed by git merge. It downloads remote changes and immediately merges them into your current branch. Using git fetch first is safer because it lets you inspect incoming changes with <code>git log</code> or <code>git diff</code> before merging. Many teams recommend git fetch followed by git merge or git rebase for more control.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>How do I use git cherry-pick?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>Git cherry-pick applies a specific commit from one branch onto your current branch. Use <code>git cherry-pick &lt;commit-hash&gt;</code> to apply a single commit. Use <code>git cherry-pick &lt;hash1&gt; &lt;hash2&gt; &lt;hash3&gt;</code> for multiple commits, or <code>git cherry-pick &lt;start&gt;..&lt;end&gt;</code> for a range. Common use cases include applying a bug fix from a development branch to a release branch without merging everything, recovering a commit from a deleted branch, and selectively moving features between branches. If conflicts occur during cherry-pick, resolve them manually, stage the files, and run <code>git cherry-pick --continue</code>.</p>
                        </div>
                    </div>
                </div>

                <div class="faq-item">
                    <button class="faq-question" onclick="toggleFAQ(this)">
                        <span>What is the best Git branching strategy for teams?</span>
                        <span class="icon">+</span>
                    </button>
                    <div class="faq-answer">
                        <div class="faq-answer-inner">
                            <p>The best strategy depends on team size and release cadence. For most teams, trunk-based development with short-lived feature branches works well: developers create feature branches from main, keep them small (1-3 days of work), and merge via pull requests. GitHub Flow is a lightweight variant: main is always deployable, features branch from main, and merge back via PR. Git Flow (with develop, release, and hotfix branches) suits teams with scheduled releases. The key principles are: keep branches short-lived, merge frequently, protect your main branch with CI checks, and delete branches after merging.</p>
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <!-- Author -->
        <div class="author-box">
            <div class="author-avatar">NT</div>
            <div class="author-info">
                <h4>NexTool Team</h4>
                <p>We build free developer tools including diff checkers, Git viewers, code formatters, and more. Over 150 tools, all browser-based, no signup required.</p>
            </div>
        </div>

        <!-- Bottom CTA -->
        <div class="cta-box">
            <h3>150+ Developer Tools, One Place</h3>
            <p>NexTool Pro ($29) unlocks clean output, enhanced features, and unlimited workspace. One payment, lifetime access.</p>
            <a href="https://nextool.app/free-tools/pro-upgrade.html" class="cta-button">Get NexTool Pro &mdash; $29</a>
            <a href="/free-tools/" class="cta-button secondary">Try Free Tools</a>
        </div>

    </article>

    <!-- Footer -->
    <footer class="footer">
        <div class="footer-inner">
            <div class="footer-links">
                <a href="https://nextool.app">Home</a>
                <a href="https://nextool.app/#services">Tools</a>
                <a href="https://nextool.app/free-tools/">Free Tools</a>
                <a href="https://nextool.app/blog/">Blog</a>
                <a href="https://nextool.app/#contact">Contact</a>
            </div>
            <p>&copy; 2026 NexTool. All rights reserved. 150+ free developer tools.</p>
        </div>
    </footer>

    <!-- FAQ Script -->
    <script>
        function toggleFAQ(button) {
            const item = button.parentElement;
            const answer = item.querySelector('.faq-answer');
            const isOpen = item.classList.contains('open');

            document.querySelectorAll('.faq-item').forEach(faq => {
                faq.classList.remove('open');
                faq.querySelector('.faq-answer').style.maxHeight = null;
            });

            if (!isOpen) {
                item.classList.add('open');
                answer.style.maxHeight = answer.scrollHeight + 'px';
            }
        }
    </script>

    <!-- Revenue Scripts -->
    <script defer src="/js/analytics-lite.js"></script>
    <script defer src="/js/revenue.js"></script>
    <script defer src="/js/lead-capture.js"></script>
</body>
</html>