<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Free SQL to MongoDB Converter — Translate Queries | NexTool</title>
<meta name="description" content="Convert SQL queries to MongoDB instantly. Supports SELECT, INSERT, UPDATE, DELETE with WHERE, ORDER BY, GROUP BY. Output as Shell, Node.js driver, or Mongoose.">
<meta name="keywords" content="SQL to MongoDB, query converter, MongoDB shell, Node.js MongoDB, Mongoose query, SQL translator, free online tool, NexTool">
<meta property="og:title" content="Free SQL to MongoDB Query Converter | NexTool">
<meta property="og:description" content="Translate SQL queries to MongoDB Shell, Node.js driver, or Mongoose syntax. Supports WHERE, JOIN, ORDER BY, GROUP BY, LIMIT. 100% free.">
<meta property="og:type" content="website">
<meta property="og:url" content="https://nextool.app/free-tools/sql-to-mongodb.html">
<meta property="og:image" content="https://nextool.app/assets/og-default.png">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<link rel="canonical" href="https://nextool.app/free-tools/sql-to-mongodb.html">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Free SQL to MongoDB Query Converter | NexTool">
<meta name="twitter:description" content="Translate SQL to MongoDB Shell, Node.js, or Mongoose queries. Free online tool by NexTool.">
<meta name="robots" content="index, follow">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"SoftwareApplication","name":"NexTool SQL to MongoDB Converter","applicationCategory":"DeveloperApplication","operatingSystem":"Web","offers":{"@type":"Offer","price":"0","priceCurrency":"USD"},"description":"Free online SQL to MongoDB query converter. Translate SELECT, INSERT, UPDATE, DELETE statements to MongoDB Shell, Node.js driver, or Mongoose syntax."}
</script>
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{--bg:#050508;--surface:#111118;--surface2:#1a1a24;--border:#2a2a3a;--text:#e4e4eb;--text2:#9494a8;--primary:#6366f1;--accent:#a855f7;--pink:#ec4899;--green:#22c55e;--red:#ef4444;--cyan:#22d3ee;--yellow:#eab308;--orange:#f97316;--radius:12px;--glass:rgba(17,17,24,0.7)}
html{scroll-behavior:smooth}
body{font-family:'Inter',system-ui,sans-serif;background:var(--bg);color:var(--text);line-height:1.6;min-height:100vh;overflow-x:hidden}
/* NAV */
.nav{position:sticky;top:0;z-index:100;background:rgba(5,5,8,0.85);backdrop-filter:blur(20px);border-bottom:1px solid var(--border);padding:0 2rem;height:64px;display:flex;align-items:center;justify-content:space-between}
.nav-logo{font-size:1.4rem;font-weight:800;background:linear-gradient(135deg,var(--primary),var(--accent));-webkit-background-clip:text;-webkit-text-fill-color:transparent;text-decoration:none}
.nav-links{display:flex;align-items:center;gap:1.5rem}
.nav-links a{color:var(--text2);text-decoration:none;font-size:.875rem;font-weight:500;transition:color .2s}
.nav-links a:hover{color:var(--text)}
.nav-cta{background:linear-gradient(135deg,var(--primary),var(--accent));color:#fff!important;padding:.5rem 1.2rem;border-radius:8px;font-weight:600;-webkit-text-fill-color:#fff!important}
.nav-cta:hover{opacity:.9}
.nav-toggle{display:none;background:none;border:none;color:var(--text);font-size:1.5rem;cursor:pointer}
/* HERO */
.hero{text-align:center;padding:3rem 1.5rem 2rem;max-width:700px;margin:0 auto}
.hero h1{font-size:2.2rem;font-weight:800;line-height:1.2;margin-bottom:.75rem}
.hero h1 span{background:linear-gradient(135deg,var(--primary),var(--accent),var(--pink));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.hero p{color:var(--text2);font-size:1rem}
/* TOOL */
.tool-container{max-width:1200px;margin:0 auto;padding:0 1.5rem 3rem}
.toolbar{display:flex;flex-wrap:wrap;gap:.5rem;margin-bottom:1rem;align-items:center}
.toolbar button,.toolbar select{background:var(--surface2);border:1px solid var(--border);color:var(--text);padding:.45rem .9rem;border-radius:8px;font-size:.8rem;font-weight:500;cursor:pointer;transition:all .2s;font-family:inherit}
.toolbar button:hover{border-color:var(--primary);background:rgba(99,102,241,.12)}
.toolbar button.active{background:linear-gradient(135deg,var(--primary),var(--accent));border-color:transparent;color:#fff}
.toolbar select{appearance:none;padding-right:1.8rem;background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%239494a8' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10z'/%3E%3C/svg%3E");background-repeat:no-repeat;background-position:right .6rem center}
.status-bar{display:flex;align-items:center;gap:1rem;margin-bottom:1rem;font-size:.8rem;color:var(--text2)}
.status-dot{width:8px;height:8px;border-radius:50%;display:inline-block}
.status-dot.valid{background:var(--green)}
.status-dot.invalid{background:var(--red)}
.status-dot.empty{background:var(--border)}
.panels{display:grid;grid-template-columns:1fr 1fr;gap:1rem;min-height:500px}
.panel{background:var(--glass);backdrop-filter:blur(16px);border:1px solid var(--border);border-radius:var(--radius);overflow:hidden;display:flex;flex-direction:column}
.panel-header{padding:.6rem 1rem;border-bottom:1px solid var(--border);font-size:.8rem;font-weight:600;color:var(--text2);display:flex;justify-content:space-between;align-items:center;background:rgba(26,26,36,0.5)}
.panel-body{flex:1;position:relative;overflow:auto}
#sqlInput{width:100%;height:100%;min-height:400px;background:transparent;border:none;color:var(--text);font-family:'JetBrains Mono','Courier New',monospace;font-size:.85rem;padding:1rem;resize:none;outline:none;line-height:1.7;tab-size:2}
#sqlInput::placeholder{color:var(--text2);opacity:.5}
.output-area{padding:1rem;font-family:'JetBrains Mono','Courier New',monospace;font-size:.85rem;line-height:1.7;white-space:pre-wrap;word-break:break-all;min-height:400px}
/* SYNTAX HIGHLIGHTING */
.hl-keyword{color:#c084fc;font-weight:600}
.hl-function{color:#818cf8}
.hl-string{color:#4ade80}
.hl-number{color:var(--cyan)}
.hl-operator{color:var(--yellow)}
.hl-field{color:#f0abfc}
.hl-collection{color:var(--orange)}
.hl-comment{color:#64748b;font-style:italic}
.hl-bracket{color:var(--text2)}
.hl-bool{color:var(--yellow)}
.hl-null{color:#6b7280}
.hl-method{color:#38bdf8}
.hl-regex{color:var(--pink)}
/* EXAMPLE CHIPS */
.examples{display:flex;flex-wrap:wrap;gap:.4rem;margin-bottom:1rem}
.examples span{font-size:.75rem;color:var(--text2);padding:.3rem 0;font-weight:500}
.example-chip{background:var(--surface2);border:1px solid var(--border);color:var(--text2);padding:.3rem .7rem;border-radius:6px;font-size:.72rem;cursor:pointer;transition:all .2s;font-family:inherit}
.example-chip:hover{border-color:var(--primary);color:var(--text);background:rgba(99,102,241,.1)}
/* ERROR */
.error-display{padding:1rem;color:var(--red);font-size:.85rem;font-family:'JetBrains Mono','Courier New',monospace;white-space:pre-wrap}
.error-display .error-line{background:rgba(239,68,68,.1);border-left:3px solid var(--red);padding:.3rem .6rem;margin:.3rem 0;border-radius:4px}
/* CTA */
.cta-section{text-align:center;padding:4rem 1.5rem;max-width:700px;margin:0 auto}
.cta-section h2{font-size:1.8rem;font-weight:800;margin-bottom:.75rem}
.cta-section h2 span{background:linear-gradient(135deg,var(--primary),var(--accent));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.cta-section p{color:var(--text2);margin-bottom:1.5rem}
.cta-btn{display:inline-block;background:linear-gradient(135deg,var(--primary),var(--accent));color:#fff;padding:.75rem 2rem;border-radius:10px;font-weight:700;text-decoration:none;font-size:1rem;transition:transform .2s,box-shadow .2s}
.cta-btn:hover{transform:translateY(-2px);box-shadow:0 8px 30px rgba(99,102,241,.3)}
/* FOOTER */
.footer{border-top:1px solid var(--border);padding:3rem 2rem 2rem;max-width:1200px;margin:0 auto}
.footer-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:2rem;margin-bottom:2rem}
.footer-col h4{font-size:.85rem;font-weight:700;margin-bottom:.75rem;color:var(--text)}
.footer-col a{display:block;color:var(--text2);text-decoration:none;font-size:.8rem;margin-bottom:.4rem;transition:color .2s}
.footer-col a:hover{color:var(--primary)}
.footer-bottom{text-align:center;color:var(--text2);font-size:.75rem;padding-top:1.5rem;border-top:1px solid var(--border)}
/* FADE IN */
.fade-in{opacity:0;transform:translateY(20px);transition:opacity .6s,transform .6s}
.fade-in.visible{opacity:1;transform:translateY(0)}
/* TOAST */
.toast{position:fixed;bottom:2rem;left:50%;transform:translateX(-50%) translateY(80px);background:var(--surface2);border:1px solid var(--border);color:var(--text);padding:.6rem 1.2rem;border-radius:10px;font-size:.85rem;font-weight:500;z-index:200;transition:transform .3s;pointer-events:none}
.toast.show{transform:translateX(-50%) translateY(0)}
/* FORMAT TABS */
.format-tabs{display:flex;gap:0;margin-bottom:0;border-bottom:1px solid var(--border);background:rgba(26,26,36,0.3)}
.format-tab{padding:.45rem 1rem;font-size:.75rem;font-weight:600;color:var(--text2);cursor:pointer;border:none;background:none;border-bottom:2px solid transparent;transition:all .2s;font-family:inherit}
.format-tab:hover{color:var(--text)}
.format-tab.active{color:var(--primary);border-bottom-color:var(--primary)}
/* RESPONSIVE */
@media(max-width:768px){
  .panels{grid-template-columns:1fr}
  .nav-links{display:none;position:absolute;top:64px;left:0;right:0;background:var(--bg);border-bottom:1px solid var(--border);flex-direction:column;padding:1rem 2rem;gap:1rem}
  .nav-links.open{display:flex}
  .nav-toggle{display:block}
  .hero h1{font-size:1.6rem}
  .footer-grid{grid-template-columns:1fr}
  .toolbar{gap:.35rem}
}
</style>
</head>
<body>

<nav class="nav">
  <a href="/" class="nav-logo">NexTool</a>
  <button class="nav-toggle" onclick="document.querySelector('.nav-links').classList.toggle('open')" aria-label="Menu">&#9776;</button>
  <div class="nav-links">
    <a href="/">Home</a>
    <a href="/free-tools/">Tools</a>
    <a href="/free-tools/">Free Tools</a>
    <a href="/blog/">Blog</a>
    <a href="/pro.html" class="nav-cta">Get Pro — $29</a>
  </div>
</nav>

<section class="hero fade-in">
  <h1>Free <span>SQL to MongoDB</span> Converter</h1>
  <p class="tool-summary" style="color:#94a3b8;font-size:15px;line-height:1.6;margin-bottom:24px;max-width:700px;margin-left:auto;margin-right:auto;">Translate SQL queries to MongoDB instantly. Supports SELECT, INSERT, UPDATE, DELETE with WHERE clauses, AND/OR/IN/LIKE/BETWEEN operators, ORDER BY, GROUP BY, and LIMIT. Output as MongoDB Shell, Node.js driver, or Mongoose syntax. 100% client-side, no data leaves your browser.</p>
</section>

<div class="tool-container fade-in">
  <div class="toolbar">
    <button onclick="convertSQL()" title="Convert SQL to MongoDB">Convert</button>
    <button onclick="copyOutput()" title="Copy MongoDB output">Copy</button>
    <button onclick="clearAll()" title="Clear all">Clear</button>
    <select id="formatSelect" onchange="reconvert()">
      <option value="shell">MongoDB Shell</option>
      <option value="nodejs">Node.js Driver</option>
      <option value="mongoose">Mongoose</option>
    </select>
  </div>

  <div class="examples">
    <span>Examples:</span>
    <button class="example-chip" onclick="loadExample('select')">SELECT</button>
    <button class="example-chip" onclick="loadExample('where')">WHERE</button>
    <button class="example-chip" onclick="loadExample('complex')">Complex WHERE</button>
    <button class="example-chip" onclick="loadExample('insert')">INSERT</button>
    <button class="example-chip" onclick="loadExample('update')">UPDATE</button>
    <button class="example-chip" onclick="loadExample('delete')">DELETE</button>
    <button class="example-chip" onclick="loadExample('group')">GROUP BY</button>
    <button class="example-chip" onclick="loadExample('join')">JOIN</button>
  </div>

  <div class="status-bar">
    <span><span class="status-dot empty" id="statusDot"></span></span>
    <span id="statusText">Enter a SQL query to convert</span>
  </div>

  <div class="panels">
    <div class="panel">
      <div class="panel-header"><span>SQL Input</span><span id="lineCount"></span></div>
      <div class="panel-body">
        <textarea id="sqlInput" placeholder="Enter your SQL query here...

Examples:
SELECT * FROM users WHERE age > 25 ORDER BY name LIMIT 10

INSERT INTO users (name, email) VALUES ('John', 'john@example.com')

UPDATE users SET status = 'active' WHERE age >= 18

DELETE FROM users WHERE last_login < '2024-01-01'" spellcheck="false"></textarea>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header">
        <span id="outputLabel">MongoDB Output</span>
        <span id="outputInfo"></span>
      </div>
      <div class="format-tabs">
        <button class="format-tab active" data-format="shell" onclick="switchFormat(this)">Shell</button>
        <button class="format-tab" data-format="nodejs" onclick="switchFormat(this)">Node.js</button>
        <button class="format-tab" data-format="mongoose" onclick="switchFormat(this)">Mongoose</button>
      </div>
      <div class="panel-body" id="outputPanel">
        <div class="output-area" id="mongoOutput"></div>
        <div class="error-display" id="errorOutput" style="display:none"></div>
      </div>
    </div>
  </div>
</div>

<section class="cta-section fade-in">
  <h2>Need something <span>more powerful</span>?</h2>
  <p>Let us build it for you. Custom APIs, dashboards, automations &mdash; whatever you need.</p>
  <a href="/#contact" class="cta-btn">Start a Project &rarr;</a>
</section>

<!-- Cross Promo -->
<section style="max-width:900px;margin:40px auto;padding:0 24px;">
<div style="background:linear-gradient(135deg,rgba(99,102,241,0.1),rgba(168,85,247,0.08));border:1px solid rgba(99,102,241,0.15);border-radius:20px;padding:32px 28px;text-align:center;">
<div style="font-size:13px;color:#818cf8;font-weight:600;text-transform:uppercase;letter-spacing:1px;margin-bottom:8px;">Founding Member</div>
<h3 style="font-size:22px;font-weight:800;color:#fff;margin:0 0 8px;">Get NexTool Pro</h3>
<p style="color:#94a3b8;font-size:14px;margin:0 auto 20px;max-width:500px;">No banners, clean output, enhanced features on all 228+ tools. One-time payment.</p>
<div style="display:flex;align-items:center;justify-content:center;gap:12px;flex-wrap:wrap;">
<a href="/pro.html" style="display:inline-block;padding:12px 28px;background:linear-gradient(135deg,#6366f1,#a855f7,#ec4899);color:#fff;border-radius:10px;font-weight:700;font-size:15px;text-decoration:none;">$29 — Get Pro</a>
<a href="/free-tools/" style="color:#94a3b8;font-size:14px;text-decoration:none;">Browse 228+ Free Tools &rarr;</a>
</div>
</div>
</section>


<!-- AUTO-LINKED by NexTool Engine -->
<div style="margin:2rem 0;padding:1.5rem;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius)">
<p style="font-weight:600;margin-bottom:.5rem">Related Tools</p>
<p><a href="/free-tools/box-shadow-generator.html" style="color:var(--primary);text-decoration:none">CSS Box Shadow Generator</a> · <a href="/free-tools/meta-tag-generator.html" style="color:var(--primary);text-decoration:none">Meta Tag Generator</a> · <a href="/free-tools/emoji-picker.html" style="color:var(--primary);text-decoration:none">Emoji Picker & Search</a></p>
</div>
<footer class="footer fade-in">
  <div class="footer-grid">
    <div class="footer-col">
      <h4>Products</h4>
      <a href="/free-tools/">228+ Free Tools</a>
<a href="/pro.html">NexTool Pro</a>
<a href="/workspace.html">Workspace</a>
    </div>
    <div class="footer-col">
      <h4>Explore</h4>
      <a href="/free-tools/">Free Tools</a><a href="/blog/">Blog</a><a href="/pro.html">FAQ</a><a href="/pro.html">Pro — $29</a>
    </div>
    <div class="footer-col">
      <h4>Ecosystem</h4>
      <a href="/">NexTool Home</a><a href="/#contact">Contact</a><a href="https://github.com/christian140903-sudo/nextool" target="_blank">GitHub</a>
    </div>
  </div>
  <div class="footer-bottom">&copy; 2026 NexTool. AI-powered tools for everyone.</div>
</footer>

<div class="toast" id="toast"></div>

<script>
const sqlInput = document.getElementById('sqlInput');
const mongoOutput = document.getElementById('mongoOutput');
const errorOutput = document.getElementById('errorOutput');
const statusDot = document.getElementById('statusDot');
const statusText = document.getElementById('statusText');
const lineCount = document.getElementById('lineCount');
const outputInfo = document.getElementById('outputInfo');
let lastResult = null;
let lastRaw = '';

sqlInput.addEventListener('input', debounce(autoConvert, 400));
sqlInput.addEventListener('input', updateLineCount);

function debounce(fn, ms) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); }; }

function updateLineCount() {
  const lines = sqlInput.value.split('\n').length;
  lineCount.textContent = lines + ' line' + (lines !== 1 ? 's' : '');
}

function autoConvert() {
  const raw = sqlInput.value.trim();
  if (!raw) {
    clearOutputs();
    statusDot.className = 'status-dot empty';
    statusText.textContent = 'Enter a SQL query to convert';
    return;
  }
  convertSQL();
}

function getFormat() {
  return document.getElementById('formatSelect').value;
}

function switchFormat(btn) {
  document.querySelectorAll('.format-tab').forEach(t => t.classList.remove('active'));
  btn.classList.add('active');
  const fmt = btn.dataset.format;
  document.getElementById('formatSelect').value = fmt;
  reconvert();
}

function reconvert() {
  const fmt = getFormat();
  document.querySelectorAll('.format-tab').forEach(t => {
    t.classList.toggle('active', t.dataset.format === fmt);
  });
  if (sqlInput.value.trim()) convertSQL();
}

/* ================= SQL TOKENIZER ================= */
function tokenize(sql) {
  const tokens = [];
  let i = 0;
  const s = sql.trim();
  while (i < s.length) {
    // Skip whitespace
    if (/\s/.test(s[i])) { i++; continue; }
    // Strings
    if (s[i] === "'" || s[i] === '"') {
      const q = s[i]; let str = ''; i++;
      while (i < s.length && s[i] !== q) {
        if (s[i] === '\\') { str += s[i+1]; i += 2; }
        else { str += s[i]; i++; }
      }
      i++; // closing quote
      tokens.push({ type: 'STRING', value: str });
      continue;
    }
    // Numbers
    if (/[0-9]/.test(s[i]) || (s[i] === '-' && i + 1 < s.length && /[0-9]/.test(s[i+1]) && (tokens.length === 0 || ['OPERATOR','COMMA','LPAREN','KEYWORD'].includes(tokens[tokens.length-1].type)))) {
      let num = s[i]; i++;
      while (i < s.length && /[0-9.]/.test(s[i])) { num += s[i]; i++; }
      tokens.push({ type: 'NUMBER', value: parseFloat(num) });
      continue;
    }
    // Parens
    if (s[i] === '(') { tokens.push({ type: 'LPAREN', value: '(' }); i++; continue; }
    if (s[i] === ')') { tokens.push({ type: 'RPAREN', value: ')' }); i++; continue; }
    // Comma
    if (s[i] === ',') { tokens.push({ type: 'COMMA', value: ',' }); i++; continue; }
    // Semicolon
    if (s[i] === ';') { i++; continue; }
    // Dot
    if (s[i] === '.') { tokens.push({ type: 'DOT', value: '.' }); i++; continue; }
    // Star
    if (s[i] === '*') { tokens.push({ type: 'STAR', value: '*' }); i++; continue; }
    // Operators
    if (s[i] === '!' && s[i+1] === '=') { tokens.push({ type: 'OPERATOR', value: '!=' }); i += 2; continue; }
    if (s[i] === '<' && s[i+1] === '>') { tokens.push({ type: 'OPERATOR', value: '<>' }); i += 2; continue; }
    if (s[i] === '<' && s[i+1] === '=') { tokens.push({ type: 'OPERATOR', value: '<=' }); i += 2; continue; }
    if (s[i] === '>' && s[i+1] === '=') { tokens.push({ type: 'OPERATOR', value: '>=' }); i += 2; continue; }
    if (s[i] === '<') { tokens.push({ type: 'OPERATOR', value: '<' }); i++; continue; }
    if (s[i] === '>') { tokens.push({ type: 'OPERATOR', value: '>' }); i++; continue; }
    if (s[i] === '=') { tokens.push({ type: 'OPERATOR', value: '=' }); i++; continue; }
    // Identifiers and keywords
    if (/[a-zA-Z_`]/.test(s[i])) {
      let ident = '';
      if (s[i] === '`') {
        i++;
        while (i < s.length && s[i] !== '`') { ident += s[i]; i++; }
        i++;
      } else {
        while (i < s.length && /[a-zA-Z0-9_]/.test(s[i])) { ident += s[i]; i++; }
      }
      const upper = ident.toUpperCase();
      const keywords = ['SELECT','FROM','WHERE','AND','OR','NOT','IN','LIKE','BETWEEN','IS','NULL',
        'ORDER','BY','GROUP','HAVING','LIMIT','OFFSET','INSERT','INTO','VALUES','UPDATE','SET',
        'DELETE','AS','ON','JOIN','LEFT','RIGHT','INNER','OUTER','CROSS','FULL','ASC','DESC',
        'DISTINCT','COUNT','SUM','AVG','MIN','MAX','TRUE','FALSE','EXISTS'];
      if (keywords.includes(upper)) {
        tokens.push({ type: 'KEYWORD', value: upper });
      } else {
        tokens.push({ type: 'IDENTIFIER', value: ident });
      }
      continue;
    }
    // Skip unknown chars
    i++;
  }
  return tokens;
}

/* ================= SQL PARSER ================= */
function parseSQL(sql) {
  const tokens = tokenize(sql);
  if (tokens.length === 0) throw new Error('Empty query');

  const first = tokens[0];
  if (first.type !== 'KEYWORD') throw new Error('Expected SQL keyword (SELECT, INSERT, UPDATE, DELETE)');

  switch (first.value) {
    case 'SELECT': return parseSelect(tokens);
    case 'INSERT': return parseInsert(tokens);
    case 'UPDATE': return parseUpdate(tokens);
    case 'DELETE': return parseDelete(tokens);
    default: throw new Error('Unsupported statement: ' + first.value + '. Supported: SELECT, INSERT, UPDATE, DELETE');
  }
}

function parseSelect(tokens) {
  let i = 1; // skip SELECT
  const result = { type: 'SELECT', collection: '', fields: [], where: null, orderBy: null, groupBy: null, having: null, limit: null, skip: null, distinct: false, joins: [] };

  // DISTINCT
  if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'DISTINCT') {
    result.distinct = true; i++;
  }

  // Fields
  if (i < tokens.length && tokens[i].type === 'STAR') {
    result.fields = []; i++;
  } else {
    const fieldResult = parseFieldList(tokens, i);
    result.fields = fieldResult.fields;
    i = fieldResult.index;
  }

  // FROM
  if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'FROM') {
    i++;
    if (i < tokens.length && tokens[i].type === 'IDENTIFIER') {
      result.collection = tokens[i].value; i++;
      // Alias
      if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'AS') { i++; i++; }
      else if (i < tokens.length && tokens[i].type === 'IDENTIFIER') { /* skip alias */ }
    }
  }

  // JOINs
  while (i < tokens.length && tokens[i].type === 'KEYWORD' && ['JOIN','LEFT','RIGHT','INNER','OUTER','CROSS','FULL'].includes(tokens[i].value)) {
    const joinResult = parseJoin(tokens, i);
    result.joins.push(joinResult.join);
    i = joinResult.index;
  }

  // WHERE
  if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'WHERE') {
    i++;
    const whereResult = parseWhere(tokens, i);
    result.where = whereResult.condition;
    i = whereResult.index;
  }

  // GROUP BY
  if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'GROUP') {
    i++; // GROUP
    if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'BY') i++; // BY
    const groups = [];
    while (i < tokens.length && tokens[i].type === 'IDENTIFIER') {
      groups.push(tokens[i].value); i++;
      if (i < tokens.length && tokens[i].type === 'COMMA') i++;
    }
    result.groupBy = groups;
  }

  // HAVING
  if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'HAVING') {
    i++;
    const havingResult = parseWhere(tokens, i);
    result.having = havingResult.condition;
    i = havingResult.index;
  }

  // ORDER BY
  if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'ORDER') {
    i++; // ORDER
    if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'BY') i++; // BY
    const orders = [];
    while (i < tokens.length && (tokens[i].type === 'IDENTIFIER' || (tokens[i].type === 'KEYWORD' && ['ASC','DESC'].includes(tokens[i].value)))) {
      const field = tokens[i].value; i++;
      let dir = 1;
      if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'DESC') { dir = -1; i++; }
      else if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'ASC') { i++; }
      orders.push({ field, dir });
      if (i < tokens.length && tokens[i].type === 'COMMA') i++;
    }
    result.orderBy = orders;
  }

  // LIMIT
  if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'LIMIT') {
    i++;
    if (i < tokens.length && tokens[i].type === 'NUMBER') {
      result.limit = tokens[i].value; i++;
    }
  }

  // OFFSET
  if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'OFFSET') {
    i++;
    if (i < tokens.length && tokens[i].type === 'NUMBER') {
      result.skip = tokens[i].value; i++;
    }
  }

  return result;
}

function parseFieldList(tokens, i) {
  const fields = [];
  while (i < tokens.length) {
    if (tokens[i].type === 'KEYWORD' && tokens[i].value === 'FROM') break;
    // Aggregate function
    if (tokens[i].type === 'KEYWORD' && ['COUNT','SUM','AVG','MIN','MAX'].includes(tokens[i].value)) {
      const fn = tokens[i].value; i++;
      if (i < tokens.length && tokens[i].type === 'LPAREN') i++;
      let arg = '*';
      if (i < tokens.length) {
        if (tokens[i].type === 'STAR') { arg = '*'; i++; }
        else if (tokens[i].type === 'IDENTIFIER') { arg = tokens[i].value; i++; }
        else if (tokens[i].type === 'KEYWORD' && tokens[i].value === 'DISTINCT') {
          i++;
          if (i < tokens.length && tokens[i].type === 'IDENTIFIER') { arg = tokens[i].value; i++; }
        }
      }
      if (i < tokens.length && tokens[i].type === 'RPAREN') i++;
      let alias = fn.toLowerCase() + '_' + arg;
      if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'AS') {
        i++;
        if (i < tokens.length && tokens[i].type === 'IDENTIFIER') { alias = tokens[i].value; i++; }
      }
      fields.push({ type: 'aggregate', fn, arg, alias });
    } else if (tokens[i].type === 'IDENTIFIER') {
      let name = tokens[i].value; i++;
      // table.field
      if (i < tokens.length && tokens[i].type === 'DOT') {
        i++;
        if (i < tokens.length && tokens[i].type === 'IDENTIFIER') { name = tokens[i].value; i++; }
      }
      let alias = name;
      if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'AS') {
        i++;
        if (i < tokens.length && tokens[i].type === 'IDENTIFIER') { alias = tokens[i].value; i++; }
      }
      fields.push({ type: 'field', name, alias });
    } else {
      i++;
    }
    if (i < tokens.length && tokens[i].type === 'COMMA') i++;
    else if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'FROM') break;
  }
  return { fields, index: i };
}

function parseJoin(tokens, i) {
  let joinType = 'left';
  // Parse join type keywords
  while (i < tokens.length && tokens[i].type === 'KEYWORD' && ['LEFT','RIGHT','INNER','OUTER','CROSS','FULL'].includes(tokens[i].value)) {
    if (tokens[i].value === 'LEFT') joinType = 'left';
    else if (tokens[i].value === 'RIGHT') joinType = 'right';
    else if (tokens[i].value === 'INNER') joinType = 'inner';
    i++;
  }
  if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'JOIN') i++;

  let foreignCollection = '';
  if (i < tokens.length && tokens[i].type === 'IDENTIFIER') { foreignCollection = tokens[i].value; i++; }

  // alias
  let alias = foreignCollection;
  if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'AS') {
    i++;
    if (i < tokens.length && tokens[i].type === 'IDENTIFIER') { alias = tokens[i].value; i++; }
  } else if (i < tokens.length && tokens[i].type === 'IDENTIFIER') {
    alias = tokens[i].value; i++;
  }

  // ON
  let localField = '', foreignField = '';
  if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'ON') {
    i++;
    // Parse: table1.field = table2.field
    if (i < tokens.length && tokens[i].type === 'IDENTIFIER') {
      let f1 = tokens[i].value; i++;
      if (i < tokens.length && tokens[i].type === 'DOT') { i++; if (i < tokens.length) { f1 = tokens[i].value; i++; } }
      localField = f1;
    }
    if (i < tokens.length && tokens[i].type === 'OPERATOR' && tokens[i].value === '=') i++;
    if (i < tokens.length && tokens[i].type === 'IDENTIFIER') {
      let f2 = tokens[i].value; i++;
      if (i < tokens.length && tokens[i].type === 'DOT') { i++; if (i < tokens.length) { f2 = tokens[i].value; i++; } }
      foreignField = f2;
    }
  }

  return {
    join: { type: joinType, collection: foreignCollection, alias, localField, foreignField },
    index: i
  };
}

function parseWhere(tokens, i) {
  return parseOr(tokens, i);
}

function parseOr(tokens, i) {
  let leftResult = parseAnd(tokens, i);
  let left = leftResult.condition;
  i = leftResult.index;

  while (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'OR') {
    i++;
    const rightResult = parseAnd(tokens, i);
    left = { type: 'OR', conditions: [left, rightResult.condition] };
    i = rightResult.index;
  }
  return { condition: left, index: i };
}

function parseAnd(tokens, i) {
  let leftResult = parseCondition(tokens, i);
  let left = leftResult.condition;
  i = leftResult.index;

  while (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'AND') {
    // Check it's not part of BETWEEN...AND
    i++;
    const rightResult = parseCondition(tokens, i);
    left = { type: 'AND', conditions: [left, rightResult.condition] };
    i = rightResult.index;
  }
  return { condition: left, index: i };
}

function parseCondition(tokens, i) {
  // NOT
  if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'NOT') {
    i++;
    const inner = parseCondition(tokens, i);
    return { condition: { type: 'NOT', condition: inner.condition }, index: inner.index };
  }

  // EXISTS (subquery) - simplified
  if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'EXISTS') {
    i++;
    // skip parens and content
    let depth = 0;
    if (i < tokens.length && tokens[i].type === 'LPAREN') { depth = 1; i++; }
    while (i < tokens.length && depth > 0) {
      if (tokens[i].type === 'LPAREN') depth++;
      if (tokens[i].type === 'RPAREN') depth--;
      i++;
    }
    return { condition: { type: 'EXISTS' }, index: i };
  }

  // Parenthesized expression
  if (i < tokens.length && tokens[i].type === 'LPAREN') {
    i++;
    const inner = parseOr(tokens, i);
    i = inner.index;
    if (i < tokens.length && tokens[i].type === 'RPAREN') i++;
    return { condition: inner.condition, index: i };
  }

  // field OPERATOR value
  if (i < tokens.length && tokens[i].type === 'IDENTIFIER') {
    let field = tokens[i].value; i++;
    // table.field
    if (i < tokens.length && tokens[i].type === 'DOT') {
      i++;
      if (i < tokens.length && tokens[i].type === 'IDENTIFIER') { field = tokens[i].value; i++; }
    }

    // IS NULL / IS NOT NULL
    if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'IS') {
      i++;
      let notNull = false;
      if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'NOT') { notNull = true; i++; }
      if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'NULL') i++;
      return {
        condition: { type: 'COMPARE', field, operator: notNull ? '$ne' : '$eq', value: null },
        index: i
      };
    }

    // NOT IN / NOT LIKE / NOT BETWEEN
    if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'NOT') {
      i++;
      if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'IN') {
        i++;
        const listResult = parseValueList(tokens, i);
        return { condition: { type: 'COMPARE', field, operator: '$nin', value: listResult.values }, index: listResult.index };
      }
      if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'LIKE') {
        i++;
        const val = parseValue(tokens, i);
        return { condition: { type: 'NOT_LIKE', field, value: val.value }, index: val.index };
      }
      if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'BETWEEN') {
        i++;
        const low = parseValue(tokens, i); i = low.index;
        if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'AND') i++;
        const high = parseValue(tokens, i);
        return {
          condition: { type: 'NOT_BETWEEN', field, low: low.value, high: high.value },
          index: high.index
        };
      }
    }

    // IN
    if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'IN') {
      i++;
      const listResult = parseValueList(tokens, i);
      return { condition: { type: 'COMPARE', field, operator: '$in', value: listResult.values }, index: listResult.index };
    }

    // LIKE
    if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'LIKE') {
      i++;
      const val = parseValue(tokens, i);
      return { condition: { type: 'LIKE', field, value: val.value }, index: val.index };
    }

    // BETWEEN
    if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'BETWEEN') {
      i++;
      const low = parseValue(tokens, i); i = low.index;
      if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'AND') i++;
      const high = parseValue(tokens, i);
      return {
        condition: { type: 'BETWEEN', field, low: low.value, high: high.value },
        index: high.index
      };
    }

    // Regular comparison
    if (i < tokens.length && tokens[i].type === 'OPERATOR') {
      const op = tokens[i].value; i++;
      const val = parseValue(tokens, i);
      const mongoOp = { '=': '$eq', '!=': '$ne', '<>': '$ne', '<': '$lt', '>': '$gt', '<=': '$lte', '>=': '$gte' }[op] || '$eq';
      return { condition: { type: 'COMPARE', field, operator: mongoOp, value: val.value }, index: val.index };
    }
  }

  // Aggregate function in HAVING
  if (i < tokens.length && tokens[i].type === 'KEYWORD' && ['COUNT','SUM','AVG','MIN','MAX'].includes(tokens[i].value)) {
    const fn = tokens[i].value; i++;
    if (i < tokens.length && tokens[i].type === 'LPAREN') i++;
    let arg = '*';
    if (i < tokens.length && tokens[i].type === 'STAR') { i++; }
    else if (i < tokens.length && tokens[i].type === 'IDENTIFIER') { arg = tokens[i].value; i++; }
    if (i < tokens.length && tokens[i].type === 'RPAREN') i++;
    const field = fn.toLowerCase() + '_' + arg;
    if (i < tokens.length && tokens[i].type === 'OPERATOR') {
      const op = tokens[i].value; i++;
      const val = parseValue(tokens, i);
      const mongoOp = { '=': '$eq', '!=': '$ne', '<>': '$ne', '<': '$lt', '>': '$gt', '<=': '$lte', '>=': '$gte' }[op] || '$eq';
      return { condition: { type: 'COMPARE', field, operator: mongoOp, value: val.value }, index: val.index };
    }
  }

  throw new Error('Unexpected token at position ' + i + (i < tokens.length ? ': ' + tokens[i].value : ''));
}

function parseValue(tokens, i) {
  if (i >= tokens.length) throw new Error('Unexpected end of query');
  const t = tokens[i];
  if (t.type === 'STRING') return { value: t.value, index: i + 1 };
  if (t.type === 'NUMBER') return { value: t.value, index: i + 1 };
  if (t.type === 'KEYWORD' && t.value === 'NULL') return { value: null, index: i + 1 };
  if (t.type === 'KEYWORD' && t.value === 'TRUE') return { value: true, index: i + 1 };
  if (t.type === 'KEYWORD' && t.value === 'FALSE') return { value: false, index: i + 1 };
  if (t.type === 'IDENTIFIER') return { value: t.value, index: i + 1 };
  throw new Error('Expected value, got: ' + t.value);
}

function parseValueList(tokens, i) {
  const values = [];
  if (i < tokens.length && tokens[i].type === 'LPAREN') i++;
  while (i < tokens.length && tokens[i].type !== 'RPAREN') {
    const v = parseValue(tokens, i);
    values.push(v.value); i = v.index;
    if (i < tokens.length && tokens[i].type === 'COMMA') i++;
  }
  if (i < tokens.length && tokens[i].type === 'RPAREN') i++;
  return { values, index: i };
}

function parseInsert(tokens) {
  let i = 1; // skip INSERT
  if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'INTO') i++;
  const result = { type: 'INSERT', collection: '', columns: [], values: [] };
  if (i < tokens.length && tokens[i].type === 'IDENTIFIER') { result.collection = tokens[i].value; i++; }

  // Columns
  if (i < tokens.length && tokens[i].type === 'LPAREN') {
    i++;
    while (i < tokens.length && tokens[i].type !== 'RPAREN') {
      if (tokens[i].type === 'IDENTIFIER') result.columns.push(tokens[i].value);
      i++;
      if (i < tokens.length && tokens[i].type === 'COMMA') i++;
    }
    if (i < tokens.length && tokens[i].type === 'RPAREN') i++;
  }

  // VALUES
  if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'VALUES') {
    i++;
    // Parse multiple value sets
    while (i < tokens.length && tokens[i].type === 'LPAREN') {
      i++;
      const row = [];
      while (i < tokens.length && tokens[i].type !== 'RPAREN') {
        const v = parseValue(tokens, i);
        row.push(v.value); i = v.index;
        if (i < tokens.length && tokens[i].type === 'COMMA') i++;
      }
      if (i < tokens.length && tokens[i].type === 'RPAREN') i++;
      result.values.push(row);
      if (i < tokens.length && tokens[i].type === 'COMMA') i++;
    }
  }

  return result;
}

function parseUpdate(tokens) {
  let i = 1; // skip UPDATE
  const result = { type: 'UPDATE', collection: '', set: {}, where: null };
  if (i < tokens.length && tokens[i].type === 'IDENTIFIER') { result.collection = tokens[i].value; i++; }

  // SET
  if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'SET') {
    i++;
    while (i < tokens.length && !(tokens[i].type === 'KEYWORD' && tokens[i].value === 'WHERE')) {
      if (tokens[i].type === 'IDENTIFIER') {
        const field = tokens[i].value; i++;
        if (i < tokens.length && tokens[i].type === 'OPERATOR' && tokens[i].value === '=') i++;
        const v = parseValue(tokens, i);
        result.set[field] = v.value; i = v.index;
        if (i < tokens.length && tokens[i].type === 'COMMA') i++;
      } else {
        i++;
      }
    }
  }

  // WHERE
  if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'WHERE') {
    i++;
    const whereResult = parseWhere(tokens, i);
    result.where = whereResult.condition;
  }

  return result;
}

function parseDelete(tokens) {
  let i = 1; // skip DELETE
  const result = { type: 'DELETE', collection: '', where: null };
  if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'FROM') i++;
  if (i < tokens.length && tokens[i].type === 'IDENTIFIER') { result.collection = tokens[i].value; i++; }

  // WHERE
  if (i < tokens.length && tokens[i].type === 'KEYWORD' && tokens[i].value === 'WHERE') {
    i++;
    const whereResult = parseWhere(tokens, i);
    result.where = whereResult.condition;
  }

  return result;
}

/* ================= CONDITION TO MONGODB ================= */
function conditionToMongo(cond) {
  if (!cond) return {};
  switch (cond.type) {
    case 'COMPARE':
      if (cond.operator === '$eq') return { [cond.field]: cond.value };
      return { [cond.field]: { [cond.operator]: cond.value } };
    case 'AND': {
      const merged = {};
      let needsAndArray = false;
      const parts = flattenLogical(cond, 'AND');
      // Try to merge simple conditions
      for (const p of parts) {
        const m = conditionToMongo(p);
        for (const key of Object.keys(m)) {
          if (key in merged) { needsAndArray = true; break; }
          merged[key] = m[key];
        }
        if (needsAndArray) break;
      }
      if (needsAndArray) return { $and: parts.map(p => conditionToMongo(p)) };
      return merged;
    }
    case 'OR':
      return { $or: flattenLogical(cond, 'OR').map(p => conditionToMongo(p)) };
    case 'NOT':
      const inner = conditionToMongo(cond.condition);
      // Wrap with $not or $nor
      if (Object.keys(inner).length === 1) {
        const key = Object.keys(inner)[0];
        const val = inner[key];
        if (typeof val === 'object' && val !== null && !Array.isArray(val)) {
          return { [key]: { $not: val } };
        }
        return { [key]: { $ne: val } };
      }
      return { $nor: [inner] };
    case 'LIKE': {
      const regex = likeToRegex(cond.value);
      return { [cond.field]: { $regex: regex, $options: 'i' } };
    }
    case 'NOT_LIKE': {
      const regex = likeToRegex(cond.value);
      return { [cond.field]: { $not: { $regex: regex, $options: 'i' } } };
    }
    case 'BETWEEN':
      return { [cond.field]: { $gte: cond.low, $lte: cond.high } };
    case 'NOT_BETWEEN':
      return { $or: [{ [cond.field]: { $lt: cond.low } }, { [cond.field]: { $gt: cond.high } }] };
    case 'EXISTS':
      return { /* $exists subquery placeholder */ };
    default:
      return {};
  }
}

function flattenLogical(cond, type) {
  if (cond.type === type) {
    const parts = [];
    for (const c of cond.conditions) {
      parts.push(...flattenLogical(c, type));
    }
    return parts;
  }
  return [cond];
}

function likeToRegex(pattern) {
  // Convert SQL LIKE pattern to regex
  let regex = pattern
    .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')  // escape regex special chars
    .replace(/\\%/g, '.*')                      // % -> .*
    .replace(/_/g, '.');                         // _ -> .
  // Fix: the % was already escaped, so undo that
  regex = pattern
    .replace(/[-/\\^$*+?.()|[\]{}]/g, function(c) {
      if (c === '%' || c === '_') return c;
      return '\\' + c;
    })
    .replace(/%/g, '.*')
    .replace(/_/g, '.');
  return '^' + regex + '$';
}

/* ================= FORMAT OUTPUT ================= */
function formatShell(parsed) {
  const col = parsed.collection || 'collection';
  switch (parsed.type) {
    case 'SELECT': return formatShellSelect(parsed, col);
    case 'INSERT': return formatShellInsert(parsed, col);
    case 'UPDATE': return formatShellUpdate(parsed, col);
    case 'DELETE': return formatShellDelete(parsed, col);
  }
}

function formatShellSelect(p, col) {
  // GROUP BY -> aggregation pipeline
  if (p.groupBy && p.groupBy.length > 0) {
    return formatShellAggregate(p, col);
  }

  // JOINs -> aggregation pipeline with $lookup
  if (p.joins && p.joins.length > 0) {
    return formatShellLookup(p, col);
  }

  const filter = p.where ? conditionToMongo(p.where) : {};
  const projection = {};
  if (p.fields.length > 0) {
    for (const f of p.fields) {
      if (f.type === 'field') projection[f.name] = 1;
    }
  }

  let hasAgg = p.fields.some(f => f.type === 'aggregate');
  if (hasAgg) return formatShellAggregate(p, col);

  let result = 'db.' + col + '.find(\n';
  result += '  ' + prettyObj(filter, 2);
  if (Object.keys(projection).length > 0) {
    result += ',\n  ' + prettyObj(projection, 2);
  }
  result += '\n)';

  if (p.orderBy && p.orderBy.length > 0) {
    const sort = {};
    for (const o of p.orderBy) sort[o.field] = o.dir;
    result += '.sort(' + prettyObj(sort) + ')';
  }
  if (p.skip) result += '.skip(' + p.skip + ')';
  if (p.limit) result += '.limit(' + p.limit + ')';
  if (p.distinct) {
    const field = p.fields.length > 0 ? p.fields[0].name : '_id';
    result = 'db.' + col + '.distinct("' + field + '"';
    if (Object.keys(filter).length > 0) result += ', ' + prettyObj(filter);
    result += ')';
  }

  return result;
}

function formatShellAggregate(p, col) {
  const pipeline = [];

  // $match
  if (p.where) {
    pipeline.push({ $match: conditionToMongo(p.where) });
  }

  // $group
  if (p.groupBy && p.groupBy.length > 0) {
    const groupId = {};
    for (const g of p.groupBy) groupId[g] = '$' + g;
    const group = { _id: p.groupBy.length === 1 ? '$' + p.groupBy[0] : groupId };
    for (const f of p.fields) {
      if (f.type === 'aggregate') {
        const mongoAgg = aggToMongo(f);
        group[f.alias] = mongoAgg;
      } else if (f.type === 'field' && !p.groupBy.includes(f.name)) {
        group[f.name] = { $first: '$' + f.name };
      }
    }
    pipeline.push({ $group: group });
  } else if (p.fields.some(f => f.type === 'aggregate')) {
    // Aggregation without GROUP BY
    const group = { _id: null };
    for (const f of p.fields) {
      if (f.type === 'aggregate') {
        group[f.alias] = aggToMongo(f);
      }
    }
    pipeline.push({ $group: group });
  }

  // $match (HAVING)
  if (p.having) {
    pipeline.push({ $match: conditionToMongo(p.having) });
  }

  // $sort
  if (p.orderBy && p.orderBy.length > 0) {
    const sort = {};
    for (const o of p.orderBy) sort[o.field] = o.dir;
    pipeline.push({ $sort: sort });
  }

  // $skip
  if (p.skip) pipeline.push({ $skip: p.skip });

  // $limit
  if (p.limit) pipeline.push({ $limit: p.limit });

  let result = 'db.' + col + '.aggregate([\n';
  result += pipeline.map(stage => '  ' + prettyObj(stage, 2)).join(',\n');
  result += '\n])';
  return result;
}

function formatShellLookup(p, col) {
  const pipeline = [];

  // $lookup for each join
  for (const j of p.joins) {
    pipeline.push({
      $lookup: {
        from: j.collection,
        localField: j.localField,
        foreignField: j.foreignField,
        as: j.alias || j.collection
      }
    });
    // Unwind for inner/left joins
    if (j.type === 'inner') {
      pipeline.push({ $unwind: '$' + (j.alias || j.collection) });
    } else {
      pipeline.push({ $unwind: { path: '$' + (j.alias || j.collection), preserveNullAndEmptyArrays: true } });
    }
  }

  // $match
  if (p.where) {
    pipeline.push({ $match: conditionToMongo(p.where) });
  }

  // $project
  if (p.fields.length > 0) {
    const project = {};
    for (const f of p.fields) {
      if (f.type === 'field') project[f.alias || f.name] = '$' + f.name;
    }
    if (Object.keys(project).length > 0) pipeline.push({ $project: project });
  }

  // $sort
  if (p.orderBy && p.orderBy.length > 0) {
    const sort = {};
    for (const o of p.orderBy) sort[o.field] = o.dir;
    pipeline.push({ $sort: sort });
  }

  if (p.skip) pipeline.push({ $skip: p.skip });
  if (p.limit) pipeline.push({ $limit: p.limit });

  let result = 'db.' + col + '.aggregate([\n';
  result += pipeline.map(stage => '  ' + prettyObj(stage, 2)).join(',\n');
  result += '\n])';
  return result;
}

function aggToMongo(f) {
  const arg = f.arg === '*' ? 1 : ('$' + f.arg);
  switch (f.fn) {
    case 'COUNT': return f.arg === '*' ? { $sum: 1 } : { $sum: { $cond: [{ $ne: ['$' + f.arg, null] }, 1, 0] } };
    case 'SUM': return { $sum: arg };
    case 'AVG': return { $avg: arg };
    case 'MIN': return { $min: arg };
    case 'MAX': return { $max: arg };
  }
}

function formatShellInsert(p, col) {
  if (p.values.length === 0) return '// No values to insert';
  const docs = p.values.map(row => {
    const doc = {};
    for (let j = 0; j < p.columns.length; j++) {
      doc[p.columns[j]] = j < row.length ? row[j] : null;
    }
    return doc;
  });

  if (docs.length === 1) {
    return 'db.' + col + '.insertOne(\n  ' + prettyObj(docs[0], 2) + '\n)';
  }
  return 'db.' + col + '.insertMany([\n' + docs.map(d => '  ' + prettyObj(d, 2)).join(',\n') + '\n])';
}

function formatShellUpdate(p, col) {
  const filter = p.where ? conditionToMongo(p.where) : {};
  return 'db.' + col + '.updateMany(\n  ' + prettyObj(filter, 2) + ',\n  { $set: ' + prettyObj(p.set, 2) + ' }\n)';
}

function formatShellDelete(p, col) {
  const filter = p.where ? conditionToMongo(p.where) : {};
  return 'db.' + col + '.deleteMany(\n  ' + prettyObj(filter, 2) + '\n)';
}

/* ================= NODE.JS FORMAT ================= */
function formatNodejs(parsed) {
  const col = parsed.collection || 'collection';
  const colVar = 'collection';
  let pre = '// Using MongoDB Node.js Driver\n';
  pre += 'const { MongoClient } = require("mongodb");\n\n';
  pre += 'const client = new MongoClient("mongodb://localhost:27017");\n';
  pre += 'const db = client.db("myDatabase");\n';
  pre += 'const ' + colVar + ' = db.collection("' + col + '");\n\n';

  switch (parsed.type) {
    case 'SELECT': return pre + formatNodejsSelect(parsed, colVar);
    case 'INSERT': return pre + formatNodejsInsert(parsed, colVar);
    case 'UPDATE': return pre + formatNodejsUpdate(parsed, colVar);
    case 'DELETE': return pre + formatNodejsDelete(parsed, colVar);
  }
}

function formatNodejsSelect(p, colVar) {
  if ((p.groupBy && p.groupBy.length > 0) || p.fields.some(f => f.type === 'aggregate') || (p.joins && p.joins.length > 0)) {
    // Use aggregate
    const shell = formatShellAggregate(p, '__PLACEHOLDER__');
    const pipelineStr = shell.replace(/^db\.__PLACEHOLDER__\.aggregate\(\[/, '[').replace(/\]\)$/, ']');
    return 'const result = await ' + colVar + '.aggregate(' + pipelineStr + ').toArray();';
  }

  const filter = p.where ? conditionToMongo(p.where) : {};
  const projection = {};
  if (p.fields.length > 0) {
    for (const f of p.fields) {
      if (f.type === 'field') projection[f.name] = 1;
    }
  }

  let options = {};
  if (Object.keys(projection).length > 0) options.projection = projection;
  if (p.orderBy && p.orderBy.length > 0) {
    const sort = {};
    for (const o of p.orderBy) sort[o.field] = o.dir;
    options.sort = sort;
  }
  if (p.skip) options.skip = p.skip;
  if (p.limit) options.limit = p.limit;

  if (p.distinct) {
    const field = p.fields.length > 0 ? p.fields[0].name : '_id';
    let result = 'const result = await ' + colVar + '.distinct(\n  "' + field + '"';
    if (Object.keys(filter).length > 0) result += ',\n  ' + prettyObj(filter, 2);
    result += '\n);';
    return result;
  }

  let result = 'const result = await ' + colVar + '.find(\n  ' + prettyObj(filter, 2);
  if (Object.keys(options).length > 0) {
    result += ',\n  ' + prettyObj(options, 2);
  }
  result += '\n).toArray();';
  return result;
}

function formatNodejsInsert(p, colVar) {
  const docs = p.values.map(row => {
    const doc = {};
    for (let j = 0; j < p.columns.length; j++) {
      doc[p.columns[j]] = j < row.length ? row[j] : null;
    }
    return doc;
  });
  if (docs.length === 1) {
    return 'const result = await ' + colVar + '.insertOne(\n  ' + prettyObj(docs[0], 2) + '\n);';
  }
  return 'const result = await ' + colVar + '.insertMany([\n' + docs.map(d => '  ' + prettyObj(d, 2)).join(',\n') + '\n]);';
}

function formatNodejsUpdate(p, colVar) {
  const filter = p.where ? conditionToMongo(p.where) : {};
  return 'const result = await ' + colVar + '.updateMany(\n  ' + prettyObj(filter, 2) + ',\n  { $set: ' + prettyObj(p.set, 2) + ' }\n);';
}

function formatNodejsDelete(p, colVar) {
  const filter = p.where ? conditionToMongo(p.where) : {};
  return 'const result = await ' + colVar + '.deleteMany(\n  ' + prettyObj(filter, 2) + '\n);';
}

/* ================= MONGOOSE FORMAT ================= */
function formatMongoose(parsed) {
  const col = parsed.collection || 'Collection';
  const modelName = col.charAt(0).toUpperCase() + col.slice(1).replace(/s$/, '');
  let pre = '// Using Mongoose\n';
  pre += 'const mongoose = require("mongoose");\n';
  pre += 'const ' + modelName + ' = mongoose.model("' + modelName + '");\n\n';

  switch (parsed.type) {
    case 'SELECT': return pre + formatMongooseSelect(parsed, modelName);
    case 'INSERT': return pre + formatMongooseInsert(parsed, modelName);
    case 'UPDATE': return pre + formatMongooseUpdate(parsed, modelName);
    case 'DELETE': return pre + formatMongooseDelete(parsed, modelName);
  }
}

function formatMongooseSelect(p, model) {
  if ((p.groupBy && p.groupBy.length > 0) || p.fields.some(f => f.type === 'aggregate') || (p.joins && p.joins.length > 0)) {
    const shell = formatShellAggregate(p, '__PLACEHOLDER__');
    const pipelineStr = shell.replace(/^db\.__PLACEHOLDER__\.aggregate\(\[/, '[').replace(/\]\)$/, ']');
    return 'const result = await ' + model + '.aggregate(' + pipelineStr + ');';
  }

  const filter = p.where ? conditionToMongo(p.where) : {};
  const fields = p.fields.filter(f => f.type === 'field').map(f => f.name);

  if (p.distinct) {
    const field = fields.length > 0 ? fields[0] : '_id';
    let result = 'const result = await ' + model + '.distinct(\n  "' + field + '"';
    if (Object.keys(filter).length > 0) result += ',\n  ' + prettyObj(filter, 2);
    result += '\n);';
    return result;
  }

  let result = 'const result = await ' + model + '.find(\n  ' + prettyObj(filter, 2) + '\n)';
  if (fields.length > 0) {
    result += '\n  .select("' + fields.join(' ') + '")';
  }
  if (p.orderBy && p.orderBy.length > 0) {
    const sortParts = p.orderBy.map(o => (o.dir === -1 ? '-' : '') + o.field);
    result += '\n  .sort("' + sortParts.join(' ') + '")';
  }
  if (p.skip) result += '\n  .skip(' + p.skip + ')';
  if (p.limit) result += '\n  .limit(' + p.limit + ')';
  result += '\n  .exec();';
  return result;
}

function formatMongooseInsert(p, model) {
  const docs = p.values.map(row => {
    const doc = {};
    for (let j = 0; j < p.columns.length; j++) {
      doc[p.columns[j]] = j < row.length ? row[j] : null;
    }
    return doc;
  });
  if (docs.length === 1) {
    return 'const result = await ' + model + '.create(\n  ' + prettyObj(docs[0], 2) + '\n);';
  }
  return 'const result = await ' + model + '.insertMany([\n' + docs.map(d => '  ' + prettyObj(d, 2)).join(',\n') + '\n]);';
}

function formatMongooseUpdate(p, model) {
  const filter = p.where ? conditionToMongo(p.where) : {};
  return 'const result = await ' + model + '.updateMany(\n  ' + prettyObj(filter, 2) + ',\n  { $set: ' + prettyObj(p.set, 2) + ' }\n);';
}

function formatMongooseDelete(p, model) {
  const filter = p.where ? conditionToMongo(p.where) : {};
  return 'const result = await ' + model + '.deleteMany(\n  ' + prettyObj(filter, 2) + '\n);';
}

/* ================= PRETTY PRINTER ================= */
function prettyObj(obj, indent) {
  return JSON.stringify(obj, null, 2).split('\n').map((line, idx) => {
    if (idx === 0) return line;
    return '  '.repeat((indent || 0) / 2) + line;
  }).join('\n');
}

/* ================= SYNTAX HIGHLIGHTING ================= */
function highlightMongo(code) {
  return code
    .replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
    // Comments
    .replace(/(\/\/.*)/g, '<span class="hl-comment">$1</span>')
    // Strings
    .replace(/("(?:[^"\\]|\\.)*")/g, '<span class="hl-string">$1</span>')
    // MongoDB operators ($set, $gt, etc.)
    .replace(/(\$[a-zA-Z_]+)/g, '<span class="hl-operator">$1</span>')
    // require/const/await keywords
    .replace(/\b(const|let|var|await|require|async|function|return)\b/g, '<span class="hl-keyword">$1</span>')
    // Method calls (.find, .aggregate, etc.)
    .replace(/\.(find|findOne|aggregate|insertOne|insertMany|updateOne|updateMany|deleteOne|deleteMany|sort|skip|limit|distinct|select|exec|toArray|create|model|collection|db)\b/g, '.<span class="hl-method">$1</span>')
    // db. prefix
    .replace(/\bdb\./g, '<span class="hl-collection">db</span>.')
    // Numbers
    .replace(/\b(-?\d+\.?\d*)\b/g, '<span class="hl-number">$1</span>')
    // Booleans and null
    .replace(/\b(true|false)\b/g, '<span class="hl-bool">$1</span>')
    .replace(/\bnull\b/g, '<span class="hl-null">null</span>')
    // Brackets
    .replace(/([{}[\]()])/g, '<span class="hl-bracket">$1</span>');
}

/* ================= MAIN CONVERT ================= */
function convertSQL() {
  const raw = sqlInput.value.trim();
  if (!raw) return;

  try {
    const parsed = parseSQL(raw);
    lastResult = parsed;
    const fmt = getFormat();
    let output;
    switch (fmt) {
      case 'shell': output = formatShell(parsed); break;
      case 'nodejs': output = formatNodejs(parsed); break;
      case 'mongoose': output = formatMongoose(parsed); break;
    }
    lastRaw = output;
    mongoOutput.innerHTML = highlightMongo(output);
    mongoOutput.style.display = '';
    errorOutput.style.display = 'none';
    statusDot.className = 'status-dot valid';
    statusText.textContent = 'Converted to ' + { shell: 'MongoDB Shell', nodejs: 'Node.js Driver', mongoose: 'Mongoose' }[fmt];
    outputInfo.textContent = output.split('\n').length + ' lines';
  } catch (e) {
    lastRaw = '';
    lastResult = null;
    errorOutput.innerHTML = '<strong>Conversion Error</strong>\n\n<div class="error-line">' + escapeHtml(e.message) + '</div>\n\nMake sure your SQL follows standard syntax.\nSupported: SELECT, INSERT, UPDATE, DELETE';
    mongoOutput.style.display = 'none';
    errorOutput.style.display = '';
    statusDot.className = 'status-dot invalid';
    statusText.textContent = 'Parse error';
    outputInfo.textContent = '';
  }
}

function escapeHtml(s) { return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); }

function clearOutputs() {
  mongoOutput.innerHTML = '';
  errorOutput.innerHTML = '';
  outputInfo.textContent = '';
  mongoOutput.style.display = '';
  errorOutput.style.display = 'none';
}

function clearAll() {
  sqlInput.value = '';
  lastResult = null;
  lastRaw = '';
  clearOutputs();
  statusDot.className = 'status-dot empty';
  statusText.textContent = 'Enter a SQL query to convert';
  lineCount.textContent = '';
}

function copyOutput() {
  if (!lastRaw) { showToast('Nothing to copy'); return; }
  navigator.clipboard.writeText(lastRaw).then(() => showToast('Copied to clipboard'));
}

function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 2000);
}

/* ================= EXAMPLES ================= */
const examples = {
  select: "SELECT name, email, age FROM users WHERE age > 25 ORDER BY name ASC LIMIT 10",
  where: "SELECT * FROM products WHERE price >= 10 AND price <= 100 AND category IN ('electronics', 'books') AND name LIKE '%phone%'",
  complex: "SELECT * FROM orders WHERE (status = 'active' OR status = 'pending') AND total > 50 AND created_at BETWEEN '2024-01-01' AND '2024-12-31' AND customer_id IS NOT NULL",
  insert: "INSERT INTO users (name, email, age, role) VALUES ('John Doe', 'john@example.com', 30, 'admin'), ('Jane Smith', 'jane@example.com', 25, 'user')",
  update: "UPDATE users SET status = 'inactive', updated_at = '2024-06-15' WHERE last_login < '2024-01-01' AND role != 'admin'",
  'delete': "DELETE FROM sessions WHERE expires_at < '2024-01-01' AND user_id IN (1, 2, 3)",
  group: "SELECT category, COUNT(*) AS total, AVG(price) AS avg_price, MAX(price) AS max_price FROM products WHERE status = 'active' GROUP BY category HAVING COUNT(*) > 5 ORDER BY total DESC",
  join: "SELECT users.name, orders.total, orders.status FROM users LEFT JOIN orders ON users.id = orders.user_id WHERE orders.total > 100 ORDER BY orders.total DESC LIMIT 20"
};

function loadExample(key) {
  sqlInput.value = examples[key];
  updateLineCount();
  convertSQL();
}

/* Tab key support */
sqlInput.addEventListener('keydown', e => {
  if (e.key === 'Tab') {
    e.preventDefault();
    const start = sqlInput.selectionStart, end = sqlInput.selectionEnd;
    sqlInput.value = sqlInput.value.substring(0, start) + '  ' + sqlInput.value.substring(end);
    sqlInput.selectionStart = sqlInput.selectionEnd = start + 2;
  }
});

/* Ctrl+Enter to convert */
sqlInput.addEventListener('keydown', e => {
  if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
    e.preventDefault();
    convertSQL();
  }
});

/* IntersectionObserver fade-in */
const observer = new IntersectionObserver(entries => {
  entries.forEach(entry => { if (entry.isIntersecting) { entry.target.classList.add('visible'); observer.unobserve(entry.target); }});
}, { threshold: 0.1 });
document.querySelectorAll('.fade-in').forEach(el => observer.observe(el));
</script>
<script src="/js/analytics-lite.js" defer></script>
<script src="/js/revenue.js" defer></script>
<script src="/js/lead-capture.js" defer></script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "FAQPage",
  "mainEntity": [
    {
      "@type": "Question",
      "name": "What SQL statements does this converter support?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "The SQL to MongoDB converter supports SELECT, INSERT, UPDATE, and DELETE statements. It handles WHERE clauses with AND, OR, IN, LIKE, BETWEEN, IS NULL, and IS NOT NULL operators, as well as ORDER BY, GROUP BY, HAVING, LIMIT, OFFSET, DISTINCT, and JOIN clauses."
      }
    },
    {
      "@type": "Question",
      "name": "What MongoDB output formats are available?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "The converter outputs in three formats: MongoDB Shell syntax (db.collection.find), Node.js MongoDB Driver (using the official mongodb npm package with async/await), and Mongoose (using Mongoose models with chaining syntax like .find().sort().limit().exec())."
      }
    },
    {
      "@type": "Question",
      "name": "Is this SQL to MongoDB converter free?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "Yes, NexTool's SQL to MongoDB converter is completely free. No signup required, no data limits, and it runs 100% in your browser. Your SQL queries never leave your device."
      }
    },
    {
      "@type": "Question",
      "name": "How does SQL JOIN translate to MongoDB?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "SQL JOINs are converted to MongoDB's $lookup aggregation stage. A LEFT JOIN becomes a $lookup followed by $unwind with preserveNullAndEmptyArrays: true, while an INNER JOIN uses $unwind without that option."
      }
    }
  ]
}
</script>
</body>
</html>
