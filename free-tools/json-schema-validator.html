<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Free JSON Schema Validator — Validate JSON Against Schema | NexTool</title>
<meta name="description" content="Free online JSON Schema validator. Validate JSON data against JSON Schema Draft 4/6/7 with detailed error messages, path highlighting, and sample schemas. No signup.">
<meta name="keywords" content="JSON Schema validator, JSON validation, JSON Schema Draft 7, validate JSON, schema validation, free online tool, NexTool">
<meta property="og:title" content="Free JSON Schema Validator | NexTool">
<meta property="og:description" content="Validate JSON data against JSON Schema Draft 4/6/7 instantly. Detailed errors with paths. 100% free, runs in your browser.">
<meta property="og:type" content="website">
<meta property="og:url" content="https://nextool.app/free-tools/json-schema-validator.html">
<meta property="og:image" content="https://nextool.app/assets/og-default.png">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<link rel="canonical" href="https://nextool.app/free-tools/json-schema-validator.html">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Free JSON Schema Validator | NexTool">
<meta name="twitter:description" content="Validate JSON data against JSON Schema Draft 4/6/7. Free online tool by NexTool.">
<meta name="robots" content="index, follow">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"SoftwareApplication","name":"NexTool JSON Schema Validator","applicationCategory":"DeveloperApplication","operatingSystem":"Web","offers":{"@type":"Offer","price":"0","priceCurrency":"USD"},"description":"Free online JSON Schema validator supporting Draft 4/6/7. Validate JSON data with detailed error messages and path highlighting."}
</script>
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{--bg:#050508;--surface:#111118;--surface2:#1a1a24;--border:#2a2a3a;--text:#e4e4eb;--text2:#9494a8;--primary:#6366f1;--accent:#a855f7;--pink:#ec4899;--green:#22c55e;--red:#ef4444;--cyan:#22d3ee;--yellow:#eab308;--radius:12px;--glass:rgba(17,17,24,0.7)}
html{scroll-behavior:smooth}
body{font-family:'Inter',system-ui,sans-serif;background:var(--bg);color:var(--text);line-height:1.6;min-height:100vh;overflow-x:hidden}
/* NAV */
.nav{position:sticky;top:0;z-index:100;background:rgba(5,5,8,0.85);backdrop-filter:blur(20px);border-bottom:1px solid var(--border);padding:0 2rem;height:64px;display:flex;align-items:center;justify-content:space-between}
.nav-logo{font-size:1.4rem;font-weight:800;background:linear-gradient(135deg,var(--primary),var(--accent));-webkit-background-clip:text;-webkit-text-fill-color:transparent;text-decoration:none}
.nav-links{display:flex;align-items:center;gap:1.5rem}
.nav-links a{color:var(--text2);text-decoration:none;font-size:.875rem;font-weight:500;transition:color .2s}
.nav-links a:hover{color:var(--text)}
.nav-cta{background:linear-gradient(135deg,var(--primary),var(--accent));color:#fff!important;padding:.5rem 1.2rem;border-radius:8px;font-weight:600;-webkit-text-fill-color:#fff!important}
.nav-cta:hover{opacity:.9}
.nav-toggle{display:none;background:none;border:none;color:var(--text);font-size:1.5rem;cursor:pointer}
/* HERO */
.hero{text-align:center;padding:3rem 1.5rem 2rem;max-width:700px;margin:0 auto}
.hero h1{font-size:2.2rem;font-weight:800;line-height:1.2;margin-bottom:.75rem}
.hero h1 span{background:linear-gradient(135deg,var(--primary),var(--accent),var(--pink));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.hero p{color:var(--text2);font-size:1rem}
/* TOOL */
.tool-container{max-width:1400px;margin:0 auto;padding:0 1.5rem 3rem}
.toolbar{display:flex;flex-wrap:wrap;gap:.5rem;margin-bottom:1rem;align-items:center}
.toolbar button,.toolbar select,.toolbar label{background:var(--surface2);border:1px solid var(--border);color:var(--text);padding:.45rem .9rem;border-radius:8px;font-size:.8rem;font-weight:500;cursor:pointer;transition:all .2s;font-family:inherit}
.toolbar button:hover,.toolbar label:hover{border-color:var(--primary);background:rgba(99,102,241,.12)}
.toolbar button.active{background:linear-gradient(135deg,var(--primary),var(--accent));border-color:transparent;color:#fff}
.toolbar select{appearance:none;padding-right:1.8rem;background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%239494a8' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10z'/%3E%3C/svg%3E");background-repeat:no-repeat;background-position:right .6rem center}
.toolbar .separator{width:1px;height:24px;background:var(--border);margin:0 .25rem}
.toolbar label input[type="file"]{display:none}
.status-bar{display:flex;align-items:center;gap:1rem;margin-bottom:1rem;font-size:.8rem;color:var(--text2);flex-wrap:wrap}
.status-dot{width:8px;height:8px;border-radius:50%;display:inline-block}
.status-dot.valid{background:var(--green)}
.status-dot.invalid{background:var(--red)}
.status-dot.empty{background:var(--border)}
.status-dot.warning{background:var(--yellow)}
.draft-badge{display:inline-block;padding:2px 8px;background:rgba(99,102,241,.15);color:var(--primary);border-radius:6px;font-size:.75rem;font-weight:600}
.panels{display:grid;grid-template-columns:1fr 1fr;gap:1rem;min-height:500px}
.panel{background:var(--glass);backdrop-filter:blur(16px);border:1px solid var(--border);border-radius:var(--radius);overflow:hidden;display:flex;flex-direction:column}
.panel-header{padding:.6rem 1rem;border-bottom:1px solid var(--border);font-size:.8rem;font-weight:600;color:var(--text2);display:flex;justify-content:space-between;align-items:center;background:rgba(26,26,36,0.5)}
.panel-body{flex:1;position:relative;overflow:auto}
.editor-area{width:100%;height:100%;min-height:400px;background:transparent;border:none;color:var(--text);font-family:'Courier New',monospace;font-size:.85rem;padding:1rem;resize:none;outline:none;line-height:1.7;tab-size:2}
.editor-area::placeholder{color:var(--text2);opacity:.5}
/* RESULTS PANEL */
.results-panel{max-width:1400px;margin:0 auto;padding:0 1.5rem 2rem}
.results-card{background:var(--glass);backdrop-filter:blur(16px);border:1px solid var(--border);border-radius:var(--radius);overflow:hidden}
.results-header{padding:.75rem 1rem;border-bottom:1px solid var(--border);font-size:.85rem;font-weight:600;color:var(--text2);display:flex;justify-content:space-between;align-items:center;background:rgba(26,26,36,0.5)}
.results-body{padding:1rem;max-height:400px;overflow-y:auto}
.result-success{display:flex;align-items:center;gap:.75rem;padding:1rem;background:rgba(34,197,94,.08);border:1px solid rgba(34,197,94,.2);border-radius:10px;color:var(--green);font-weight:600;font-size:.9rem}
.result-success .icon{font-size:1.5rem}
.error-list{list-style:none}
.error-item{padding:.75rem 1rem;margin-bottom:.5rem;background:rgba(239,68,68,.06);border:1px solid rgba(239,68,68,.15);border-radius:10px;font-size:.85rem;font-family:'Courier New',monospace;line-height:1.6;transition:background .2s}
.error-item:hover{background:rgba(239,68,68,.1)}
.error-path{color:var(--cyan);font-weight:600;display:block;margin-bottom:.25rem}
.error-msg{color:var(--red)}
.error-keyword{display:inline-block;padding:1px 6px;background:rgba(99,102,241,.15);color:var(--primary);border-radius:4px;font-size:.75rem;font-weight:600;margin-left:.5rem}
.error-context{color:var(--text2);font-size:.8rem;margin-top:.25rem;display:block}
/* CTA */
.cta-section{text-align:center;padding:4rem 1.5rem;max-width:700px;margin:0 auto}
.cta-section h2{font-size:1.8rem;font-weight:800;margin-bottom:.75rem}
.cta-section h2 span{background:linear-gradient(135deg,var(--primary),var(--accent));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.cta-section p{color:var(--text2);margin-bottom:1.5rem}
.cta-btn{display:inline-block;background:linear-gradient(135deg,var(--primary),var(--accent));color:#fff;padding:.75rem 2rem;border-radius:10px;font-weight:700;text-decoration:none;font-size:1rem;transition:transform .2s,box-shadow .2s}
.cta-btn:hover{transform:translateY(-2px);box-shadow:0 8px 30px rgba(99,102,241,.3)}
/* FOOTER */
.footer{border-top:1px solid var(--border);padding:3rem 2rem 2rem;max-width:1200px;margin:0 auto}
.footer-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:2rem;margin-bottom:2rem}
.footer-col h4{font-size:.85rem;font-weight:700;margin-bottom:.75rem;color:var(--text)}
.footer-col a{display:block;color:var(--text2);text-decoration:none;font-size:.8rem;margin-bottom:.4rem;transition:color .2s}
.footer-col a:hover{color:var(--primary)}
.footer-bottom{text-align:center;color:var(--text2);font-size:.75rem;padding-top:1.5rem;border-top:1px solid var(--border)}
/* FADE IN */
.fade-in{opacity:0;transform:translateY(20px);transition:opacity .6s,transform .6s}
.fade-in.visible{opacity:1;transform:translateY(0)}
/* TOAST */
.toast{position:fixed;bottom:2rem;left:50%;transform:translateX(-50%) translateY(80px);background:var(--surface2);border:1px solid var(--border);color:var(--text);padding:.6rem 1.2rem;border-radius:10px;font-size:.85rem;font-weight:500;z-index:200;transition:transform .3s;pointer-events:none}
.toast.show{transform:translateX(-50%) translateY(0)}
/* SCHEMA HINTS */
.hints-bar{display:flex;flex-wrap:wrap;gap:.35rem;padding:.5rem 1rem;border-top:1px solid var(--border);background:rgba(26,26,36,0.3)}
.hint-chip{padding:2px 8px;background:rgba(99,102,241,.1);border:1px solid rgba(99,102,241,.15);color:var(--primary);border-radius:6px;font-size:.7rem;font-weight:500;cursor:pointer;transition:all .2s;font-family:'Courier New',monospace}
.hint-chip:hover{background:rgba(99,102,241,.2);border-color:var(--primary)}
/* ERROR HIGHLIGHTING OVERLAY */
.editor-wrap{position:relative;flex:1;display:flex;flex-direction:column}
.line-highlight{position:absolute;left:0;right:0;height:1.7em;background:rgba(239,68,68,.08);border-left:3px solid var(--red);pointer-events:none;z-index:1}
/* RESPONSIVE */
@media(max-width:768px){
  .panels{grid-template-columns:1fr}
  .nav-links{display:none;position:absolute;top:64px;left:0;right:0;background:var(--bg);border-bottom:1px solid var(--border);flex-direction:column;padding:1rem 2rem;gap:1rem}
  .nav-links.open{display:flex}
  .nav-toggle{display:block}
  .hero h1{font-size:1.6rem}
  .footer-grid{grid-template-columns:1fr}
  .toolbar{gap:.35rem}
  .editor-area{min-height:300px}
}
</style>
</head>
<body>

<nav class="nav">
  <a href="/" class="nav-logo">NexTool</a>
  <button class="nav-toggle" onclick="document.querySelector('.nav-links').classList.toggle('open')" aria-label="Menu">&#9776;</button>
  <div class="nav-links">
    <a href="/">Home</a>
    <a href="/free-tools/">Tools</a>
    <a href="/free-tools/">Free Tools</a>
    <a href="/blog/">Blog</a>
    <a href="/#contact" class="nav-cta">Get Pro — $29</a>
  </div>
</nav>

<section class="hero fade-in">
  <h1>Free <span>JSON Schema Validator</span></h1>
  <p class="tool-summary" style="color:#94a3b8;font-size:15px;line-height:1.6;margin-bottom:24px;max-width:700px;margin-left:auto;margin-right:auto;">Validate JSON data against JSON Schema (Draft 4/6/7) instantly in your browser. Get detailed error messages with paths, line numbers, and keyword context. Load sample schemas, upload files, and copy validated results. No signup required.</p>
</section>

<div class="tool-container fade-in">
  <div class="toolbar">
    <button onclick="validateAll()" title="Validate JSON against schema" class="active">Validate</button>
    <button onclick="formatBoth()" title="Format both editors">Format</button>
    <button onclick="copyResult()" title="Copy validation result">Copy Result</button>
    <button onclick="clearAll()" title="Clear everything">Clear</button>
    <div class="separator"></div>
    <select id="sampleSelect" onchange="loadSample(this.value)" title="Load sample schema">
      <option value="">Load Sample...</option>
      <option value="string">String Validation</option>
      <option value="object">Object with Properties</option>
      <option value="array">Array Items</option>
      <option value="nested">Nested Object</option>
      <option value="enum">Enum + Const</option>
      <option value="combinators">anyOf / oneOf / allOf</option>
      <option value="pattern">Pattern + Format</option>
      <option value="ref">$ref References</option>
    </select>
    <div class="separator"></div>
    <label title="Load schema from file" style="display:flex;align-items:center;gap:4px">
      Schema <input type="file" accept=".json,.schema,.jsonschema" onchange="loadFile(event,'schema')">
    </label>
    <label title="Load JSON data from file" style="display:flex;align-items:center;gap:4px">
      Data <input type="file" accept=".json" onchange="loadFile(event,'data')">
    </label>
  </div>

  <div class="status-bar">
    <span><span class="status-dot empty" id="statusDot"></span></span>
    <span id="statusText">Paste a schema and data to begin</span>
    <span id="draftBadge" class="draft-badge" style="display:none"></span>
    <span id="errorCount" style="margin-left:auto"></span>
  </div>

  <div class="panels">
    <div class="panel">
      <div class="panel-header"><span>JSON Schema</span><span id="schemaInfo"></span></div>
      <div class="editor-wrap">
        <textarea id="schemaInput" class="editor-area" placeholder='Paste your JSON Schema here...&#10;&#10;Example:&#10;{&#10;  "type": "object",&#10;  "properties": {&#10;    "name": { "type": "string" },&#10;    "age": { "type": "integer", "minimum": 0 }&#10;  },&#10;  "required": ["name"]&#10;}' spellcheck="false"></textarea>
      </div>
      <div class="hints-bar" id="schemaHints">
        <span class="hint-chip" onclick="insertHint('type')">"type"</span>
        <span class="hint-chip" onclick="insertHint('properties')">"properties"</span>
        <span class="hint-chip" onclick="insertHint('required')">"required"</span>
        <span class="hint-chip" onclick="insertHint('items')">"items"</span>
        <span class="hint-chip" onclick="insertHint('enum')">"enum"</span>
        <span class="hint-chip" onclick="insertHint('pattern')">"pattern"</span>
        <span class="hint-chip" onclick="insertHint('minimum')">"minimum"</span>
        <span class="hint-chip" onclick="insertHint('anyOf')">"anyOf"</span>
        <span class="hint-chip" onclick="insertHint('$ref')">"$ref"</span>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"><span>JSON Data</span><span id="dataInfo"></span></div>
      <div class="editor-wrap" id="dataEditorWrap">
        <textarea id="dataInput" class="editor-area" placeholder='Paste your JSON data here...&#10;&#10;Example:&#10;{&#10;  "name": "NexTool",&#10;  "age": 1&#10;}' spellcheck="false"></textarea>
      </div>
    </div>
  </div>
</div>

<div class="results-panel fade-in">
  <div class="results-card">
    <div class="results-header">
      <span>Validation Results</span>
      <span id="resultsSummary"></span>
    </div>
    <div class="results-body" id="resultsBody">
      <div style="color:var(--text2);font-size:.85rem;text-align:center;padding:2rem">Enter a JSON Schema and JSON data, then click Validate</div>
    </div>
  </div>
</div>

<section class="cta-section fade-in">
  <h2>Need something <span>more powerful</span>?</h2>
  <p>Let us build it for you. Custom APIs, dashboards, automations &mdash; whatever you need.</p>
  <a href="/#contact" class="cta-btn">Start a Project &rarr;</a>
</section>

<!-- Cross Promo -->
<section style="max-width:900px;margin:40px auto;padding:0 24px;">
<div style="background:linear-gradient(135deg,rgba(99,102,241,0.1),rgba(168,85,247,0.08));border:1px solid rgba(99,102,241,0.15);border-radius:20px;padding:32px 28px;text-align:center;">
<div style="font-size:13px;color:#818cf8;font-weight:600;text-transform:uppercase;letter-spacing:1px;margin-bottom:8px;">Founding Member</div>
<h3 style="font-size:22px;font-weight:800;color:#fff;margin:0 0 8px;">Get NexTool Pro</h3>
<p style="color:#94a3b8;font-size:14px;margin:0 auto 20px;max-width:500px;">No banners, clean output, enhanced features on all 213+ tools. One-time payment.</p>
<div style="display:flex;align-items:center;justify-content:center;gap:12px;flex-wrap:wrap;">
<a href="/pro.html" style="display:inline-block;padding:12px 28px;background:linear-gradient(135deg,#6366f1,#a855f7,#ec4899);color:#fff;border-radius:10px;font-weight:700;font-size:15px;text-decoration:none;">$29 — Get Pro</a>
<a href="/free-tools/" style="color:#94a3b8;font-size:14px;text-decoration:none;">Browse 213+ Free Tools &rarr;</a>
</div>
</div>
</section>


<!-- AUTO-LINKED by NexTool Engine -->
<div style="margin:2rem 0;padding:1.5rem;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius)">
<p style="font-weight:600;margin-bottom:.5rem">Related Tools</p>
<p><a href="/free-tools/box-shadow-generator.html" style="color:var(--primary);text-decoration:none">CSS Box Shadow Generator</a> · <a href="/free-tools/emoji-picker.html" style="color:var(--primary);text-decoration:none">Emoji Picker & Search</a> · <a href="/free-tools/favicon-generator.html" style="color:var(--primary);text-decoration:none">Favicon Generator</a></p>
</div>
<footer class="footer fade-in">
  <div class="footer-grid">
    <div class="footer-col">
      <h4>Products</h4>
      <a href="/free-tools/">213+ Free Tools</a>
<a href="/pro.html">NexTool Pro</a>
<a href="/workspace.html">Workspace</a>
    </div>
    <div class="footer-col">
      <h4>Explore</h4>
      <a href="/free-tools/">Free Tools</a><a href="/blog/">Blog</a><a href="/pro.html">FAQ</a><a href="/pro.html">Pro — $29</a>
    </div>
    <div class="footer-col">
      <h4>Ecosystem</h4>
      <a href="/">NexTool Home</a><a href="/#contact">Contact</a><a href="https://github.com/christian140903-sudo/nextool" target="_blank">GitHub</a>
    </div>
  </div>
  <div class="footer-bottom">&copy; 2026 NexTool. AI-powered tools for everyone.</div>
</footer>

<div class="toast" id="toast"></div>

<script>
/* ========================================================================
   JSON Schema Validator — Draft 7 (with Draft 4/6 detection)
   Pure client-side implementation. No external dependencies.
   ======================================================================== */

const schemaInput = document.getElementById('schemaInput');
const dataInput = document.getElementById('dataInput');
const statusDot = document.getElementById('statusDot');
const statusText = document.getElementById('statusText');
const draftBadge = document.getElementById('draftBadge');
const errorCountEl = document.getElementById('errorCount');
const resultsBody = document.getElementById('resultsBody');
const resultsSummary = document.getElementById('resultsSummary');
const schemaInfo = document.getElementById('schemaInfo');
const dataInfo = document.getElementById('dataInfo');
const dataEditorWrap = document.getElementById('dataEditorWrap');

let lastErrors = [];
let lastResultText = '';

/* ---- Debounced auto-validate on input ---- */
let autoTimer = null;
schemaInput.addEventListener('input', () => { clearTimeout(autoTimer); autoTimer = setTimeout(autoValidate, 600); });
dataInput.addEventListener('input', () => { clearTimeout(autoTimer); autoTimer = setTimeout(autoValidate, 600); });

function autoValidate() {
  if (schemaInput.value.trim() && dataInput.value.trim()) validateAll();
}

/* ---- Tab key support ---- */
[schemaInput, dataInput].forEach(el => {
  el.addEventListener('keydown', e => {
    if (e.key === 'Tab') {
      e.preventDefault();
      const s = el.selectionStart, end = el.selectionEnd;
      el.value = el.value.substring(0, s) + '  ' + el.value.substring(end);
      el.selectionStart = el.selectionEnd = s + 2;
    }
  });
});

/* ===================================================================
   CORE: JSON Schema Draft 7 Validator
   =================================================================== */
function validateSchema(schema, data, rootSchema) {
  rootSchema = rootSchema || schema;
  const errors = [];
  const path = arguments[3] || '';

  // Handle boolean schemas
  if (schema === true) return errors;
  if (schema === false) { errors.push({ path: path || '/', message: 'Schema is false — no value is valid', keyword: 'false schema' }); return errors; }
  if (typeof schema !== 'object' || schema === null) return errors;

  // $ref — resolve same-document JSON Pointer references
  if (schema.$ref) {
    const resolved = resolveRef(schema.$ref, rootSchema);
    if (resolved !== undefined) {
      return validateSchema(resolved, data, rootSchema, path);
    } else {
      errors.push({ path: path || '/', message: 'Could not resolve $ref: ' + schema.$ref, keyword: '$ref' });
      return errors;
    }
  }

  // const
  if (schema.hasOwnProperty('const')) {
    if (!deepEqual(data, schema.const)) {
      errors.push({ path: path || '/', message: 'Value must be equal to the const: ' + JSON.stringify(schema.const), keyword: 'const' });
    }
  }

  // enum
  if (schema.hasOwnProperty('enum')) {
    if (!Array.isArray(schema.enum) || !schema.enum.some(v => deepEqual(data, v))) {
      errors.push({ path: path || '/', message: 'Value must be one of: ' + JSON.stringify(schema.enum), keyword: 'enum' });
    }
  }

  // type
  if (schema.hasOwnProperty('type')) {
    const types = Array.isArray(schema.type) ? schema.type : [schema.type];
    const actual = jsonType(data);
    let typeValid = false;
    for (const t of types) {
      if (t === 'integer') {
        if (actual === 'number' && Number.isInteger(data)) { typeValid = true; break; }
      } else if (t === actual) {
        typeValid = true; break;
      }
    }
    if (!typeValid) {
      errors.push({ path: path || '/', message: 'Expected type "' + schema.type + '" but got "' + actual + '"', keyword: 'type', context: 'Value: ' + truncate(JSON.stringify(data), 80) });
    }
  }

  // ---- Numeric validations ----
  if (typeof data === 'number') {
    if (schema.hasOwnProperty('minimum') && data < schema.minimum) {
      errors.push({ path: path || '/', message: 'Value ' + data + ' is less than minimum ' + schema.minimum, keyword: 'minimum' });
    }
    if (schema.hasOwnProperty('maximum') && data > schema.maximum) {
      errors.push({ path: path || '/', message: 'Value ' + data + ' is greater than maximum ' + schema.maximum, keyword: 'maximum' });
    }
    if (schema.hasOwnProperty('exclusiveMinimum')) {
      const em = schema.exclusiveMinimum;
      if (typeof em === 'number' && data <= em) {
        errors.push({ path: path || '/', message: 'Value ' + data + ' must be > ' + em, keyword: 'exclusiveMinimum' });
      } else if (typeof em === 'boolean' && em && schema.hasOwnProperty('minimum') && data === schema.minimum) {
        errors.push({ path: path || '/', message: 'Value ' + data + ' must be > ' + schema.minimum + ' (exclusive)', keyword: 'exclusiveMinimum' });
      }
    }
    if (schema.hasOwnProperty('exclusiveMaximum')) {
      const em = schema.exclusiveMaximum;
      if (typeof em === 'number' && data >= em) {
        errors.push({ path: path || '/', message: 'Value ' + data + ' must be < ' + em, keyword: 'exclusiveMaximum' });
      } else if (typeof em === 'boolean' && em && schema.hasOwnProperty('maximum') && data === schema.maximum) {
        errors.push({ path: path || '/', message: 'Value ' + data + ' must be < ' + schema.maximum + ' (exclusive)', keyword: 'exclusiveMaximum' });
      }
    }
    if (schema.hasOwnProperty('multipleOf') && typeof schema.multipleOf === 'number' && schema.multipleOf > 0) {
      const remainder = data / schema.multipleOf;
      if (Math.abs(remainder - Math.round(remainder)) > 1e-10) {
        errors.push({ path: path || '/', message: 'Value ' + data + ' is not a multiple of ' + schema.multipleOf, keyword: 'multipleOf' });
      }
    }
  }

  // ---- String validations ----
  if (typeof data === 'string') {
    if (schema.hasOwnProperty('minLength') && data.length < schema.minLength) {
      errors.push({ path: path || '/', message: 'String length ' + data.length + ' is less than minLength ' + schema.minLength, keyword: 'minLength' });
    }
    if (schema.hasOwnProperty('maxLength') && data.length > schema.maxLength) {
      errors.push({ path: path || '/', message: 'String length ' + data.length + ' exceeds maxLength ' + schema.maxLength, keyword: 'maxLength' });
    }
    if (schema.hasOwnProperty('pattern')) {
      try {
        if (!new RegExp(schema.pattern).test(data)) {
          errors.push({ path: path || '/', message: 'String does not match pattern: ' + schema.pattern, keyword: 'pattern' });
        }
      } catch (e) {
        errors.push({ path: path || '/', message: 'Invalid regex pattern: ' + schema.pattern, keyword: 'pattern' });
      }
    }
    if (schema.hasOwnProperty('format')) {
      const fmtErr = validateFormat(data, schema.format);
      if (fmtErr) {
        errors.push({ path: path || '/', message: fmtErr, keyword: 'format' });
      }
    }
  }

  // ---- Array validations ----
  if (Array.isArray(data)) {
    if (schema.hasOwnProperty('minItems') && data.length < schema.minItems) {
      errors.push({ path: path || '/', message: 'Array has ' + data.length + ' items, minimum is ' + schema.minItems, keyword: 'minItems' });
    }
    if (schema.hasOwnProperty('maxItems') && data.length > schema.maxItems) {
      errors.push({ path: path || '/', message: 'Array has ' + data.length + ' items, maximum is ' + schema.maxItems, keyword: 'maxItems' });
    }
    if (schema.uniqueItems) {
      const seen = [];
      for (let i = 0; i < data.length; i++) {
        for (let j = 0; j < seen.length; j++) {
          if (deepEqual(data[i], seen[j])) {
            errors.push({ path: path + '/' + i, message: 'Duplicate item found at index ' + i, keyword: 'uniqueItems' });
            break;
          }
        }
        seen.push(data[i]);
      }
    }
    if (schema.hasOwnProperty('contains')) {
      let found = false;
      for (let i = 0; i < data.length; i++) {
        if (validateSchema(schema.contains, data[i], rootSchema, path + '/' + i).length === 0) {
          found = true; break;
        }
      }
      if (!found) {
        errors.push({ path: path || '/', message: 'Array must contain at least one item matching the "contains" schema', keyword: 'contains' });
      }
    }
    // items
    if (schema.hasOwnProperty('items')) {
      if (Array.isArray(schema.items)) {
        // Tuple validation
        for (let i = 0; i < schema.items.length && i < data.length; i++) {
          errors.push(...validateSchema(schema.items[i], data[i], rootSchema, path + '/' + i));
        }
        if (schema.hasOwnProperty('additionalItems')) {
          if (schema.additionalItems === false && data.length > schema.items.length) {
            errors.push({ path: path || '/', message: 'Additional items are not allowed. Expected at most ' + schema.items.length + ' items', keyword: 'additionalItems' });
          } else if (typeof schema.additionalItems === 'object') {
            for (let i = schema.items.length; i < data.length; i++) {
              errors.push(...validateSchema(schema.additionalItems, data[i], rootSchema, path + '/' + i));
            }
          }
        }
      } else {
        // All items must match single schema
        for (let i = 0; i < data.length; i++) {
          errors.push(...validateSchema(schema.items, data[i], rootSchema, path + '/' + i));
        }
      }
    }
  }

  // ---- Object validations ----
  if (typeof data === 'object' && data !== null && !Array.isArray(data)) {
    const keys = Object.keys(data);

    if (schema.hasOwnProperty('minProperties') && keys.length < schema.minProperties) {
      errors.push({ path: path || '/', message: 'Object has ' + keys.length + ' properties, minimum is ' + schema.minProperties, keyword: 'minProperties' });
    }
    if (schema.hasOwnProperty('maxProperties') && keys.length > schema.maxProperties) {
      errors.push({ path: path || '/', message: 'Object has ' + keys.length + ' properties, maximum is ' + schema.maxProperties, keyword: 'maxProperties' });
    }

    // required
    if (Array.isArray(schema.required)) {
      for (const req of schema.required) {
        if (!data.hasOwnProperty(req)) {
          errors.push({ path: path || '/', message: 'Missing required property: "' + req + '"', keyword: 'required', context: 'Present keys: ' + keys.join(', ') });
        }
      }
    }

    // properties
    const validatedKeys = new Set();
    if (schema.properties) {
      for (const [key, propSchema] of Object.entries(schema.properties)) {
        if (data.hasOwnProperty(key)) {
          validatedKeys.add(key);
          errors.push(...validateSchema(propSchema, data[key], rootSchema, path + '/' + key));
        }
      }
    }

    // patternProperties
    if (schema.patternProperties) {
      for (const [pattern, propSchema] of Object.entries(schema.patternProperties)) {
        try {
          const re = new RegExp(pattern);
          for (const key of keys) {
            if (re.test(key)) {
              validatedKeys.add(key);
              errors.push(...validateSchema(propSchema, data[key], rootSchema, path + '/' + key));
            }
          }
        } catch (e) { /* skip invalid patterns */ }
      }
    }

    // additionalProperties
    if (schema.hasOwnProperty('additionalProperties')) {
      const propKeys = schema.properties ? new Set(Object.keys(schema.properties)) : new Set();
      const patternKeys = schema.patternProperties ? Object.keys(schema.patternProperties) : [];
      for (const key of keys) {
        if (propKeys.has(key)) continue;
        let matchesPattern = false;
        for (const p of patternKeys) {
          try { if (new RegExp(p).test(key)) { matchesPattern = true; break; } } catch (e) {}
        }
        if (matchesPattern) continue;
        if (schema.additionalProperties === false) {
          errors.push({ path: path + '/' + key, message: 'Additional property "' + key + '" is not allowed', keyword: 'additionalProperties' });
        } else if (typeof schema.additionalProperties === 'object') {
          errors.push(...validateSchema(schema.additionalProperties, data[key], rootSchema, path + '/' + key));
        }
      }
    }

    // propertyNames
    if (schema.propertyNames) {
      for (const key of keys) {
        const nameErrors = validateSchema(schema.propertyNames, key, rootSchema, path + '/' + key);
        if (nameErrors.length) {
          errors.push({ path: path + '/' + key, message: 'Property name "' + key + '" does not match propertyNames schema', keyword: 'propertyNames' });
        }
      }
    }

    // dependencies
    if (schema.dependencies) {
      for (const [key, dep] of Object.entries(schema.dependencies)) {
        if (!data.hasOwnProperty(key)) continue;
        if (Array.isArray(dep)) {
          for (const d of dep) {
            if (!data.hasOwnProperty(d)) {
              errors.push({ path: path || '/', message: 'Property "' + key + '" requires "' + d + '" to be present', keyword: 'dependencies' });
            }
          }
        } else if (typeof dep === 'object') {
          errors.push(...validateSchema(dep, data, rootSchema, path));
        }
      }
    }
  }

  // ---- Combinators ----
  if (schema.hasOwnProperty('allOf') && Array.isArray(schema.allOf)) {
    for (let i = 0; i < schema.allOf.length; i++) {
      const subErrors = validateSchema(schema.allOf[i], data, rootSchema, path);
      if (subErrors.length) {
        errors.push({ path: path || '/', message: 'Failed allOf sub-schema #' + (i + 1), keyword: 'allOf' });
        errors.push(...subErrors);
      }
    }
  }

  if (schema.hasOwnProperty('anyOf') && Array.isArray(schema.anyOf)) {
    let anyValid = false;
    for (const sub of schema.anyOf) {
      if (validateSchema(sub, data, rootSchema, path).length === 0) { anyValid = true; break; }
    }
    if (!anyValid) {
      errors.push({ path: path || '/', message: 'Value does not match any of the "anyOf" sub-schemas (' + schema.anyOf.length + ' schemas)', keyword: 'anyOf' });
    }
  }

  if (schema.hasOwnProperty('oneOf') && Array.isArray(schema.oneOf)) {
    let matchCount = 0;
    for (const sub of schema.oneOf) {
      if (validateSchema(sub, data, rootSchema, path).length === 0) matchCount++;
    }
    if (matchCount !== 1) {
      errors.push({ path: path || '/', message: matchCount === 0 ? 'Value does not match any of the "oneOf" sub-schemas' : 'Value matches ' + matchCount + ' of the "oneOf" sub-schemas (must match exactly one)', keyword: 'oneOf' });
    }
  }

  if (schema.hasOwnProperty('not')) {
    if (validateSchema(schema.not, data, rootSchema, path).length === 0) {
      errors.push({ path: path || '/', message: 'Value must NOT match the "not" schema', keyword: 'not' });
    }
  }

  // if / then / else
  if (schema.hasOwnProperty('if')) {
    const ifValid = validateSchema(schema.if, data, rootSchema, path).length === 0;
    if (ifValid && schema.hasOwnProperty('then')) {
      const thenErrors = validateSchema(schema.then, data, rootSchema, path);
      if (thenErrors.length) {
        errors.push({ path: path || '/', message: 'Value matches "if" but fails "then" schema', keyword: 'if/then' });
        errors.push(...thenErrors);
      }
    }
    if (!ifValid && schema.hasOwnProperty('else')) {
      const elseErrors = validateSchema(schema.else, data, rootSchema, path);
      if (elseErrors.length) {
        errors.push({ path: path || '/', message: 'Value does not match "if" and fails "else" schema', keyword: 'if/else' });
        errors.push(...elseErrors);
      }
    }
  }

  return errors;
}

/* ---- Helpers ---- */
function jsonType(v) {
  if (v === null) return 'null';
  if (Array.isArray(v)) return 'array';
  return typeof v; // 'string', 'number', 'boolean', 'object'
}

function deepEqual(a, b) {
  if (a === b) return true;
  if (a === null || b === null) return false;
  if (typeof a !== typeof b) return false;
  if (typeof a !== 'object') return false;
  if (Array.isArray(a) !== Array.isArray(b)) return false;
  if (Array.isArray(a)) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) if (!deepEqual(a[i], b[i])) return false;
    return true;
  }
  const ka = Object.keys(a).sort(), kb = Object.keys(b).sort();
  if (ka.length !== kb.length) return false;
  for (let i = 0; i < ka.length; i++) {
    if (ka[i] !== kb[i]) return false;
    if (!deepEqual(a[ka[i]], b[kb[i]])) return false;
  }
  return true;
}

function resolveRef(ref, root) {
  if (!ref.startsWith('#')) return undefined;
  if (ref === '#') return root;
  const pointer = ref.substring(1);
  const parts = pointer.split('/').filter(Boolean).map(p => p.replace(/~1/g, '/').replace(/~0/g, '~'));
  let current = root;
  for (const part of parts) {
    if (typeof current !== 'object' || current === null) return undefined;
    if (Array.isArray(current)) {
      const idx = parseInt(part, 10);
      if (isNaN(idx) || idx < 0 || idx >= current.length) return undefined;
      current = current[idx];
    } else {
      if (!current.hasOwnProperty(part)) return undefined;
      current = current[part];
    }
  }
  return current;
}

function validateFormat(value, format) {
  const formats = {
    'email': { re: /^[^\s@]+@[^\s@]+\.[^\s@]+$/, msg: 'Invalid email format' },
    'uri': { re: /^https?:\/\/.+/, msg: 'Invalid URI format' },
    'uri-reference': { re: /^(https?:\/\/|\/|#|\.\.?\/)/, msg: 'Invalid URI reference' },
    'date': { re: /^\d{4}-\d{2}-\d{2}$/, msg: 'Invalid date format (expected YYYY-MM-DD)' },
    'time': { re: /^\d{2}:\d{2}:\d{2}/, msg: 'Invalid time format (expected HH:MM:SS)' },
    'date-time': { re: /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/, msg: 'Invalid date-time format (expected ISO 8601)' },
    'ipv4': { re: /^(\d{1,3}\.){3}\d{1,3}$/, msg: 'Invalid IPv4 address', validate: v => v.split('.').every(o => { const n = parseInt(o); return n >= 0 && n <= 255; }) },
    'ipv6': { re: /^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$/, msg: 'Invalid IPv6 address' },
    'hostname': { re: /^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?)*$/, msg: 'Invalid hostname' },
    'uuid': { re: /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i, msg: 'Invalid UUID format' },
    'json-pointer': { re: /^(\/[^/~]*(~[01][^/~]*)*)*$/, msg: 'Invalid JSON pointer' },
    'regex': { validate: v => { try { new RegExp(v); return true; } catch(e) { return false; } }, msg: 'Invalid regex pattern' }
  };
  const fmt = formats[format];
  if (!fmt) return null; // Unknown format: pass
  if (fmt.re && !fmt.re.test(value)) return fmt.msg;
  if (fmt.validate && !fmt.validate(value)) return fmt.msg;
  return null;
}

function truncate(s, n) { return s.length > n ? s.substring(0, n) + '...' : s; }

/* ---- Draft Detection ---- */
function detectDraft(schema) {
  if (!schema || typeof schema !== 'object') return 'Unknown';
  const s = schema.$schema || '';
  if (s.includes('draft-07') || s.includes('draft/2019') || s.includes('draft/2020')) return s.includes('2020') ? 'Draft 2020-12' : s.includes('2019') ? 'Draft 2019-09' : 'Draft 7';
  if (s.includes('draft-06')) return 'Draft 6';
  if (s.includes('draft-04')) return 'Draft 4';
  // Heuristic: check keywords
  if (schema.hasOwnProperty('if') || schema.hasOwnProperty('then') || schema.hasOwnProperty('else') || schema.hasOwnProperty('contains') || schema.hasOwnProperty('propertyNames') || schema.hasOwnProperty('const')) return 'Draft 7 (detected)';
  if (typeof schema.exclusiveMinimum === 'number' || typeof schema.exclusiveMaximum === 'number') return 'Draft 6 (detected)';
  if (typeof schema.exclusiveMinimum === 'boolean') return 'Draft 4 (detected)';
  return 'Draft 7 (assumed)';
}

/* ===================================================================
   UI Functions
   =================================================================== */
function validateAll() {
  const schemaRaw = schemaInput.value.trim();
  const dataRaw = dataInput.value.trim();

  // Clear highlights
  clearHighlights();

  if (!schemaRaw && !dataRaw) {
    statusDot.className = 'status-dot empty';
    statusText.textContent = 'Paste a schema and data to begin';
    draftBadge.style.display = 'none';
    errorCountEl.textContent = '';
    resultsBody.innerHTML = '<div style="color:var(--text2);font-size:.85rem;text-align:center;padding:2rem">Enter a JSON Schema and JSON data, then click Validate</div>';
    resultsSummary.textContent = '';
    return;
  }

  if (!schemaRaw) {
    showStatus('warning', 'No schema provided');
    resultsBody.innerHTML = '<div style="color:var(--yellow);font-size:.85rem;padding:1rem">Please enter a JSON Schema in the left panel.</div>';
    return;
  }
  if (!dataRaw) {
    showStatus('warning', 'No data provided');
    resultsBody.innerHTML = '<div style="color:var(--yellow);font-size:.85rem;padding:1rem">Please enter JSON data in the right panel.</div>';
    return;
  }

  let schema, data;
  try {
    schema = JSON.parse(schemaRaw);
  } catch (e) {
    showStatus('invalid', 'Invalid JSON in schema');
    resultsBody.innerHTML = '<div class="error-item"><span class="error-path">Schema Parse Error</span><span class="error-msg">' + escapeHtml(e.message) + '</span></div>';
    resultsSummary.textContent = 'Schema error';
    schemaInfo.textContent = 'Invalid JSON';
    return;
  }
  try {
    data = JSON.parse(dataRaw);
  } catch (e) {
    showStatus('invalid', 'Invalid JSON in data');
    const posMatch = e.message.match(/position\s+(\d+)/i);
    let lineNum = null;
    if (posMatch) lineNum = dataRaw.substring(0, parseInt(posMatch[1])).split('\n').length;
    resultsBody.innerHTML = '<div class="error-item"><span class="error-path">Data Parse Error' + (lineNum ? ' (line ' + lineNum + ')' : '') + '</span><span class="error-msg">' + escapeHtml(e.message) + '</span></div>';
    resultsSummary.textContent = 'Parse error';
    dataInfo.textContent = 'Invalid JSON';
    if (lineNum) highlightLine(lineNum);
    return;
  }

  // Update info
  schemaInfo.textContent = formatBytes(new Blob([schemaRaw]).size);
  dataInfo.textContent = formatBytes(new Blob([dataRaw]).size);

  // Detect draft
  const draft = detectDraft(schema);
  draftBadge.textContent = draft;
  draftBadge.style.display = 'inline-block';

  // Validate
  const errors = validateSchema(schema, data, schema, '');
  lastErrors = errors;

  if (errors.length === 0) {
    showStatus('valid', 'Valid — Data matches schema');
    errorCountEl.textContent = '';
    resultsSummary.textContent = 'All checks passed';
    resultsBody.innerHTML = '<div class="result-success"><span class="icon">&#10003;</span>JSON data is valid against the schema. All constraints passed.</div>';
    lastResultText = 'VALID: JSON data matches the schema.';
  } else {
    showStatus('invalid', errors.length + ' validation error' + (errors.length > 1 ? 's' : ''));
    errorCountEl.textContent = errors.length + ' error' + (errors.length > 1 ? 's' : '');
    resultsSummary.textContent = errors.length + ' error' + (errors.length > 1 ? 's' : '') + ' found';

    let html = '<ul class="error-list">';
    const errorLineMap = new Set();
    for (const err of errors) {
      html += '<li class="error-item">';
      html += '<span class="error-path">' + escapeHtml(err.path || '/') + '<span class="error-keyword">' + escapeHtml(err.keyword) + '</span></span>';
      html += '<span class="error-msg">' + escapeHtml(err.message) + '</span>';
      if (err.context) html += '<span class="error-context">' + escapeHtml(err.context) + '</span>';
      html += '</li>';

      // Try to find line numbers for error paths in data
      const line = findLineForPath(dataRaw, err.path);
      if (line) errorLineMap.add(line);
    }
    html += '</ul>';
    resultsBody.innerHTML = html;

    // Highlight error lines
    for (const line of errorLineMap) highlightLine(line);

    lastResultText = errors.map(e => e.path + ': ' + e.message + ' [' + e.keyword + ']').join('\n');
  }
}

function findLineForPath(jsonStr, path) {
  if (!path || path === '/') return null;
  const parts = path.split('/').filter(Boolean);
  // Build a search string from the last path segment
  const lastPart = parts[parts.length - 1];
  // Search for the key in the JSON string
  const lines = jsonStr.split('\n');
  const needle = '"' + lastPart + '"';
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].includes(needle)) return i + 1;
  }
  return null;
}

function highlightLine(lineNum) {
  const wrap = dataEditorWrap;
  const textarea = dataInput;
  const lineHeight = parseFloat(getComputedStyle(textarea).lineHeight) || (parseFloat(getComputedStyle(textarea).fontSize) * 1.7);
  const paddingTop = parseFloat(getComputedStyle(textarea).paddingTop) || 16;

  const marker = document.createElement('div');
  marker.className = 'line-highlight';
  marker.style.top = (paddingTop + (lineNum - 1) * lineHeight - textarea.scrollTop) + 'px';
  marker.style.height = lineHeight + 'px';
  wrap.appendChild(marker);
}

function clearHighlights() {
  const markers = dataEditorWrap.querySelectorAll('.line-highlight');
  markers.forEach(m => m.remove());
}

function showStatus(type, text) {
  statusDot.className = 'status-dot ' + type;
  statusText.textContent = text;
}

function formatBoth() {
  try {
    const s = JSON.parse(schemaInput.value);
    schemaInput.value = JSON.stringify(s, null, 2);
  } catch (e) {}
  try {
    const d = JSON.parse(dataInput.value);
    dataInput.value = JSON.stringify(d, null, 2);
  } catch (e) {}
  showToast('Formatted both editors');
}

function copyResult() {
  if (!lastResultText) { showToast('Nothing to copy'); return; }
  navigator.clipboard.writeText(lastResultText).then(() => showToast('Result copied to clipboard'));
}

function clearAll() {
  schemaInput.value = '';
  dataInput.value = '';
  lastErrors = [];
  lastResultText = '';
  clearHighlights();
  statusDot.className = 'status-dot empty';
  statusText.textContent = 'Paste a schema and data to begin';
  draftBadge.style.display = 'none';
  errorCountEl.textContent = '';
  schemaInfo.textContent = '';
  dataInfo.textContent = '';
  resultsBody.innerHTML = '<div style="color:var(--text2);font-size:.85rem;text-align:center;padding:2rem">Enter a JSON Schema and JSON data, then click Validate</div>';
  resultsSummary.textContent = '';
  document.getElementById('sampleSelect').value = '';
}

function loadFile(event, target) {
  const file = event.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(e) {
    if (target === 'schema') schemaInput.value = e.target.result;
    else dataInput.value = e.target.result;
    showToast('Loaded ' + file.name);
    autoValidate();
  };
  reader.readAsText(file);
  event.target.value = '';
}

function insertHint(keyword) {
  const textarea = schemaInput;
  const start = textarea.selectionStart;
  const snippets = {
    'type': '"type": "object"',
    'properties': '"properties": {\n    "key": { "type": "string" }\n  }',
    'required': '"required": ["key"]',
    'items': '"items": { "type": "string" }',
    'enum': '"enum": ["a", "b", "c"]',
    'pattern': '"pattern": "^[a-z]+$"',
    'minimum': '"minimum": 0',
    'anyOf': '"anyOf": [\n    { "type": "string" },\n    { "type": "number" }\n  ]',
    '$ref': '"$ref": "#/definitions/MyType"'
  };
  const text = snippets[keyword] || ('"' + keyword + '": ');
  textarea.value = textarea.value.substring(0, start) + text + textarea.value.substring(textarea.selectionEnd);
  textarea.selectionStart = textarea.selectionEnd = start + text.length;
  textarea.focus();
}

/* ---- Sample Schemas ---- */
const SAMPLES = {
  string: {
    schema: {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "String Validation",
      "type": "string",
      "minLength": 3,
      "maxLength": 50,
      "pattern": "^[A-Za-z ]+$"
    },
    data: "Hello World"
  },
  object: {
    schema: {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User Profile",
      "type": "object",
      "properties": {
        "name": { "type": "string", "minLength": 1 },
        "age": { "type": "integer", "minimum": 0, "maximum": 150 },
        "email": { "type": "string", "format": "email" },
        "active": { "type": "boolean" }
      },
      "required": ["name", "email"],
      "additionalProperties": false
    },
    data: { "name": "Alice", "age": 30, "email": "alice@example.com", "active": true }
  },
  array: {
    schema: {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Tag List",
      "type": "array",
      "items": { "type": "string", "minLength": 1 },
      "minItems": 1,
      "maxItems": 10,
      "uniqueItems": true
    },
    data: ["javascript", "typescript", "react", "node"]
  },
  nested: {
    schema: {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Company",
      "type": "object",
      "properties": {
        "name": { "type": "string" },
        "address": {
          "type": "object",
          "properties": {
            "street": { "type": "string" },
            "city": { "type": "string" },
            "zip": { "type": "string", "pattern": "^\\d{5}(-\\d{4})?$" }
          },
          "required": ["street", "city"]
        },
        "employees": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "name": { "type": "string" },
              "role": { "type": "string" },
              "salary": { "type": "number", "minimum": 0 }
            },
            "required": ["name", "role"]
          }
        }
      },
      "required": ["name"]
    },
    data: {
      "name": "NexTool Inc.",
      "address": { "street": "123 AI Blvd", "city": "San Francisco", "zip": "94105" },
      "employees": [
        { "name": "Alice", "role": "Engineer", "salary": 120000 },
        { "name": "Bob", "role": "Designer", "salary": 95000 }
      ]
    }
  },
  enum: {
    schema: {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Configuration",
      "type": "object",
      "properties": {
        "logLevel": { "enum": ["debug", "info", "warn", "error"] },
        "maxRetries": { "const": 3 },
        "environment": { "type": "string", "enum": ["development", "staging", "production"] }
      },
      "required": ["logLevel", "environment"]
    },
    data: { "logLevel": "info", "maxRetries": 3, "environment": "production" }
  },
  combinators: {
    schema: {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Shape",
      "oneOf": [
        {
          "type": "object",
          "properties": {
            "shape": { "const": "circle" },
            "radius": { "type": "number", "exclusiveMinimum": 0 }
          },
          "required": ["shape", "radius"]
        },
        {
          "type": "object",
          "properties": {
            "shape": { "const": "rectangle" },
            "width": { "type": "number", "exclusiveMinimum": 0 },
            "height": { "type": "number", "exclusiveMinimum": 0 }
          },
          "required": ["shape", "width", "height"]
        }
      ]
    },
    data: { "shape": "circle", "radius": 5 }
  },
  pattern: {
    schema: {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Contact Info",
      "type": "object",
      "properties": {
        "phone": { "type": "string", "pattern": "^\\+?[1-9]\\d{6,14}$" },
        "website": { "type": "string", "format": "uri" },
        "birthday": { "type": "string", "format": "date" },
        "id": { "type": "string", "format": "uuid" }
      },
      "required": ["phone"]
    },
    data: {
      "phone": "+14155552671",
      "website": "https://nextool.app",
      "birthday": "1990-06-15",
      "id": "550e8400-e29b-41d4-a716-446655440000"
    }
  },
  ref: {
    schema: {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Order",
      "definitions": {
        "address": {
          "type": "object",
          "properties": {
            "street": { "type": "string" },
            "city": { "type": "string" },
            "country": { "type": "string", "minLength": 2 }
          },
          "required": ["street", "city", "country"]
        },
        "product": {
          "type": "object",
          "properties": {
            "name": { "type": "string" },
            "price": { "type": "number", "minimum": 0 },
            "quantity": { "type": "integer", "minimum": 1 }
          },
          "required": ["name", "price", "quantity"]
        }
      },
      "type": "object",
      "properties": {
        "orderId": { "type": "string" },
        "shipping": { "$ref": "#/definitions/address" },
        "billing": { "$ref": "#/definitions/address" },
        "items": { "type": "array", "items": { "$ref": "#/definitions/product" }, "minItems": 1 }
      },
      "required": ["orderId", "shipping", "items"]
    },
    data: {
      "orderId": "ORD-2026-001",
      "shipping": { "street": "123 Main St", "city": "Austin", "country": "US" },
      "billing": { "street": "456 Oak Ave", "city": "Austin", "country": "US" },
      "items": [
        { "name": "NexTool Pro", "price": 29, "quantity": 1 },
        { "name": "Custom Chatbot", "price": 149, "quantity": 2 }
      ]
    }
  }
};

function loadSample(name) {
  if (!name || !SAMPLES[name]) return;
  const sample = SAMPLES[name];
  schemaInput.value = JSON.stringify(sample.schema, null, 2);
  dataInput.value = JSON.stringify(sample.data, null, 2);
  showToast('Loaded sample: ' + name);
  setTimeout(validateAll, 100);
}

/* ---- Utility ---- */
function escapeHtml(s) { return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }

function formatBytes(bytes) {
  if (bytes === 0) return '0 B';
  const k = 1024, sizes = ['B', 'KB', 'MB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}

function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 2000);
}

/* Scroll sync for highlights */
dataInput.addEventListener('scroll', () => {
  const markers = dataEditorWrap.querySelectorAll('.line-highlight');
  const lineHeight = parseFloat(getComputedStyle(dataInput).lineHeight) || (parseFloat(getComputedStyle(dataInput).fontSize) * 1.7);
  const paddingTop = parseFloat(getComputedStyle(dataInput).paddingTop) || 16;
  // Recalculate isn't practical per-scroll, so just hide stale markers
  markers.forEach(m => m.style.display = 'none');
});

/* IntersectionObserver fade-in */
const observer = new IntersectionObserver(entries => {
  entries.forEach(entry => { if (entry.isIntersecting) { entry.target.classList.add('visible'); observer.unobserve(entry.target); }});
}, { threshold: 0.1 });
document.querySelectorAll('.fade-in').forEach(el => observer.observe(el));
</script>
<script src="/js/analytics-lite.js" defer></script>
<script src="/js/revenue.js" defer></script>
<script src="/js/lead-capture.js" defer></script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "FAQPage",
  "mainEntity": [
    {
      "@type": "Question",
      "name": "What is JSON Schema validation?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "JSON Schema validation checks whether a JSON document conforms to a defined structure (schema). The schema specifies data types, required fields, value constraints, and patterns. NexTool's validator supports JSON Schema Draft 4, 6, and 7 with detailed error reporting."
      }
    },
    {
      "@type": "Question",
      "name": "What JSON Schema drafts are supported?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "NexTool's JSON Schema Validator supports Draft 4, Draft 6, and Draft 7 features including type, required, properties, items, minimum/maximum, pattern, enum, const, anyOf, oneOf, allOf, not, $ref, if/then/else, format validation, and more. The draft version is auto-detected from the schema."
      }
    },
    {
      "@type": "Question",
      "name": "Is this JSON Schema validator free?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "Yes, NexTool's JSON Schema Validator is completely free. It runs entirely in your browser with no server calls, so your data stays private. No signup or installation required."
      }
    },
    {
      "@type": "Question",
      "name": "Does the validator show error line numbers?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "Yes, the validator provides detailed error messages with JSON paths, keyword context, and highlights the corresponding lines in the data editor. Each error shows the exact path to the failing value and which schema keyword caused the failure."
      }
    }
  ]
}
</script>
</body>
</html>
