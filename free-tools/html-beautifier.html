<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Free HTML Beautifier — Format & Indent HTML Code | NexTool</title>
<meta name="description" content="Free online HTML beautifier and formatter. Pretty print HTML with proper indentation, syntax highlighting, attribute wrapping, and minification. No signup required.">
<meta name="keywords" content="HTML beautifier, HTML formatter, HTML pretty print, HTML indent, HTML minifier, format HTML code, free online tool, NexTool">
<meta name="robots" content="index, follow">
<meta property="og:title" content="Free HTML Beautifier — Format & Indent HTML Code | NexTool">
<meta property="og:description" content="Beautify, format, and minify HTML instantly. Custom indentation, attribute wrapping, syntax highlighting. 100% free.">
<meta property="og:type" content="website">
<meta property="og:url" content="https://nextool.app/free-tools/html-beautifier.html">
<meta property="og:image" content="https://nextool.app/assets/og-default.png">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<link rel="canonical" href="https://nextool.app/free-tools/html-beautifier.html">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Free HTML Beautifier — Format & Indent HTML Code | NexTool">
<meta name="twitter:description" content="Beautify, format, and minify HTML instantly. Free online tool by NexTool.">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"SoftwareApplication","name":"NexTool HTML Beautifier","applicationCategory":"DeveloperApplication","operatingSystem":"Web","offers":{"@type":"Offer","price":"0","priceCurrency":"USD"},"description":"Free online HTML beautifier and formatter with syntax highlighting, custom indentation, attribute wrapping, and minification."}
</script>
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{--bg:#050508;--surface:#111118;--surface2:#1a1a24;--border:#2a2a3a;--text:#e4e4eb;--text2:#9494a8;--primary:#6366f1;--accent:#a855f7;--pink:#ec4899;--green:#22c55e;--red:#ef4444;--cyan:#22d3ee;--yellow:#eab308;--radius:12px;--glass:rgba(17,17,24,0.7)}
html{scroll-behavior:smooth}
body{font-family:'Inter',system-ui,sans-serif;background:var(--bg);color:var(--text);line-height:1.6;min-height:100vh;overflow-x:hidden}
/* NAV */
.nav{position:sticky;top:0;z-index:100;background:rgba(5,5,8,0.85);backdrop-filter:blur(20px);border-bottom:1px solid var(--border);padding:0 2rem;height:64px;display:flex;align-items:center;justify-content:space-between}
.nav-logo{font-size:1.4rem;font-weight:800;background:linear-gradient(135deg,var(--primary),var(--accent));-webkit-background-clip:text;-webkit-text-fill-color:transparent;text-decoration:none}
.nav-links{display:flex;align-items:center;gap:1.5rem}
.nav-links a{color:var(--text2);text-decoration:none;font-size:.875rem;font-weight:500;transition:color .2s}
.nav-links a:hover{color:var(--text)}
.nav-cta{background:linear-gradient(135deg,var(--primary),var(--accent));color:#fff!important;padding:.5rem 1.2rem;border-radius:8px;font-weight:600;-webkit-text-fill-color:#fff!important}
.nav-cta:hover{opacity:.9}
.nav-toggle{display:none;background:none;border:none;color:var(--text);font-size:1.5rem;cursor:pointer}
/* HERO */
.hero{text-align:center;padding:3rem 1.5rem 2rem;max-width:700px;margin:0 auto}
.hero h1{font-size:2.2rem;font-weight:800;line-height:1.2;margin-bottom:.75rem}
.hero h1 span{background:linear-gradient(135deg,var(--primary),var(--accent),var(--pink));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.hero p{color:var(--text2);font-size:1rem}
/* TOOL */
.tool-container{max-width:1200px;margin:0 auto;padding:0 1.5rem 3rem}
.toolbar{display:flex;flex-wrap:wrap;gap:.5rem;margin-bottom:1rem;align-items:center}
.toolbar button,.toolbar select,.toolbar label{background:var(--surface2);border:1px solid var(--border);color:var(--text);padding:.45rem .9rem;border-radius:8px;font-size:.8rem;font-weight:500;cursor:pointer;transition:all .2s;font-family:inherit}
.toolbar button:hover{border-color:var(--primary);background:rgba(99,102,241,.12)}
.toolbar button.active{background:linear-gradient(135deg,var(--primary),var(--accent));border-color:transparent;color:#fff}
.toolbar select{appearance:none;padding-right:1.8rem;background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%239494a8' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10z'/%3E%3C/svg%3E");background-repeat:no-repeat;background-position:right .6rem center}
.toolbar label{cursor:pointer;display:flex;align-items:center;gap:.4rem;user-select:none}
.toolbar label input[type="checkbox"]{accent-color:var(--primary);width:14px;height:14px;cursor:pointer}
.status-bar{display:flex;align-items:center;gap:1rem;margin-bottom:1rem;font-size:.8rem;color:var(--text2);flex-wrap:wrap}
.status-dot{width:8px;height:8px;border-radius:50%;display:inline-block}
.status-dot.valid{background:var(--green)}
.status-dot.invalid{background:var(--red)}
.status-dot.empty{background:var(--border)}
.panels{display:grid;grid-template-columns:1fr 1fr;gap:1rem;min-height:500px}
.panel{background:var(--glass);backdrop-filter:blur(16px);border:1px solid var(--border);border-radius:var(--radius);overflow:hidden;display:flex;flex-direction:column}
.panel-header{padding:.6rem 1rem;border-bottom:1px solid var(--border);font-size:.8rem;font-weight:600;color:var(--text2);display:flex;justify-content:space-between;align-items:center;background:rgba(26,26,36,0.5)}
.panel-body{flex:1;position:relative;overflow:auto}
#htmlInput{width:100%;height:100%;min-height:400px;background:transparent;border:none;color:var(--text);font-family:'Courier New',monospace;font-size:.85rem;padding:1rem;resize:none;outline:none;line-height:1.7;tab-size:2}
#htmlInput::placeholder{color:var(--text2);opacity:.5}
.output-area{padding:1rem;font-family:'Courier New',monospace;font-size:.85rem;line-height:1.7;white-space:pre-wrap;word-break:break-all;min-height:400px}
/* SYNTAX HIGHLIGHTING */
.hl-tag{color:#c084fc}
.hl-attr{color:var(--cyan)}
.hl-val{color:#4ade80}
.hl-comment{color:#6b7280;font-style:italic}
.hl-doctype{color:var(--yellow)}
.hl-text{color:var(--text)}
.hl-bracket{color:var(--text2)}
.hl-entity{color:var(--pink)}
/* CTA */
.cta-section{text-align:center;padding:4rem 1.5rem;max-width:700px;margin:0 auto}
.cta-section h2{font-size:1.8rem;font-weight:800;margin-bottom:.75rem}
.cta-section h2 span{background:linear-gradient(135deg,var(--primary),var(--accent));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.cta-section p{color:var(--text2);margin-bottom:1.5rem}
.cta-btn{display:inline-block;background:linear-gradient(135deg,var(--primary),var(--accent));color:#fff;padding:.75rem 2rem;border-radius:10px;font-weight:700;text-decoration:none;font-size:1rem;transition:transform .2s,box-shadow .2s}
.cta-btn:hover{transform:translateY(-2px);box-shadow:0 8px 30px rgba(99,102,241,.3)}
/* FOOTER */
.footer{border-top:1px solid var(--border);padding:3rem 2rem 2rem;max-width:1200px;margin:0 auto}
.footer-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:2rem;margin-bottom:2rem}
.footer-col h4{font-size:.85rem;font-weight:700;margin-bottom:.75rem;color:var(--text)}
.footer-col a{display:block;color:var(--text2);text-decoration:none;font-size:.8rem;margin-bottom:.4rem;transition:color .2s}
.footer-col a:hover{color:var(--primary)}
.footer-bottom{text-align:center;color:var(--text2);font-size:.75rem;padding-top:1.5rem;border-top:1px solid var(--border)}
/* FADE IN */
.fade-in{opacity:0;transform:translateY(20px);transition:opacity .6s,transform .6s}
.fade-in.visible{opacity:1;transform:translateY(0)}
/* TOAST */
.toast{position:fixed;bottom:2rem;left:50%;transform:translateX(-50%) translateY(80px);background:var(--surface2);border:1px solid var(--border);color:var(--text);padding:.6rem 1.2rem;border-radius:10px;font-size:.85rem;font-weight:500;z-index:200;transition:transform .3s;pointer-events:none}
.toast.show{transform:translateX(-50%) translateY(0)}
/* RESPONSIVE */
@media(max-width:768px){
  .panels{grid-template-columns:1fr}
  .nav-links{display:none;position:absolute;top:64px;left:0;right:0;background:var(--bg);border-bottom:1px solid var(--border);flex-direction:column;padding:1rem 2rem;gap:1rem}
  .nav-links.open{display:flex}
  .nav-toggle{display:block}
  .hero h1{font-size:1.6rem}
  .footer-grid{grid-template-columns:1fr}
  .toolbar{gap:.35rem}
}
</style>
</head>
<body>

<nav class="nav">
  <a href="/" class="nav-logo">NexTool</a>
  <button class="nav-toggle" onclick="document.querySelector('.nav-links').classList.toggle('open')" aria-label="Menu">&#9776;</button>
  <div class="nav-links">
    <a href="/">Home</a>
    <a href="/free-tools/">Tools</a>
    <a href="/free-tools/">Free Tools</a>
    <a href="/blog/">Blog</a>
    <a href="/pro.html" class="nav-cta">Get Pro — $29</a>
  </div>
</nav>

<section class="hero fade-in">
  <h1>Free <span>HTML Beautifier</span> & Formatter</h1>
  <p class="tool-summary" style="color:#94a3b8;font-size:15px;line-height:1.6;margin-bottom:24px;max-width:700px;margin-left:auto;margin-right:auto;">NexTool's HTML Beautifier is a free, browser-based tool that formats and indents HTML code instantly. Customize indentation, wrap attributes, preserve inline elements, or minify your markup. Includes syntax highlighting and runs entirely in your browser for privacy and speed.</p>
</section>

<div class="tool-container fade-in">
  <div class="toolbar">
    <button onclick="beautifyHTML()" title="Beautify HTML">Beautify</button>
    <button onclick="minifyHTML()" title="Minify HTML">Minify</button>
    <button onclick="copyOutput()" title="Copy to clipboard">Copy</button>
    <button onclick="downloadHTML()" title="Download .html">Download</button>
    <select id="indentSelect" onchange="beautifyHTML()">
      <option value="2">2 spaces</option>
      <option value="4">4 spaces</option>
      <option value="8">8 spaces</option>
      <option value="tab">Tab</option>
    </select>
    <label title="Keep inline elements (span, a, strong, em, etc.) on one line"><input type="checkbox" id="preserveInline" checked onchange="beautifyHTML()"> Inline</label>
    <label title="Put each attribute on its own line"><input type="checkbox" id="wrapAttrs" onchange="beautifyHTML()"> Wrap Attrs</label>
    <button onclick="clearAll()" title="Clear input and output">Clear</button>
    <button onclick="loadSample()" title="Load sample HTML">Sample</button>
  </div>

  <div class="status-bar">
    <span><span class="status-dot empty" id="statusDot"></span></span>
    <span id="statusText">Paste HTML to begin</span>
    <span id="sizeInfo" style="margin-left:auto"></span>
  </div>

  <div class="panels">
    <div class="panel">
      <div class="panel-header"><span>Input</span><span id="lineCount"></span></div>
      <div class="panel-body">
        <textarea id="htmlInput" placeholder='Paste your HTML here...&#10;&#10;Example:&#10;<div class="container"><h1>Hello</h1><p>World</p></div>' spellcheck="false"></textarea>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"><span id="outputLabel">Output</span><span id="outputInfo"></span></div>
      <div class="panel-body" id="outputPanel">
        <div class="output-area" id="formattedOutput"></div>
      </div>
    </div>
  </div>
</div>

<section class="cta-section fade-in">
  <h2>Need something <span>more powerful</span>?</h2>
  <p>Let us build it for you. Custom APIs, dashboards, automations &mdash; whatever you need.</p>
  <a href="/#contact" class="cta-btn">Start a Project &rarr;</a>
</section>

<!-- Cross Promo -->
<section style="max-width:900px;margin:40px auto;padding:0 24px;">
<div style="background:linear-gradient(135deg,rgba(99,102,241,0.1),rgba(168,85,247,0.08));border:1px solid rgba(99,102,241,0.15);border-radius:20px;padding:32px 28px;text-align:center;">
<div style="font-size:13px;color:#818cf8;font-weight:600;text-transform:uppercase;letter-spacing:1px;margin-bottom:8px;">Founding Member</div>
<h3 style="font-size:22px;font-weight:800;color:#fff;margin:0 0 8px;">Get NexTool Pro</h3>
<p style="color:#94a3b8;font-size:14px;margin:0 auto 20px;max-width:500px;">No banners, clean output, enhanced features on all 245+ tools. One-time payment.</p>
<div style="display:flex;align-items:center;justify-content:center;gap:12px;flex-wrap:wrap;">
<a href="/pro.html" style="display:inline-block;padding:12px 28px;background:linear-gradient(135deg,#6366f1,#a855f7,#ec4899);color:#fff;border-radius:10px;font-weight:700;font-size:15px;text-decoration:none;">$29 — Get Pro</a>
<a href="/free-tools/" style="color:#94a3b8;font-size:14px;text-decoration:none;">Browse 245+ Free Tools &rarr;</a>
</div>
</div>
</section>


<!-- AUTO-LINKED by NexTool Engine -->
<div style="margin:2rem 0;padding:1.5rem;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius)">
<p style="font-weight:600;margin-bottom:.5rem">Related Tools</p>
<p><a href="/free-tools/html-formatter.html" style="color:var(--primary);text-decoration:none">HTML Beautifier &amp; Minifier</a> · <a href="/free-tools/box-shadow-generator.html" style="color:var(--primary);text-decoration:none">CSS Box Shadow Generator</a> · <a href="/free-tools/emoji-picker.html" style="color:var(--primary);text-decoration:none">Emoji Picker & Search</a></p>
</div>

<!-- AUTO-LINKED by NexTool Engine -->
<div style="margin:2rem 0;padding:1.5rem;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius)">
<p style="font-weight:600;margin-bottom:.5rem">Related Tools</p>
<p><a href="/free-tools/git-diff-viewer.html" style="color:var(--primary);text-decoration:none">Free Git Diff Viewer</a> · <a href="/free-tools/json-to-yaml-converter.html" style="color:var(--primary);text-decoration:none">Free JSON to YAML Converter</a> · <a href="/free-tools/accessibility-checker.html" style="color:var(--primary);text-decoration:none">Free Accessibility Checker</a></p>
</div>
<footer class="footer fade-in">
  <div class="footer-grid">
    <div class="footer-col">
      <h4>Products</h4>
      <a href="/free-tools/">245+ Free Tools</a>
<a href="/pro.html">NexTool Pro</a>
<a href="/workspace.html">Workspace</a>
    </div>
    <div class="footer-col">
      <h4>Explore</h4>
      <a href="/free-tools/">Free Tools</a><a href="/blog/">Blog</a><a href="/pro.html">FAQ</a><a href="/pro.html">Pro — $29</a>
    </div>
    <div class="footer-col">
      <h4>Ecosystem</h4>
      <a href="/">NexTool Home</a><a href="/#contact">Contact</a><a href="https://github.com/christian140903-sudo/nextool" target="_blank">GitHub</a>
    </div>
  </div>
  <div class="footer-bottom">&copy; 2026 NexTool. AI-powered tools for everyone.</div>
</footer>

<div class="toast" id="toast"></div>

<script>
const input = document.getElementById('htmlInput');
const formattedOutput = document.getElementById('formattedOutput');
const statusDot = document.getElementById('statusDot');
const statusText = document.getElementById('statusText');
const sizeInfo = document.getElementById('sizeInfo');
const lineCount = document.getElementById('lineCount');
const outputLabel = document.getElementById('outputLabel');
const outputInfo = document.getElementById('outputInfo');
let lastFormatted = '';

input.addEventListener('input', debounce(autoProcess, 400));
input.addEventListener('input', updateLineCount);

function debounce(fn, ms) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); }; }

function updateLineCount() {
  const lines = input.value.split('\n').length;
  lineCount.textContent = lines + ' line' + (lines !== 1 ? 's' : '');
}

function autoProcess() {
  const raw = input.value;
  if (!raw.trim()) {
    formattedOutput.innerHTML = '';
    statusDot.className = 'status-dot empty';
    statusText.textContent = 'Paste HTML to begin';
    sizeInfo.textContent = '';
    outputInfo.textContent = '';
    lastFormatted = '';
    return;
  }
  sizeInfo.textContent = formatBytes(new Blob([raw]).size);
  beautifyHTML();
}

/* ========== CORE HTML BEAUTIFIER ENGINE ========== */

// Void (self-closing) elements that should never have a closing tag
const VOID_ELEMENTS = new Set([
  'area','base','br','col','embed','hr','img','input','link','meta',
  'param','source','track','wbr','command','keygen','menuitem'
]);

// Inline elements that can optionally be kept on one line
const INLINE_ELEMENTS = new Set([
  'a','abbr','acronym','b','bdo','big','br','button','cite','code',
  'dfn','em','i','img','input','kbd','label','map','object','output',
  'q','samp','select','small','span','strong','sub','sup','textarea',
  'time','tt','u','var','mark','ruby','rt','rp','wbr'
]);

// Raw content elements whose inner text should not be modified
const RAW_ELEMENTS = new Set(['script','style','pre','code','textarea','xmp']);

function getIndentStr() {
  const sel = document.getElementById('indentSelect').value;
  return sel === 'tab' ? '\t' : ' '.repeat(parseInt(sel));
}

function tokenizeHTML(html) {
  const tokens = [];
  let i = 0;
  const len = html.length;

  while (i < len) {
    // Comment
    if (html.substr(i, 4) === '<!--') {
      const end = html.indexOf('-->', i + 4);
      if (end === -1) {
        tokens.push({ type: 'comment', value: html.substring(i) });
        break;
      }
      tokens.push({ type: 'comment', value: html.substring(i, end + 3) });
      i = end + 3;
      continue;
    }

    // Doctype
    if (html.substr(i, 9).toLowerCase() === '<!doctype') {
      const end = html.indexOf('>', i);
      if (end === -1) {
        tokens.push({ type: 'doctype', value: html.substring(i) });
        break;
      }
      tokens.push({ type: 'doctype', value: html.substring(i, end + 1) });
      i = end + 1;
      continue;
    }

    // CDATA
    if (html.substr(i, 9) === '<![CDATA[') {
      const end = html.indexOf(']]>', i + 9);
      if (end === -1) {
        tokens.push({ type: 'cdata', value: html.substring(i) });
        break;
      }
      tokens.push({ type: 'cdata', value: html.substring(i, end + 3) });
      i = end + 3;
      continue;
    }

    // Closing tag
    if (html.substr(i, 2) === '</') {
      const end = html.indexOf('>', i);
      if (end === -1) {
        tokens.push({ type: 'text', value: html.substring(i) });
        break;
      }
      const tag = html.substring(i, end + 1);
      const nameMatch = tag.match(/^<\/\s*([a-zA-Z][a-zA-Z0-9-]*)/);
      tokens.push({
        type: 'close',
        value: tag,
        tagName: nameMatch ? nameMatch[1].toLowerCase() : ''
      });
      i = end + 1;
      continue;
    }

    // Opening tag (or self-closing)
    if (html[i] === '<' && i + 1 < len && /[a-zA-Z]/.test(html[i + 1])) {
      const end = findTagEnd(html, i);
      if (end === -1) {
        tokens.push({ type: 'text', value: html.substring(i) });
        break;
      }
      const tag = html.substring(i, end + 1);
      const nameMatch = tag.match(/^<\s*([a-zA-Z][a-zA-Z0-9-]*)/);
      const tagName = nameMatch ? nameMatch[1].toLowerCase() : '';
      const selfClosing = tag.endsWith('/>') || VOID_ELEMENTS.has(tagName);

      tokens.push({
        type: selfClosing ? 'selfclose' : 'open',
        value: tag,
        tagName: tagName,
        attrs: parseAttributes(tag)
      });
      i = end + 1;

      // For raw elements, grab everything until closing tag as raw text
      if (RAW_ELEMENTS.has(tagName) && !selfClosing) {
        const closePattern = '</' + tagName;
        let rawEnd = html.toLowerCase().indexOf(closePattern, i);
        if (rawEnd === -1) rawEnd = len;
        if (rawEnd > i) {
          tokens.push({ type: 'rawtext', value: html.substring(i, rawEnd) });
          i = rawEnd;
        }
      }
      continue;
    }

    // Text content
    const nextTag = html.indexOf('<', i + 1);
    if (nextTag === -1) {
      const text = html.substring(i);
      if (text.trim()) tokens.push({ type: 'text', value: text });
      break;
    }
    const text = html.substring(i, nextTag);
    if (text.trim()) tokens.push({ type: 'text', value: text });
    else if (text.length > 0 && tokens.length > 0) {
      // preserve a single space hint between inline elements
      tokens.push({ type: 'whitespace', value: ' ' });
    }
    i = nextTag;
  }

  return tokens;
}

function findTagEnd(html, start) {
  let i = start + 1;
  const len = html.length;
  let inQuote = false;
  let quoteChar = '';

  while (i < len) {
    const ch = html[i];
    if (inQuote) {
      if (ch === quoteChar) inQuote = false;
    } else {
      if (ch === '"' || ch === "'") {
        inQuote = true;
        quoteChar = ch;
      } else if (ch === '>') {
        return i;
      }
    }
    i++;
  }
  return -1;
}

function parseAttributes(tag) {
  // Remove the tag name and closing > or />
  const inner = tag.replace(/^<\s*[a-zA-Z][a-zA-Z0-9-]*/, '').replace(/\/?>$/, '').trim();
  if (!inner) return [];

  const attrs = [];
  const re = /([a-zA-Z_:@][\w:.\-]*)(?:\s*=\s*(?:"([^"]*)"|'([^']*)'|(\S+)))?/g;
  let m;
  while ((m = re.exec(inner)) !== null) {
    const name = m[1];
    const val = m[2] !== undefined ? m[2] : (m[3] !== undefined ? m[3] : (m[4] !== undefined ? m[4] : null));
    attrs.push({ name, value: val });
  }
  return attrs;
}

function rebuildTag(token, indentUnit, depth, wrapAttrs) {
  if (!token.attrs || token.attrs.length === 0) return token.value;

  const tagName = token.tagName;
  const isSelfClose = token.type === 'selfclose';
  const closing = isSelfClose ? (VOID_ELEMENTS.has(tagName) ? '>' : ' />') : '>';

  if (!wrapAttrs || token.attrs.length <= 1) {
    let s = '<' + tagName;
    for (const attr of token.attrs) {
      s += ' ' + attr.name;
      if (attr.value !== null) s += '="' + attr.value + '"';
    }
    s += closing;
    return s;
  }

  // Wrap attributes: each on its own line, indented one more level
  const attrIndent = indentUnit.repeat(depth + 1);
  let s = '<' + tagName;
  for (let j = 0; j < token.attrs.length; j++) {
    const attr = token.attrs[j];
    s += '\n' + attrIndent + attr.name;
    if (attr.value !== null) s += '="' + attr.value + '"';
  }
  s += closing;
  return s;
}

function beautify(html, indentUnit, preserveInline, wrapAttrs) {
  const tokens = tokenizeHTML(html);
  const lines = [];
  let depth = 0;

  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];

    switch (token.type) {
      case 'doctype':
      case 'cdata':
        lines.push(indentUnit.repeat(depth) + token.value.trim());
        break;

      case 'comment':
        lines.push(indentUnit.repeat(depth) + token.value.trim());
        break;

      case 'open': {
        const tagName = token.tagName;
        const isInline = INLINE_ELEMENTS.has(tagName);

        // Check if this inline element has simple text content followed by close tag
        if (isInline && preserveInline) {
          const inlineResult = tryInlineSingle(tokens, i, indentUnit, depth, wrapAttrs);
          if (inlineResult !== null) {
            lines.push(indentUnit.repeat(depth) + inlineResult.text);
            i = inlineResult.endIndex;
            break;
          }
        }

        lines.push(indentUnit.repeat(depth) + rebuildTag(token, indentUnit, depth, wrapAttrs));
        if (!RAW_ELEMENTS.has(tagName)) {
          depth++;
        }
        break;
      }

      case 'close':
        if (!RAW_ELEMENTS.has(token.tagName)) {
          depth = Math.max(0, depth - 1);
        }
        lines.push(indentUnit.repeat(depth) + token.value.trim());
        break;

      case 'selfclose':
        lines.push(indentUnit.repeat(depth) + rebuildTag(token, indentUnit, depth, wrapAttrs));
        break;

      case 'rawtext':
        // Preserve raw text as-is (script, style, pre content)
        lines.push(token.value);
        break;

      case 'text': {
        const trimmed = token.value.trim();
        if (trimmed) {
          lines.push(indentUnit.repeat(depth) + trimmed);
        }
        break;
      }

      case 'whitespace':
        // skip whitespace-only tokens in beautify mode
        break;
    }
  }

  return lines.join('\n');
}

function tryInlineSingle(tokens, openIdx, indentUnit, depth, wrapAttrs) {
  // Look ahead: text or whitespace tokens, then close tag matching the open tag
  const openToken = tokens[openIdx];
  const tagName = openToken.tagName;
  let textParts = [];
  let j = openIdx + 1;

  while (j < tokens.length) {
    const t = tokens[j];
    if (t.type === 'text' || t.type === 'whitespace') {
      textParts.push(t.value.trim());
      j++;
    } else if (t.type === 'selfclose' && INLINE_ELEMENTS.has(t.tagName)) {
      textParts.push(t.value.trim());
      j++;
    } else {
      break;
    }
  }

  if (j < tokens.length && tokens[j].type === 'close' && tokens[j].tagName === tagName) {
    const innerText = textParts.join(' ').trim();
    // Only inline if the total line length is reasonable
    const openTag = rebuildTag(openToken, indentUnit, depth, false); // never wrap attrs for inline
    const result = openTag + innerText + tokens[j].value.trim();
    if (result.length < 120) {
      return { text: result, endIndex: j };
    }
  }

  return null;
}

function minify(html) {
  // Remove comments
  let result = html.replace(/<!--[\s\S]*?-->/g, '');
  // Collapse whitespace between tags
  result = result.replace(/>\s+</g, '><');
  // Collapse whitespace in text
  result = result.replace(/\s{2,}/g, ' ');
  // Trim leading/trailing whitespace per line then join
  result = result.split('\n').map(l => l.trim()).filter(l => l).join('');
  return result.trim();
}

/* ========== SYNTAX HIGHLIGHTING ========== */

function syntaxHighlightHTML(html) {
  return escapeHtml(html).replace(
    /(&lt;!--[\s\S]*?--&gt;)|(&lt;!DOCTYPE[^&]*&gt;)|(&lt;\/?[a-zA-Z][a-zA-Z0-9-]*)((?:\s+[^&]*?)?)(\/?\s*&gt;)|(&amp;[a-zA-Z0-9#]+;)/gi,
    function(match, comment, doctype, tagStart, attrs, tagEnd, entity) {
      if (comment) return '<span class="hl-comment">' + comment + '</span>';
      if (doctype) return '<span class="hl-doctype">' + doctype + '</span>';
      if (entity) return '<span class="hl-entity">' + entity + '</span>';
      if (tagStart) {
        let result = '<span class="hl-bracket">' + tagStart.substring(0, tagStart.indexOf(';') + 1) + '</span>';
        const nameRaw = tagStart.substring(tagStart.indexOf(';') + 1);
        if (nameRaw.startsWith('/')) {
          result += '<span class="hl-tag">/' + nameRaw.substring(1) + '</span>';
        } else {
          result += '<span class="hl-tag">' + nameRaw + '</span>';
        }

        if (attrs) {
          result += highlightAttrs(attrs);
        }

        if (tagEnd) {
          result += '<span class="hl-bracket">' + tagEnd + '</span>';
        }
        return result;
      }
      return match;
    }
  );
}

function highlightAttrs(attrStr) {
  return attrStr.replace(
    /([a-zA-Z_:@][\w:.\-]*)(\s*=\s*)((?:&quot;[^&]*?&quot;)|(?:&#39;[^&]*?&#39;)|(\S+))/g,
    function(m, name, eq, val) {
      return '<span class="hl-attr">' + name + '</span>' + eq + '<span class="hl-val">' + val + '</span>';
    }
  ).replace(
    /([a-zA-Z_:@][\w:.\-]*)(?=\s|$)/g,
    function(m, name) {
      // Boolean attribute (no value)
      if (!/hl-attr/.test(m)) return '<span class="hl-attr">' + name + '</span>';
      return m;
    }
  );
}

// Simpler and more reliable syntax highlighter
function highlightHTML(code) {
  const escaped = escapeHtml(code);
  let result = '';
  let i = 0;
  const len = escaped.length;

  while (i < len) {
    // HTML comment
    if (escaped.substr(i, 7) === '&lt;!--') {
      const end = escaped.indexOf('--&gt;', i);
      if (end !== -1) {
        result += '<span class="hl-comment">' + escaped.substring(i, end + 6) + '</span>';
        i = end + 6;
        continue;
      }
    }

    // DOCTYPE
    if (escaped.substr(i, 13).toLowerCase() === '&lt;!doctype') {
      const end = escaped.indexOf('&gt;', i);
      if (end !== -1) {
        result += '<span class="hl-doctype">' + escaped.substring(i, end + 4) + '</span>';
        i = end + 4;
        continue;
      }
    }

    // Tags (opening, closing, self-closing)
    if (escaped.substr(i, 4) === '&lt;') {
      const end = escaped.indexOf('&gt;', i);
      if (end !== -1) {
        const fullTag = escaped.substring(i, end + 4);
        result += colorizeTag(fullTag);
        i = end + 4;
        continue;
      }
    }

    // HTML entities
    if (escaped[i] === '&' && escaped.substr(i).match(/^&amp;[a-zA-Z0-9#]+;/)) {
      const em = escaped.substr(i).match(/^(&amp;[a-zA-Z0-9#]+;)/);
      if (em) {
        result += '<span class="hl-entity">' + em[1] + '</span>';
        i += em[1].length;
        continue;
      }
    }

    result += escaped[i];
    i++;
  }

  return result;
}

function colorizeTag(tagStr) {
  // tagStr is already escaped, e.g. &lt;div class=&quot;foo&quot;&gt;
  // Extract tag name
  const isClosing = tagStr.startsWith('&lt;/');
  const prefix = isClosing ? '&lt;/' : '&lt;';
  const nameMatch = tagStr.substring(prefix.length).match(/^([a-zA-Z][a-zA-Z0-9-]*)/);
  if (!nameMatch) return '<span class="hl-bracket">' + tagStr + '</span>';

  const tagName = nameMatch[1];
  const afterName = tagStr.substring(prefix.length + tagName.length);
  // afterName is the attributes + &gt; or /&gt;

  let result = '<span class="hl-bracket">' + prefix + '</span>';
  result += '<span class="hl-tag">' + tagName + '</span>';

  // Find closing bracket
  let suffix = '';
  let attrsPart = afterName;
  if (attrsPart.endsWith('/&gt;')) {
    suffix = '/&gt;';
    attrsPart = attrsPart.slice(0, -5);
  } else if (attrsPart.endsWith('&gt;')) {
    suffix = '&gt;';
    attrsPart = attrsPart.slice(0, -4);
  }

  // Highlight attributes
  if (attrsPart.trim()) {
    result += highlightAttrString(attrsPart);
  }

  result += '<span class="hl-bracket">' + suffix + '</span>';
  return result;
}

function highlightAttrString(s) {
  // s is already HTML-escaped; attribute values use &quot; for "
  return s.replace(
    /([a-zA-Z_:@][\w:.\-]*)(\s*=\s*)?(&quot;[\s\S]*?&quot;|&#39;[\s\S]*?&#39;|\S+)?/g,
    function(m, name, eq, val) {
      if (!name) return m;
      let r = '<span class="hl-attr">' + name + '</span>';
      if (eq) r += eq;
      if (val) r += '<span class="hl-val">' + val + '</span>';
      return r;
    }
  );
}

function escapeHtml(s) {
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

/* ========== UI ACTIONS ========== */

function beautifyHTML() {
  const raw = input.value;
  if (!raw.trim()) return;
  const indentStr = getIndentStr();
  const preserveInline = document.getElementById('preserveInline').checked;
  const wrapAttrs = document.getElementById('wrapAttrs').checked;

  try {
    const result = beautify(raw, indentStr, preserveInline, wrapAttrs);
    lastFormatted = result;
    formattedOutput.innerHTML = highlightHTML(result);
    statusDot.className = 'status-dot valid';
    statusText.textContent = 'HTML Beautified';
    outputLabel.textContent = 'Output';
    outputInfo.textContent = result.split('\n').length + ' lines';
  } catch (e) {
    statusDot.className = 'status-dot invalid';
    statusText.textContent = 'Error: ' + e.message;
  }
}

function minifyHTML() {
  const raw = input.value;
  if (!raw.trim()) return;

  try {
    const result = minify(raw);
    lastFormatted = result;
    formattedOutput.innerHTML = highlightHTML(result);
    statusDot.className = 'status-dot valid';
    statusText.textContent = 'HTML Minified';
    outputLabel.textContent = 'Minified Output';
    const origSize = new Blob([raw]).size;
    const newSize = new Blob([result]).size;
    const savings = origSize > 0 ? Math.round((1 - newSize / origSize) * 100) : 0;
    outputInfo.textContent = formatBytes(newSize) + ' (' + savings + '% smaller)';
  } catch (e) {
    statusDot.className = 'status-dot invalid';
    statusText.textContent = 'Error: ' + e.message;
  }
}

function copyOutput() {
  if (!lastFormatted) { showToast('Nothing to copy'); return; }
  navigator.clipboard.writeText(lastFormatted).then(() => showToast('Copied to clipboard'));
}

function downloadHTML() {
  if (!lastFormatted) { showToast('Nothing to download'); return; }
  const blob = new Blob([lastFormatted], { type: 'text/html' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'formatted.html';
  a.click();
  URL.revokeObjectURL(a.href);
  showToast('Downloaded formatted.html');
}

function clearAll() {
  input.value = '';
  lastFormatted = '';
  formattedOutput.innerHTML = '';
  statusDot.className = 'status-dot empty';
  statusText.textContent = 'Paste HTML to begin';
  sizeInfo.textContent = '';
  lineCount.textContent = '';
  outputInfo.textContent = '';
  outputLabel.textContent = 'Output';
}

function loadSample() {
  input.value = '<!DOCTYPE html>\n<html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>My Page</title><link rel="stylesheet" href="styles.css"><style>body{margin:0;padding:0;font-family:sans-serif}h1{color:#333}</style></head><body><header class="site-header"><nav id="main-nav" role="navigation"><ul><li><a href="/">Home</a></li><li><a href="/about" class="active">About</a></li><li><a href="/contact">Contact</a></li></ul></nav></header><main><section class="hero"><div class="container"><h1>Welcome to <strong>NexTool</strong></h1><p>Build amazing things with our <em>free developer tools</em>.</p><a href="/free-tools/" class="btn btn-primary">Get Started</a></div></section><section class="features"><div class="container"><h2>Features</h2><div class="grid"><div class="card"><img src="icon1.svg" alt="Fast"><h3>Lightning Fast</h3><p>All tools run 100% in your browser.</p></div><div class="card"><img src="icon2.svg" alt="Free"><h3>Always Free</h3><p>No signup, no limits, no tracking.</p></div></div></div></section></main><footer><p>&copy; 2026 NexTool. All rights reserved.</p></footer><script src="app.js"></script></body></html>';
  updateLineCount();
  autoProcess();
}

function formatBytes(bytes) {
  if (bytes === 0) return '0 B';
  const k = 1024, sizes = ['B', 'KB', 'MB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}

function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 2000);
}

/* Tab key support in textarea */
input.addEventListener('keydown', e => {
  if (e.key === 'Tab') {
    e.preventDefault();
    const start = input.selectionStart, end = input.selectionEnd;
    input.value = input.value.substring(0, start) + '  ' + input.value.substring(end);
    input.selectionStart = input.selectionEnd = start + 2;
  }
});

/* IntersectionObserver fade-in */
const observer = new IntersectionObserver(entries => {
  entries.forEach(entry => { if (entry.isIntersecting) { entry.target.classList.add('visible'); observer.unobserve(entry.target); }});
}, { threshold: 0.1 });
document.querySelectorAll('.fade-in').forEach(el => observer.observe(el));
</script>
<script src="/js/analytics-lite.js" defer></script>
<script src="/js/revenue.js" defer></script>
<script src="/js/lead-capture.js" defer></script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "FAQPage",
  "mainEntity": [
    {
      "@type": "Question",
      "name": "What is an HTML beautifier?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "An HTML beautifier is a tool that takes raw or minified HTML code and reformats it with proper indentation and line breaks, making it easier to read and maintain. NexTool's HTML Beautifier also includes syntax highlighting, attribute wrapping, and minification."
      }
    },
    {
      "@type": "Question",
      "name": "Is NexTool's HTML beautifier free?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "Yes, NexTool's HTML beautifier is completely free to use. No signup, no download, and no data limits. It runs entirely in your browser for maximum privacy and speed."
      }
    },
    {
      "@type": "Question",
      "name": "Can I minify HTML with this tool?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "Yes, NexTool's HTML Beautifier includes a one-click minify button that compresses your HTML by removing comments, extra whitespace, and line breaks. This reduces file size for faster page loads."
      }
    },
    {
      "@type": "Question",
      "name": "Does the HTML beautifier support custom indentation?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "Yes, you can choose between 2 spaces, 4 spaces, 8 spaces, or tabs for indentation. You can also enable attribute wrapping to put each HTML attribute on its own line, and toggle inline element preservation."
      }
    }
  ]
}
</script>
</body>
</html>
