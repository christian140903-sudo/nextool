<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
    <link rel="icon" type="image/svg+xml" href="/img/favicon.svg">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Code Converter — Python, JavaScript, TypeScript, Go & More | ANIMA</title>
<meta name="description" content="Convert code between programming languages. Python to JavaScript, TypeScript to Go, and more. Pattern-based conversion with syntax highlighting. Free online tool.">
<meta name="keywords" content="code converter, language converter, Python to JavaScript, TypeScript to Go, code translator, free online tool, ANIMA">
<meta name="robots" content="index, follow">
<meta property="og:title" content="Free Code Converter — Translate Between Languages | ANIMA">
<meta property="og:description" content="Convert code between Python, JavaScript, TypeScript, Go, Rust, Java, C#, PHP, Ruby, and Swift. Pattern-based conversion. 100% free.">
<meta property="og:type" content="website">
<meta property="og:url" content="https://nextool.app/free-tools/code-converter.html">
<meta property="og:image" content="https://nextool.app/img/og-image.png">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<link rel="canonical" href="https://nextool.app/free-tools/code-converter.html">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Free Code Converter — Translate Between Languages | ANIMA">
<meta name="twitter:description" content="Convert code between 10 programming languages. Pattern-based conversion with syntax highlighting. Free online tool by ANIMA.">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"SoftwareApplication","name":"Code Language Converter","applicationCategory":"DeveloperApplication","operatingSystem":"Web","offers":{"@type":"Offer","price":"0","priceCurrency":"USD"},"description":"Convert code between Python, JavaScript, TypeScript, Go, Rust, Java, C#, PHP, Ruby, and Swift. Free online pattern-based code converter."}
</script>
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{--bg:#050508;--surface:#111118;--surface2:#1a1a24;--border:#2a2a3a;--text:#e4e4eb;--text2:#9494a8;--primary:#00d4ff;--accent:#a855f7;--pink:#ec4899;--green:#22c55e;--red:#ef4444;--cyan:#22d3ee;--yellow:#eab308;--radius:12px;--glass:rgba(17,17,24,0.7)}
html{scroll-behavior:smooth}
body{font-family:'Inter',system-ui,sans-serif;background:var(--bg);color:var(--text);line-height:1.6;min-height:100vh;overflow-x:hidden}
/* NAV */
.nav{position:sticky;top:0;z-index:100;background:rgba(5,5,8,0.85);backdrop-filter:blur(20px);border-bottom:1px solid var(--border);padding:0 2rem;height:64px;display:flex;align-items:center;justify-content:space-between}
.nav-logo{font-size:1.4rem;font-weight:800;background:linear-gradient(135deg,var(--primary),var(--accent));-webkit-background-clip:text;-webkit-text-fill-color:transparent;text-decoration:none}
.nav-links{display:flex;align-items:center;gap:1.5rem}
.nav-links a{color:var(--text2);text-decoration:none;font-size:.875rem;font-weight:500;transition:color .2s}
.nav-links a:hover{color:var(--text)}
.nav-cta{background:linear-gradient(135deg,var(--primary),var(--accent));color:#fff!important;padding:.5rem 1.2rem;border-radius:8px;font-weight:600;-webkit-text-fill-color:#fff!important}
.nav-cta:hover{opacity:.9}
.nav-toggle{display:none;background:none;border:none;color:var(--text);font-size:1.5rem;cursor:pointer}
/* HERO */
.hero{text-align:center;padding:3rem 1.5rem 2rem;max-width:700px;margin:0 auto}
.hero h1{font-size:2.2rem;font-weight:800;line-height:1.2;margin-bottom:.75rem}
.hero h1 span{background:linear-gradient(135deg,var(--primary),var(--accent),var(--pink));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.hero p{color:var(--text2);font-size:1rem}
/* TOOL */
.tool-container{max-width:1200px;margin:0 auto;padding:0 1.5rem 3rem}
.toolbar{display:flex;flex-wrap:wrap;gap:.5rem;margin-bottom:1rem;align-items:center}
.toolbar button,.toolbar select{background:var(--surface2);border:1px solid var(--border);color:var(--text);padding:.45rem .9rem;border-radius:8px;font-size:.8rem;font-weight:500;cursor:pointer;transition:all .2s;font-family:inherit}
.toolbar button:hover{border-color:var(--primary);background:rgba(0,212,255,.12)}
.toolbar button.active{background:linear-gradient(135deg,var(--primary),var(--accent));border-color:transparent;color:#fff}
.toolbar select{appearance:none;padding-right:1.8rem;background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%239494a8' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10z'/%3E%3C/svg%3E");background-repeat:no-repeat;background-position:right .6rem center}
.lang-bar{display:flex;align-items:center;gap:.75rem;margin-bottom:1rem;flex-wrap:wrap}
.lang-bar label{color:var(--text2);font-size:.8rem;font-weight:600;text-transform:uppercase;letter-spacing:.5px}
.lang-bar select{background:var(--surface2);border:1px solid var(--border);color:var(--text);padding:.5rem 2rem .5rem .75rem;border-radius:8px;font-size:.85rem;font-weight:500;cursor:pointer;font-family:inherit;appearance:none;background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%239494a8' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10z'/%3E%3C/svg%3E");background-repeat:no-repeat;background-position:right .6rem center;min-width:140px}
.swap-btn{background:var(--surface2);border:1px solid var(--border);color:var(--primary);width:36px;height:36px;border-radius:50%;cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all .2s;font-size:1.1rem;flex-shrink:0}
.swap-btn:hover{background:rgba(0,212,255,.12);border-color:var(--primary);transform:rotate(180deg)}
.convert-btn{background:linear-gradient(135deg,var(--primary),var(--accent));border:none;color:#fff;padding:.55rem 1.5rem;border-radius:8px;font-size:.85rem;font-weight:700;cursor:pointer;transition:all .2s;font-family:inherit}
.convert-btn:hover{opacity:.9;transform:translateY(-1px);box-shadow:0 4px 20px rgba(0,212,255,.3)}
.status-bar{display:flex;align-items:center;gap:1rem;margin-bottom:1rem;font-size:.8rem;color:var(--text2)}
.status-dot{width:8px;height:8px;border-radius:50%;display:inline-block}
.status-dot.valid{background:var(--green)}
.status-dot.warn{background:var(--yellow)}
.status-dot.empty{background:var(--border)}
.panels{display:grid;grid-template-columns:1fr 1fr;gap:1rem;min-height:500px}
.panel{background:var(--glass);backdrop-filter:blur(16px);border:1px solid var(--border);border-radius:var(--radius);overflow:hidden;display:flex;flex-direction:column}
.panel-header{padding:.6rem 1rem;border-bottom:1px solid var(--border);font-size:.8rem;font-weight:600;color:var(--text2);display:flex;justify-content:space-between;align-items:center;background:rgba(26,26,36,0.5)}
.panel-body{flex:1;position:relative;overflow:auto}
#codeInput{width:100%;height:100%;min-height:400px;background:transparent;border:none;color:var(--text);font-family:'Courier New',monospace;font-size:.85rem;padding:1rem;resize:none;outline:none;line-height:1.7;tab-size:2}
#codeInput::placeholder{color:var(--text2);opacity:.5}
.output-area{padding:1rem;font-family:'Courier New',monospace;font-size:.85rem;line-height:1.7;white-space:pre-wrap;word-break:break-all;min-height:400px}
/* SYNTAX HIGHLIGHTING */
.hl-kw{color:#c084fc}.hl-str{color:#4ade80}.hl-num{color:var(--cyan)}.hl-cm{color:#6b7280;font-style:italic}.hl-fn{color:#60a5fa}.hl-type{color:var(--yellow)}.hl-op{color:var(--text2)}.hl-var{color:#f472b6}
.disclaimer{text-align:center;padding:1rem;color:var(--text2);font-size:.78rem;font-style:italic;margin-top:.5rem}
.sample-btns{display:flex;flex-wrap:wrap;gap:.35rem;margin-top:.5rem}
.sample-btns button{background:var(--surface);border:1px solid var(--border);color:var(--text2);padding:.3rem .6rem;border-radius:6px;font-size:.7rem;cursor:pointer;transition:all .2s;font-family:inherit}
.sample-btns button:hover{border-color:var(--primary);color:var(--text)}
/* CTA */
.cta-section{text-align:center;padding:4rem 1.5rem;max-width:700px;margin:0 auto}
.cta-section h2{font-size:1.8rem;font-weight:800;margin-bottom:.75rem}
.cta-section h2 span{background:linear-gradient(135deg,var(--primary),var(--accent));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.cta-section p{color:var(--text2);margin-bottom:1.5rem}
.cta-btn{display:inline-block;background:linear-gradient(135deg,var(--primary),var(--accent));color:#fff;padding:.75rem 2rem;border-radius:10px;font-weight:700;text-decoration:none;font-size:1rem;transition:transform .2s,box-shadow .2s}
.cta-btn:hover{transform:translateY(-2px);box-shadow:0 8px 30px rgba(0,212,255,.3)}
/* FOOTER */
.footer{border-top:1px solid var(--border);padding:3rem 2rem 2rem;max-width:1200px;margin:0 auto}
.footer-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:2rem;margin-bottom:2rem}
.footer-col h4{font-size:.85rem;font-weight:700;margin-bottom:.75rem;color:var(--text)}
.footer-col a{display:block;color:var(--text2);text-decoration:none;font-size:.8rem;margin-bottom:.4rem;transition:color .2s}
.footer-col a:hover{color:var(--primary)}
.footer-bottom{text-align:center;color:var(--text2);font-size:.75rem;padding-top:1.5rem;border-top:1px solid var(--border)}
/* FADE IN */
.fade-in{opacity:0;transform:translateY(20px);transition:opacity .6s,transform .6s}
.fade-in.visible{opacity:1;transform:translateY(0)}
/* TOAST */
.toast{position:fixed;bottom:2rem;left:50%;transform:translateX(-50%) translateY(80px);background:var(--surface2);border:1px solid var(--border);color:var(--text);padding:.6rem 1.2rem;border-radius:10px;font-size:.85rem;font-weight:500;z-index:200;transition:transform .3s;pointer-events:none}
.toast.show{transform:translateX(-50%) translateY(0)}
/* RESPONSIVE */
@media(max-width:768px){
  .panels{grid-template-columns:1fr}
  .nav-links{display:none;position:absolute;top:64px;left:0;right:0;background:var(--bg);border-bottom:1px solid var(--border);flex-direction:column;padding:1rem 2rem;gap:1rem}
  .nav-links.open{display:flex}
  .nav-toggle{display:block}
  .hero h1{font-size:1.6rem}
  .footer-grid{grid-template-columns:1fr}
  .toolbar{gap:.35rem}
  .lang-bar{gap:.5rem}
}
</style>
</head>
<body>

<nav class="nav">
  <a href="/" class="nav-logo">ANIMA</a>
  <button class="nav-toggle" onclick="document.querySelector('.nav-links').classList.toggle('open')" aria-label="Menu">&#9776;</button>
  <div class="nav-links">
    <a href="/">Home</a>
    <a href="/free-tools/">Tools</a>
    <a href="/free-tools/">Free Tools</a>
    <a href="/blog/">Blog</a>
    <a href="https://github.com/christian140903-sudo/nextool" class="nav-cta" target="_blank" rel="noopener">GitHub</a>
  </div>
</nav>

<section class="hero fade-in">
  <h1>Free <span>Code Converter</span></h1>
  <p class="tool-summary" style="color:#94a3b8;font-size:15px;line-height:1.6;margin-bottom:24px;max-width:700px;margin-left:auto;margin-right:auto;">Convert code between Python, JavaScript, TypeScript, Go, Rust, Java, C#, PHP, Ruby, and Swift. Pattern-based conversion handles variable declarations, functions, loops, conditionals, print statements, and more. 100% client-side, no signup required.</p>
</section>

<div class="tool-container fade-in">
  <div class="lang-bar">
    <label>From:</label>
    <select id="sourceLang">
      <option value="python">Python</option>
      <option value="javascript">JavaScript</option>
      <option value="typescript">TypeScript</option>
      <option value="go">Go</option>
      <option value="rust">Rust</option>
      <option value="java">Java</option>
      <option value="csharp">C#</option>
      <option value="php">PHP</option>
      <option value="ruby">Ruby</option>
      <option value="swift">Swift</option>
    </select>
    <button class="swap-btn" onclick="swapLanguages()" title="Swap languages">&#8644;</button>
    <label>To:</label>
    <select id="targetLang">
      <option value="javascript" selected>JavaScript</option>
      <option value="python">Python</option>
      <option value="typescript">TypeScript</option>
      <option value="go">Go</option>
      <option value="rust">Rust</option>
      <option value="java">Java</option>
      <option value="csharp">C#</option>
      <option value="php">PHP</option>
      <option value="ruby">Ruby</option>
      <option value="swift">Swift</option>
    </select>
    <button class="convert-btn" onclick="convertCode()">Convert</button>
  </div>

  <div class="toolbar">
    <button onclick="copyOutput()" title="Copy output">Copy Output</button>
    <button onclick="clearAll()" title="Clear all">Clear</button>
    <span style="color:var(--text2);font-size:.75rem;margin-left:auto;">Sample code:</span>
  </div>
  <div class="sample-btns">
    <button onclick="loadSample('python')">Python</button>
    <button onclick="loadSample('javascript')">JavaScript</button>
    <button onclick="loadSample('typescript')">TypeScript</button>
    <button onclick="loadSample('go')">Go</button>
    <button onclick="loadSample('rust')">Rust</button>
    <button onclick="loadSample('java')">Java</button>
    <button onclick="loadSample('csharp')">C#</button>
    <button onclick="loadSample('php')">PHP</button>
    <button onclick="loadSample('ruby')">Ruby</button>
    <button onclick="loadSample('swift')">Swift</button>
  </div>

  <div class="status-bar" style="margin-top:1rem">
    <span><span class="status-dot empty" id="statusDot"></span></span>
    <span id="statusText">Paste code and click Convert</span>
    <span id="lineInfo" style="margin-left:auto"></span>
  </div>

  <div class="panels">
    <div class="panel">
      <div class="panel-header"><span>Source Code</span><span id="inputLineCount"></span></div>
      <div class="panel-body">
        <textarea id="codeInput" placeholder="Paste your source code here...

Example (Python):
def greet(name):
    print(f'Hello, {name}!')

greet('World')" spellcheck="false"></textarea>
      </div>
    </div>
    <div class="panel">
      <div class="panel-header"><span id="outputLabel">Converted Output</span><span id="outputLineCount"></span></div>
      <div class="panel-body" id="outputPanel">
        <div class="output-area" id="convertedOutput"></div>
      </div>
    </div>
  </div>
  <p class="disclaimer">Pattern-based conversion &mdash; review output for complex code. Not a compiler. Best for common patterns and snippets.</p>
</div>

<section class="cta-section fade-in">
  <h2>Need something <span>more powerful</span>?</h2>
  <p>Let us build it for you. Custom APIs, dashboards, automations &mdash; whatever you need.</p>
  <a href="/#contact" class="cta-btn">Start a Project &rarr;</a>
</section>

<!-- Cross Promo -->
<section style="max-width:900px;margin:40px auto;padding:0 24px;">
<div style="background:linear-gradient(135deg,rgba(0,212,255,0.1),rgba(168,85,247,0.08));border:1px solid rgba(0,212,255,0.15);border-radius:20px;padding:32px 28px;text-align:center;">
<div style="font-size:13px;color:#818cf8;font-weight:600;text-transform:uppercase;letter-spacing:1px;margin-bottom:8px;">Founding Member</div>
<h3 style="font-size:22px;font-weight:800;color:#fff;margin:0 0 8px;">ANIMA on GitHub</h3>
<p style="color:#94a3b8;font-size:14px;margin:0 auto 20px;max-width:500px;">253+ free tools. No signup. Open source. Built by Christian Bucher.</p>
<div style="display:flex;align-items:center;justify-content:center;gap:12px;flex-wrap:wrap;">
<a href="/about/" style="display:inline-block;padding:12px 28px;background:linear-gradient(135deg,#00d4ff,#a855f7,#ec4899);color:#fff;border-radius:10px;font-weight:700;font-size:15px;text-decoration:none;">GitHub</a>
<a href="/free-tools/" style="color:#94a3b8;font-size:14px;text-decoration:none;">Browse 250+ Free Tools &rarr;</a>
</div>
</div>
</section>

<div style="max-width:1200px;margin:2rem auto;padding:0 1.5rem;">
<div style="padding:1.5rem;background:var(--surface);border:1px solid var(--border);border-radius:var(--radius)">
<p style="font-weight:600;margin-bottom:.5rem">Related Tools</p>
<p><a href="/free-tools/javascript-formatter.html" style="color:var(--primary);text-decoration:none">JavaScript Formatter</a> &middot; <a href="/free-tools/html-to-jsx.html" style="color:var(--primary);text-decoration:none">HTML to JSX Converter</a> &middot; <a href="/free-tools/json-to-typescript.html" style="color:var(--primary);text-decoration:none">JSON to TypeScript</a> &middot; <a href="/free-tools/css-to-tailwind.html" style="color:var(--primary);text-decoration:none">CSS to Tailwind</a> &middot; <a href="/free-tools/sql-formatter.html" style="color:var(--primary);text-decoration:none">SQL Formatter</a></p>
</div>
</div>

<footer class="footer fade-in">
  <div class="footer-grid">
    <div class="footer-col">
      <h4>Products</h4>
      <a href="/free-tools/">250+ Free Tools</a>
<a href="/about/">About</a>
<a href="/docs/">Documentation</a>
    </div>
    <div class="footer-col">
      <h4>Explore</h4>
      <a href="/free-tools/">Free Tools</a><a href="/blog/">Blog</a><a href="/about/">FAQ</a><a href="/about/">About</a>
    </div>
    <div class="footer-col">
      <h4>Ecosystem</h4>
      <a href="/">ANIMA Home</a><a href="/#contact">Contact</a><a href="https://github.com/christian140903-sudo/nextool" target="_blank">GitHub</a>
    </div>
  </div>
  <div class="footer-bottom">&copy; 2026 ANIMA. AI-powered tools for everyone.</div>
</footer>

<div class="toast" id="toast"></div>

<script>
const codeInput = document.getElementById('codeInput');
const convertedOutput = document.getElementById('convertedOutput');
const statusDot = document.getElementById('statusDot');
const statusText = document.getElementById('statusText');
const inputLineCount = document.getElementById('inputLineCount');
const outputLineCount = document.getElementById('outputLineCount');
const lineInfo = document.getElementById('lineInfo');
const sourceLang = document.getElementById('sourceLang');
const targetLang = document.getElementById('targetLang');
let lastConverted = '';

codeInput.addEventListener('input', updateInputInfo);

function updateInputInfo() {
  const lines = codeInput.value.split('\n').length;
  inputLineCount.textContent = lines + ' line' + (lines !== 1 ? 's' : '');
}

/* ========== SAMPLE CODE ========== */
const samples = {
python: `# Variable declarations
name = "World"
count = 42
is_active = True
items = [1, 2, 3, 4, 5]

# Function definition
def greet(name):
    message = f"Hello, {name}!"
    print(message)
    return message

# For loop
for i in range(10):
    print(i)

# For-each loop
for item in items:
    print(item)

# While loop
i = 0
while i < 10:
    i += 1

# If/else conditional
if count > 50:
    print("High")
elif count > 20:
    print("Medium")
else:
    print("Low")

# String operations
upper = name.upper()
lower = name.lower()
length = len(name)
trimmed = name.strip()
contains = "orl" in name

# Array operations
items.append(6)
first = items[0]
sliced = items[1:3]
size = len(items)

# Call the function
greet("ANIMA")`,

javascript: `// Variable declarations
let name = "World";
const count = 42;
let isActive = true;
const items = [1, 2, 3, 4, 5];

// Function definition
function greet(name) {
    const message = \`Hello, \${name}!\`;
    console.log(message);
    return message;
}

// For loop
for (let i = 0; i < 10; i++) {
    console.log(i);
}

// For-each loop
for (const item of items) {
    console.log(item);
}

// While loop
let i = 0;
while (i < 10) {
    i++;
}

// If/else conditional
if (count > 50) {
    console.log("High");
} else if (count > 20) {
    console.log("Medium");
} else {
    console.log("Low");
}

// String operations
const upper = name.toUpperCase();
const lower = name.toLowerCase();
const length = name.length;
const trimmed = name.trim();
const contains = name.includes("orl");

// Array operations
items.push(6);
const first = items[0];
const sliced = items.slice(1, 3);
const size = items.length;

// Call the function
greet("ANIMA");`,

typescript: `// Variable declarations
let name: string = "World";
const count: number = 42;
let isActive: boolean = true;
const items: number[] = [1, 2, 3, 4, 5];

// Function definition
function greet(name: string): string {
    const message: string = \`Hello, \${name}!\`;
    console.log(message);
    return message;
}

// For loop
for (let i: number = 0; i < 10; i++) {
    console.log(i);
}

// For-each loop
for (const item of items) {
    console.log(item);
}

// While loop
let i: number = 0;
while (i < 10) {
    i++;
}

// If/else conditional
if (count > 50) {
    console.log("High");
} else if (count > 20) {
    console.log("Medium");
} else {
    console.log("Low");
}

// String operations
const upper: string = name.toUpperCase();
const lower: string = name.toLowerCase();
const length: number = name.length;
const trimmed: string = name.trim();
const contains: boolean = name.includes("orl");

// Array operations
items.push(6);
const first: number = items[0];
const sliced: number[] = items.slice(1, 3);
const size: number = items.length;

// Call the function
greet("ANIMA");`,

go: `package main

import "fmt"

// Variable declarations
var name string = "World"
var count int = 42
var isActive bool = true
var items []int = []int{1, 2, 3, 4, 5}

// Function definition
func greet(name string) string {
    message := fmt.Sprintf("Hello, %s!", name)
    fmt.Println(message)
    return message
}

// For loop
func main() {
    for i := 0; i < 10; i++ {
        fmt.Println(i)
    }

    // For-each loop
    for _, item := range items {
        fmt.Println(item)
    }

    // While loop
    i := 0
    for i < 10 {
        i++
    }

    // If/else conditional
    if count > 50 {
        fmt.Println("High")
    } else if count > 20 {
        fmt.Println("Medium")
    } else {
        fmt.Println("Low")
    }

    // String operations
    upper := strings.ToUpper(name)
    lower := strings.ToLower(name)
    length := len(name)
    trimmed := strings.TrimSpace(name)
    contains := strings.Contains(name, "orl")

    // Array operations
    items = append(items, 6)
    first := items[0]
    sliced := items[1:3]
    size := len(items)

    // Call the function
    greet("ANIMA")
}`,

rust: `// Variable declarations
let name: &str = "World";
let count: i32 = 42;
let is_active: bool = true;
let mut items: Vec<i32> = vec![1, 2, 3, 4, 5];

// Function definition
fn greet(name: &str) -> String {
    let message = format!("Hello, {}!", name);
    println!("{}", message);
    message
}

// For loop
fn main() {
    for i in 0..10 {
        println!("{}", i);
    }

    // For-each loop
    for item in &items {
        println!("{}", item);
    }

    // While loop
    let mut i = 0;
    while i < 10 {
        i += 1;
    }

    // If/else conditional
    if count > 50 {
        println!("High");
    } else if count > 20 {
        println!("Medium");
    } else {
        println!("Low");
    }

    // String operations
    let upper = name.to_uppercase();
    let lower = name.to_lowercase();
    let length = name.len();
    let trimmed = name.trim();
    let contains = name.contains("orl");

    // Array operations
    items.push(6);
    let first = items[0];
    let sliced = &items[1..3];
    let size = items.len();

    // Call the function
    greet("ANIMA");
}`,

java: `// Variable declarations
String name = "World";
int count = 42;
boolean isActive = true;
List<Integer> items = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

// Function definition
public static String greet(String name) {
    String message = String.format("Hello, %s!", name);
    System.out.println(message);
    return message;
}

// For loop
for (int i = 0; i < 10; i++) {
    System.out.println(i);
}

// For-each loop
for (int item : items) {
    System.out.println(item);
}

// While loop
int i = 0;
while (i < 10) {
    i++;
}

// If/else conditional
if (count > 50) {
    System.out.println("High");
} else if (count > 20) {
    System.out.println("Medium");
} else {
    System.out.println("Low");
}

// String operations
String upper = name.toUpperCase();
String lower = name.toLowerCase();
int length = name.length();
String trimmed = name.trim();
boolean contains = name.contains("orl");

// Array operations
items.add(6);
int first = items.get(0);
List<Integer> sliced = items.subList(1, 3);
int size = items.size();

// Call the function
greet("ANIMA");`,

csharp: `// Variable declarations
string name = "World";
int count = 42;
bool isActive = true;
List<int> items = new List<int> { 1, 2, 3, 4, 5 };

// Function definition
static string Greet(string name) {
    string message = $"Hello, {name}!";
    Console.WriteLine(message);
    return message;
}

// For loop
for (int i = 0; i < 10; i++) {
    Console.WriteLine(i);
}

// For-each loop
foreach (int item in items) {
    Console.WriteLine(item);
}

// While loop
int i = 0;
while (i < 10) {
    i++;
}

// If/else conditional
if (count > 50) {
    Console.WriteLine("High");
} else if (count > 20) {
    Console.WriteLine("Medium");
} else {
    Console.WriteLine("Low");
}

// String operations
string upper = name.ToUpper();
string lower = name.ToLower();
int length = name.Length;
string trimmed = name.Trim();
bool contains = name.Contains("orl");

// Array operations
items.Add(6);
int first = items[0];
List<int> sliced = items.GetRange(1, 2);
int size = items.Count;

// Call the function
Greet("ANIMA");`,

php: `<?php
// Variable declarations
$name = "World";
$count = 42;
$isActive = true;
$items = [1, 2, 3, 4, 5];

// Function definition
function greet($name) {
    $message = "Hello, {$name}!";
    echo $message . "\\n";
    return $message;
}

// For loop
for ($i = 0; $i < 10; $i++) {
    echo $i . "\\n";
}

// For-each loop
foreach ($items as $item) {
    echo $item . "\\n";
}

// While loop
$i = 0;
while ($i < 10) {
    $i++;
}

// If/else conditional
if ($count > 50) {
    echo "High\\n";
} elseif ($count > 20) {
    echo "Medium\\n";
} else {
    echo "Low\\n";
}

// String operations
$upper = strtoupper($name);
$lower = strtolower($name);
$length = strlen($name);
$trimmed = trim($name);
$contains = str_contains($name, "orl");

// Array operations
$items[] = 6;
$first = $items[0];
$sliced = array_slice($items, 1, 2);
$size = count($items);

// Call the function
greet("ANIMA");
?>`,

ruby: `# Variable declarations
name = "World"
count = 42
is_active = true
items = [1, 2, 3, 4, 5]

# Function definition
def greet(name)
    message = "Hello, #{name}!"
    puts message
    return message
end

# For loop
for i in 0...10
    puts i
end

# For-each loop
items.each do |item|
    puts item
end

# While loop
i = 0
while i < 10
    i += 1
end

# If/else conditional
if count > 50
    puts "High"
elsif count > 20
    puts "Medium"
else
    puts "Low"
end

# String operations
upper = name.upcase
lower = name.downcase
length = name.length
trimmed = name.strip
contains = name.include?("orl")

# Array operations
items.push(6)
first = items[0]
sliced = items[1..2]
size = items.length

# Call the function
greet("ANIMA")`,

swift: `// Variable declarations
var name: String = "World"
let count: Int = 42
var isActive: Bool = true
var items: [Int] = [1, 2, 3, 4, 5]

// Function definition
func greet(name: String) -> String {
    let message = "Hello, \\(name)!"
    print(message)
    return message
}

// For loop
for i in 0..<10 {
    print(i)
}

// For-each loop
for item in items {
    print(item)
}

// While loop
var i = 0
while i < 10 {
    i += 1
}

// If/else conditional
if count > 50 {
    print("High")
} else if count > 20 {
    print("Medium")
} else {
    print("Low")
}

// String operations
let upper = name.uppercased()
let lower = name.lowercased()
let length = name.count
let trimmed = name.trimmingCharacters(in: .whitespaces)
let contains = name.contains("orl")

// Array operations
items.append(6)
let first = items[0]
let sliced = Array(items[1...2])
let size = items.count

// Call the function
greet(name: "ANIMA")`
};

function loadSample(lang) {
  sourceLang.value = lang;
  codeInput.value = samples[lang] || '';
  updateInputInfo();
  statusDot.className = 'status-dot empty';
  statusText.textContent = 'Sample loaded. Click Convert.';
}

/* ========== SWAP ========== */
function swapLanguages() {
  const src = sourceLang.value;
  const tgt = targetLang.value;
  sourceLang.value = tgt;
  targetLang.value = src;
  if (lastConverted) {
    codeInput.value = lastConverted;
    updateInputInfo();
    lastConverted = '';
    convertedOutput.innerHTML = '';
    outputLineCount.textContent = '';
    statusDot.className = 'status-dot empty';
    statusText.textContent = 'Languages swapped. Click Convert.';
  }
}

/* ========== CLEAR / COPY ========== */
function clearAll() {
  codeInput.value = '';
  convertedOutput.innerHTML = '';
  lastConverted = '';
  statusDot.className = 'status-dot empty';
  statusText.textContent = 'Paste code and click Convert';
  inputLineCount.textContent = '';
  outputLineCount.textContent = '';
  lineInfo.textContent = '';
}

function copyOutput() {
  if (!lastConverted) { showToast('Nothing to copy'); return; }
  navigator.clipboard.writeText(lastConverted).then(() => showToast('Copied to clipboard'));
}

/* ========== MAIN CONVERT ========== */
function convertCode() {
  const src = sourceLang.value;
  const tgt = targetLang.value;
  const code = codeInput.value;

  if (!code.trim()) {
    showToast('Please enter some code first');
    return;
  }

  if (src === tgt) {
    lastConverted = code;
    convertedOutput.innerHTML = highlightCode(code, tgt);
    statusDot.className = 'status-dot warn';
    statusText.textContent = 'Same source and target language';
    outputLineCount.textContent = code.split('\n').length + ' lines';
    return;
  }

  // Normalize to intermediate representation then emit target
  const lines = code.split('\n');
  const converted = [];
  let inBlock = false;
  let blockIndent = 0;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const trimmed = line.trim();
    const indent = line.match(/^(\s*)/)[1];

    // Skip empty lines
    if (trimmed === '') { converted.push(''); continue; }

    // Handle package/import/include lines (skip or adapt)
    if (isPackageLine(trimmed, src)) {
      converted.push(convertPackageLine(trimmed, src, tgt, indent));
      continue;
    }

    // Comments
    if (isComment(trimmed, src)) {
      converted.push(indent + convertComment(trimmed, src, tgt));
      continue;
    }

    // Function definitions
    const funcMatch = matchFunction(trimmed, src);
    if (funcMatch) {
      converted.push(indent + emitFunction(funcMatch, tgt));
      continue;
    }

    // For loops
    const forMatch = matchForLoop(trimmed, src);
    if (forMatch) {
      converted.push(indent + emitForLoop(forMatch, tgt));
      continue;
    }

    // For-each loops
    const forEachMatch = matchForEach(trimmed, src);
    if (forEachMatch) {
      converted.push(indent + emitForEach(forEachMatch, tgt));
      continue;
    }

    // While loops
    const whileMatch = matchWhile(trimmed, src);
    if (whileMatch) {
      converted.push(indent + emitWhile(whileMatch, tgt));
      continue;
    }

    // If/else if/else
    const condMatch = matchConditional(trimmed, src);
    if (condMatch) {
      converted.push(indent + emitConditional(condMatch, tgt));
      continue;
    }

    // Variable declarations
    const varMatch = matchVariable(trimmed, src);
    if (varMatch) {
      converted.push(indent + emitVariable(varMatch, tgt));
      continue;
    }

    // Print/console output
    const printMatch = matchPrint(trimmed, src);
    if (printMatch) {
      converted.push(indent + emitPrint(printMatch, tgt));
      continue;
    }

    // Return statements
    const retMatch = matchReturn(trimmed, src);
    if (retMatch) {
      converted.push(indent + emitReturn(retMatch, tgt));
      continue;
    }

    // String operations
    const strMatch = matchStringOp(trimmed, src);
    if (strMatch) {
      converted.push(indent + emitStringOp(strMatch, tgt));
      continue;
    }

    // Array operations
    const arrMatch = matchArrayOp(trimmed, src);
    if (arrMatch) {
      converted.push(indent + emitArrayOp(arrMatch, tgt));
      continue;
    }

    // Block delimiters
    if (trimmed === '{' || trimmed === '}' || trimmed === 'end' || trimmed === '?>') {
      converted.push(indent + convertBlockDelimiter(trimmed, src, tgt));
      continue;
    }

    // Increment/decrement
    const incMatch = trimmed.match(/^(\w+)\s*(\+\+|--);?$/);
    if (incMatch) {
      converted.push(indent + emitIncrement(incMatch[1], incMatch[2], tgt));
      continue;
    }

    // += / -=
    const assignMatch = trimmed.match(/^(\$?\w+)\s*(\+=|-=)\s*(.+?);?$/);
    if (assignMatch) {
      converted.push(indent + emitCompoundAssign(assignMatch[1].replace(/^\$/, ''), assignMatch[2], assignMatch[3], tgt));
      continue;
    }

    // Function calls
    const callMatch = matchFunctionCall(trimmed, src);
    if (callMatch) {
      converted.push(indent + emitFunctionCall(callMatch, tgt));
      continue;
    }

    // Fallback: pass through with minor syntax adaptation
    converted.push(indent + adaptSyntax(trimmed, src, tgt));
  }

  // Post-process: remove/add braces for brace-less/brace languages
  let result = postProcess(converted, src, tgt);
  lastConverted = result;

  convertedOutput.innerHTML = highlightCode(result, tgt);
  statusDot.className = 'status-dot valid';
  statusText.textContent = 'Converted: ' + langName(src) + ' to ' + langName(tgt);
  outputLineCount.textContent = result.split('\n').length + ' lines';
  lineInfo.textContent = lines.length + ' input lines';
}

/* ========== LANGUAGE NAMES ========== */
function langName(l) {
  const names = {python:'Python',javascript:'JavaScript',typescript:'TypeScript',go:'Go',rust:'Rust',java:'Java',csharp:'C#',php:'PHP',ruby:'Ruby',swift:'Swift'};
  return names[l] || l;
}

/* ========== HELPERS ========== */
function needsSemicolon(lang) { return ['javascript','typescript','java','csharp','php','rust'].includes(lang); }
function needsBraces(lang) { return !['python','ruby'].includes(lang); }
function semi(lang) { return needsSemicolon(lang) ? ';' : ''; }
function varPrefix(lang) { return lang === 'php' ? '$' : ''; }

/* ========== PACKAGE/IMPORT ========== */
function isPackageLine(line, src) {
  if (src === 'go' && /^package\s/.test(line)) return true;
  if (src === 'go' && /^import\s/.test(line)) return true;
  if (src === 'java' && /^(import|package)\s/.test(line)) return true;
  if (src === 'csharp' && /^using\s/.test(line)) return true;
  if (src === 'rust' && /^use\s/.test(line)) return true;
  if (src === 'php' && /^<\?php/.test(line)) return true;
  if (src === 'python' && /^(import|from)\s/.test(line)) return true;
  if (src === 'ruby' && /^require\s/.test(line)) return true;
  if (src === 'swift' && /^import\s/.test(line)) return true;
  return false;
}

function convertPackageLine(line, src, tgt, indent) {
  return indent + '// ' + line.replace(/;$/, '');
}

/* ========== COMMENTS ========== */
function isComment(line, src) {
  if (['python','ruby'].includes(src) && /^#(?!!)/.test(line)) return true;
  if (['javascript','typescript','go','rust','java','csharp','swift','php'].includes(src) && /^\/\//.test(line)) return true;
  return false;
}

function convertComment(line, src, tgt) {
  let text;
  if (['python','ruby'].includes(src)) {
    text = line.replace(/^#\s?/, '');
  } else {
    text = line.replace(/^\/\/\s?/, '');
  }
  if (['python','ruby'].includes(tgt)) {
    return '# ' + text;
  }
  return '// ' + text;
}

/* ========== FUNCTION DEFINITIONS ========== */
function matchFunction(line, src) {
  let m;
  switch (src) {
    case 'python':
      m = line.match(/^def\s+(\w+)\s*\(([^)]*)\)\s*(?:->.*)?:$/);
      if (m) return { name: m[1], params: parsePythonParams(m[2]), hasReturn: true };
      break;
    case 'javascript':
      m = line.match(/^(?:function\s+(\w+)|(?:const|let|var)\s+(\w+)\s*=\s*(?:function)?\s*)\s*\(([^)]*)\)\s*(?:=>)?\s*\{?$/);
      if (!m) m = line.match(/^function\s+(\w+)\s*\(([^)]*)\)\s*\{?$/);
      if (m) return { name: m[1] || m[2], params: parseJSParams(m[3] || m[2]), hasReturn: true };
      break;
    case 'typescript':
      m = line.match(/^function\s+(\w+)\s*\(([^)]*)\)\s*(?::\s*\w+)?\s*\{?$/);
      if (m) return { name: m[1], params: parseTSParams(m[2]), hasReturn: true };
      break;
    case 'go':
      m = line.match(/^func\s+(\w+)\s*\(([^)]*)\)\s*([\w\[\]*]*)\s*\{?$/);
      if (m) return { name: m[1], params: parseGoParams(m[2]), returnType: m[3]?.trim(), hasReturn: true };
      break;
    case 'rust':
      m = line.match(/^fn\s+(\w+)\s*\(([^)]*)\)\s*(?:->\s*([\w&<>]+))?\s*\{?$/);
      if (m) return { name: m[1], params: parseRustParams(m[2]), returnType: m[3]?.trim(), hasReturn: true };
      break;
    case 'java':
      m = line.match(/^(?:public\s+)?(?:static\s+)?(\w+)\s+(\w+)\s*\(([^)]*)\)\s*\{?$/);
      if (m) return { name: m[2], params: parseJavaParams(m[3]), returnType: m[1], hasReturn: true };
      break;
    case 'csharp':
      m = line.match(/^(?:public\s+)?(?:static\s+)?(\w+)\s+(\w+)\s*\(([^)]*)\)\s*\{?$/);
      if (m) return { name: m[2], params: parseCSharpParams(m[3]), returnType: m[1], hasReturn: true };
      break;
    case 'php':
      m = line.match(/^function\s+(\w+)\s*\(([^)]*)\)\s*(?::\s*\w+)?\s*\{?$/);
      if (m) return { name: m[1], params: parsePHPParams(m[2]), hasReturn: true };
      break;
    case 'ruby':
      m = line.match(/^def\s+(\w+)\s*(?:\(([^)]*)\))?$/);
      if (m) return { name: m[1], params: parseRubyParams(m[2] || ''), hasReturn: true };
      break;
    case 'swift':
      m = line.match(/^func\s+(\w+)\s*\(([^)]*)\)\s*(?:->\s*(\w+))?\s*\{?$/);
      if (m) return { name: m[1], params: parseSwiftParams(m[2]), returnType: m[3]?.trim(), hasReturn: true };
      break;
  }
  return null;
}

function parsePythonParams(s) { return s.split(',').map(p => p.trim()).filter(Boolean).map(p => ({ name: p.split(':')[0].trim().split('=')[0].trim() })); }
function parseJSParams(s) { if (!s) return []; return s.split(',').map(p => p.trim()).filter(Boolean).map(p => ({ name: p.split('=')[0].trim() })); }
function parseTSParams(s) { if (!s) return []; return s.split(',').map(p => p.trim()).filter(Boolean).map(p => { const parts = p.split(':'); return { name: parts[0].trim(), type: parts[1]?.trim() }; }); }
function parseGoParams(s) { if (!s) return []; return s.split(',').map(p => p.trim()).filter(Boolean).map(p => { const parts = p.split(/\s+/); return { name: parts[0], type: parts[1] }; }); }
function parseRustParams(s) { if (!s) return []; return s.split(',').map(p => p.trim()).filter(Boolean).map(p => { const parts = p.split(':'); return { name: parts[0].replace('&', '').replace('mut ', '').trim(), type: parts[1]?.trim() }; }); }
function parseJavaParams(s) { if (!s) return []; return s.split(',').map(p => p.trim()).filter(Boolean).map(p => { const parts = p.split(/\s+/); return { name: parts[parts.length - 1], type: parts.slice(0, -1).join(' ') }; }); }
function parseCSharpParams(s) { return parseJavaParams(s); }
function parsePHPParams(s) { if (!s) return []; return s.split(',').map(p => p.trim()).filter(Boolean).map(p => ({ name: p.replace(/^\$/, '').split('=')[0].trim() })); }
function parseRubyParams(s) { if (!s) return []; return s.split(',').map(p => p.trim()).filter(Boolean).map(p => ({ name: p.split('=')[0].trim() })); }
function parseSwiftParams(s) { if (!s) return []; return s.split(',').map(p => p.trim()).filter(Boolean).map(p => { const parts = p.split(':'); return { name: parts[0].trim().split(/\s+/).pop(), type: parts[1]?.trim() }; }); }

function emitFunction(fn, tgt) {
  const paramStr = fn.params.map(p => formatParam(p, tgt)).join(', ');
  switch (tgt) {
    case 'python':
      return 'def ' + fn.name + '(' + paramStr + '):';
    case 'javascript':
      return 'function ' + fn.name + '(' + paramStr + ') {';
    case 'typescript':
      return 'function ' + fn.name + '(' + paramStr + ') {';
    case 'go':
      return 'func ' + fn.name + '(' + paramStr + ') {';
    case 'rust':
      return 'fn ' + fn.name + '(' + paramStr + ') {';
    case 'java':
      return 'public static void ' + fn.name + '(' + paramStr + ') {';
    case 'csharp':
      return 'static void ' + capitalize(fn.name) + '(' + paramStr + ') {';
    case 'php':
      return 'function ' + fn.name + '(' + paramStr + ') {';
    case 'ruby':
      return 'def ' + toSnake(fn.name) + '(' + paramStr + ')';
    case 'swift':
      return 'func ' + fn.name + '(' + paramStr + ') {';
  }
  return 'function ' + fn.name + '(' + paramStr + ') {';
}

function formatParam(p, tgt) {
  const name = tgt === 'ruby' || tgt === 'python' ? toSnake(p.name) : toCamel(p.name);
  switch (tgt) {
    case 'python': return name;
    case 'javascript': return name;
    case 'typescript': return name + ': any';
    case 'go': return name + ' interface{}';
    case 'rust': return name + ': &str';
    case 'java': return 'Object ' + name;
    case 'csharp': return 'object ' + name;
    case 'php': return '$' + name;
    case 'ruby': return name;
    case 'swift': return '_ ' + name + ': Any';
  }
  return name;
}

/* ========== FOR LOOPS ========== */
function matchForLoop(line, src) {
  let m;
  switch (src) {
    case 'python':
      m = line.match(/^for\s+(\w+)\s+in\s+range\((\d+)(?:\s*,\s*(\d+))?\)\s*:$/);
      if (m) return { var: m[1], start: m[3] ? m[2] : '0', end: m[3] || m[2] };
      break;
    case 'javascript': case 'typescript':
      m = line.match(/^for\s*\(\s*(?:let|var|const|int)\s+(\w+)(?::\s*\w+)?\s*=\s*(\d+)\s*;\s*\w+\s*<\s*(\d+)\s*;\s*\w+\+\+\s*\)\s*\{?$/);
      if (m) return { var: m[1], start: m[2], end: m[3] };
      break;
    case 'go':
      m = line.match(/^for\s+(\w+)\s*:=\s*(\d+)\s*;\s*\w+\s*<\s*(\d+)\s*;\s*\w+\+\+\s*\{?$/);
      if (m) return { var: m[1], start: m[2], end: m[3] };
      break;
    case 'rust':
      m = line.match(/^for\s+(\w+)\s+in\s+(\d+)\.\.(\d+)\s*\{?$/);
      if (m) return { var: m[1], start: m[2], end: m[3] };
      break;
    case 'java': case 'csharp':
      m = line.match(/^for\s*\(\s*(?:int|var)\s+(\w+)\s*=\s*(\d+)\s*;\s*\w+\s*<\s*(\d+)\s*;\s*\w+\+\+\s*\)\s*\{?$/);
      if (m) return { var: m[1], start: m[2], end: m[3] };
      break;
    case 'php':
      m = line.match(/^for\s*\(\s*\$(\w+)\s*=\s*(\d+)\s*;\s*\$\w+\s*<\s*(\d+)\s*;\s*\$\w+\+\+\s*\)\s*\{?$/);
      if (m) return { var: m[1], start: m[2], end: m[3] };
      break;
    case 'ruby':
      m = line.match(/^for\s+(\w+)\s+in\s+(\d+)\.\.\.(\d+)$/);
      if (m) return { var: m[1], start: m[2], end: m[3] };
      break;
    case 'swift':
      m = line.match(/^for\s+(\w+)\s+in\s+(\d+)\.\.<(\d+)\s*\{?$/);
      if (m) return { var: m[1], start: m[2], end: m[3] };
      break;
  }
  return null;
}

function emitForLoop(fl, tgt) {
  const v = tgt === 'php' ? '$' + fl.var : fl.var;
  switch (tgt) {
    case 'python': return 'for ' + fl.var + ' in range(' + (fl.start !== '0' ? fl.start + ', ' : '') + fl.end + '):';
    case 'javascript': return 'for (let ' + fl.var + ' = ' + fl.start + '; ' + fl.var + ' < ' + fl.end + '; ' + fl.var + '++) {';
    case 'typescript': return 'for (let ' + fl.var + ': number = ' + fl.start + '; ' + fl.var + ' < ' + fl.end + '; ' + fl.var + '++) {';
    case 'go': return 'for ' + fl.var + ' := ' + fl.start + '; ' + fl.var + ' < ' + fl.end + '; ' + fl.var + '++ {';
    case 'rust': return 'for ' + fl.var + ' in ' + fl.start + '..' + fl.end + ' {';
    case 'java': return 'for (int ' + fl.var + ' = ' + fl.start + '; ' + fl.var + ' < ' + fl.end + '; ' + fl.var + '++) {';
    case 'csharp': return 'for (int ' + fl.var + ' = ' + fl.start + '; ' + fl.var + ' < ' + fl.end + '; ' + fl.var + '++) {';
    case 'php': return 'for ($' + fl.var + ' = ' + fl.start + '; $' + fl.var + ' < ' + fl.end + '; $' + fl.var + '++) {';
    case 'ruby': return 'for ' + fl.var + ' in ' + fl.start + '...' + fl.end;
    case 'swift': return 'for ' + fl.var + ' in ' + fl.start + '..<' + fl.end + ' {';
  }
  return '';
}

/* ========== FOR-EACH ========== */
function matchForEach(line, src) {
  let m;
  switch (src) {
    case 'python':
      m = line.match(/^for\s+(\w+)\s+in\s+(\w+)\s*:$/);
      if (m && !m[2].match(/^range$/)) return { var: m[1], collection: m[2] };
      break;
    case 'javascript': case 'typescript':
      m = line.match(/^for\s*\(\s*(?:const|let|var)\s+(\w+)\s+of\s+(\w+)\s*\)\s*\{?$/);
      if (m) return { var: m[1], collection: m[2] };
      break;
    case 'go':
      m = line.match(/^for\s+(?:_,\s*)?(\w+)\s*:=\s*range\s+(\w+)\s*\{?$/);
      if (m) return { var: m[1], collection: m[2] };
      break;
    case 'rust':
      m = line.match(/^for\s+(\w+)\s+in\s+&?(\w+)\s*\{?$/);
      if (m) return { var: m[1], collection: m[2] };
      break;
    case 'java':
      m = line.match(/^for\s*\(\s*(?:int|String|var|Object|\w+)\s+(\w+)\s*:\s*(\w+)\s*\)\s*\{?$/);
      if (m) return { var: m[1], collection: m[2] };
      break;
    case 'csharp':
      m = line.match(/^foreach\s*\(\s*(?:int|string|var|object|\w+)\s+(\w+)\s+in\s+(\w+)\s*\)\s*\{?$/);
      if (m) return { var: m[1], collection: m[2] };
      break;
    case 'php':
      m = line.match(/^foreach\s*\(\s*\$(\w+)\s+as\s+\$(\w+)\s*\)\s*\{?$/);
      if (m) return { var: m[2], collection: m[1] };
      break;
    case 'ruby':
      m = line.match(/^(\w+)\.each\s+do\s+\|(\w+)\|$/);
      if (m) return { var: m[2], collection: m[1] };
      break;
    case 'swift':
      m = line.match(/^for\s+(\w+)\s+in\s+(\w+)\s*\{?$/);
      if (m) return { var: m[1], collection: m[2] };
      break;
  }
  return null;
}

function emitForEach(fe, tgt) {
  const v = fe.var;
  const c = tgt === 'php' ? '$' + fe.collection : fe.collection;
  switch (tgt) {
    case 'python': return 'for ' + toSnake(v) + ' in ' + toSnake(fe.collection) + ':';
    case 'javascript': return 'for (const ' + toCamel(v) + ' of ' + toCamel(fe.collection) + ') {';
    case 'typescript': return 'for (const ' + toCamel(v) + ' of ' + toCamel(fe.collection) + ') {';
    case 'go': return 'for _, ' + v + ' := range ' + fe.collection + ' {';
    case 'rust': return 'for ' + toSnake(v) + ' in &' + toSnake(fe.collection) + ' {';
    case 'java': return 'for (var ' + toCamel(v) + ' : ' + toCamel(fe.collection) + ') {';
    case 'csharp': return 'foreach (var ' + toCamel(v) + ' in ' + toCamel(fe.collection) + ') {';
    case 'php': return 'foreach ($' + fe.collection + ' as $' + fe.var + ') {';
    case 'ruby': return toSnake(fe.collection) + '.each do |' + toSnake(v) + '|';
    case 'swift': return 'for ' + toCamel(v) + ' in ' + toCamel(fe.collection) + ' {';
  }
  return '';
}

/* ========== WHILE LOOPS ========== */
function matchWhile(line, src) {
  let m;
  if (src === 'python' || src === 'ruby') {
    m = line.match(/^while\s+(.+?)(?::)?$/);
  } else if (src === 'go') {
    m = line.match(/^for\s+(.+?)\s*\{?$/);
    if (m && m[1].includes(':=') || m && m[1].includes(';')) return null; // not a while
  } else {
    m = line.match(/^while\s*\(\s*(.+?)\s*\)\s*\{?$/);
  }
  if (m) return { condition: m[1].replace(/:$/, '').trim() };
  return null;
}

function emitWhile(wh, tgt) {
  const c = convertCondition(wh.condition, tgt);
  switch (tgt) {
    case 'python': return 'while ' + c + ':';
    case 'javascript': case 'typescript': return 'while (' + c + ') {';
    case 'go': return 'for ' + c + ' {';
    case 'rust': return 'while ' + c + ' {';
    case 'java': case 'csharp': return 'while (' + c + ') {';
    case 'php': return 'while (' + convertConditionPHP(c) + ') {';
    case 'ruby': return 'while ' + c;
    case 'swift': return 'while ' + c + ' {';
  }
  return '';
}

function convertCondition(cond, tgt) {
  let c = cond.replace(/^\(/, '').replace(/\)$/, '');
  c = c.replace(/\$(\w+)/g, '$1');
  return c;
}

function convertConditionPHP(cond) {
  return cond.replace(/(?<!\$)\b([a-z]\w*)\b(?!\s*\()/g, function(match) {
    if (['true','false','null','and','or','not'].includes(match)) return match;
    return '$' + match;
  });
}

/* ========== CONDITIONALS ========== */
function matchConditional(line, src) {
  let m;
  // if
  if (src === 'python') {
    m = line.match(/^(if|elif|else)\s*(.*?)\s*:$/);
    if (m) return { type: m[1] === 'elif' ? 'elseif' : m[1], condition: m[2] };
  } else if (src === 'ruby') {
    m = line.match(/^(if|elsif|else)\s*(.*?)$/);
    if (m) return { type: m[1] === 'elsif' ? 'elseif' : m[1], condition: m[2] };
  } else if (src === 'php') {
    m = line.match(/^(if|elseif|else\s*if|else)\s*(?:\(\s*(.+?)\s*\))?\s*\{?$/);
    if (m) return { type: (m[1] === 'elseif' || m[1] === 'else if') ? 'elseif' : m[1], condition: m[2] || '' };
  } else {
    m = line.match(/^(if|else\s*if|else)\s*(?:\(\s*(.+?)\s*\))?\s*\{?$/);
    if (m) return { type: m[1] === 'else if' ? 'elseif' : m[1], condition: m[2] || '' };
  }
  return null;
}

function emitConditional(cd, tgt) {
  const c = cd.condition ? convertCondition(cd.condition, tgt) : '';
  const kw = cd.type;
  switch (tgt) {
    case 'python':
      if (kw === 'else') return 'else:';
      if (kw === 'elseif') return 'elif ' + c + ':';
      return 'if ' + c + ':';
    case 'ruby':
      if (kw === 'else') return 'else';
      if (kw === 'elseif') return 'elsif ' + c;
      return 'if ' + c;
    case 'javascript': case 'typescript':
      if (kw === 'else') return '} else {';
      if (kw === 'elseif') return '} else if (' + c + ') {';
      return 'if (' + c + ') {';
    case 'go':
      if (kw === 'else') return '} else {';
      if (kw === 'elseif') return '} else if ' + c + ' {';
      return 'if ' + c + ' {';
    case 'rust':
      if (kw === 'else') return '} else {';
      if (kw === 'elseif') return '} else if ' + c + ' {';
      return 'if ' + c + ' {';
    case 'java': case 'csharp':
      if (kw === 'else') return '} else {';
      if (kw === 'elseif') return '} else if (' + c + ') {';
      return 'if (' + c + ') {';
    case 'php':
      if (kw === 'else') return '} else {';
      if (kw === 'elseif') return '} elseif (' + convertConditionPHP(c) + ') {';
      return 'if (' + convertConditionPHP(c) + ') {';
    case 'swift':
      if (kw === 'else') return '} else {';
      if (kw === 'elseif') return '} else if ' + c + ' {';
      return 'if ' + c + ' {';
  }
  return '';
}

/* ========== VARIABLE DECLARATIONS ========== */
function matchVariable(line, src) {
  let m;
  switch (src) {
    case 'python':
      m = line.match(/^(\w+)\s*=\s*(.+)$/);
      if (m && !m[0].match(/^(def|class|for|while|if|elif|else|return|import|from)\b/)) {
        return { name: m[1], value: m[2], isConst: false };
      }
      break;
    case 'javascript':
      m = line.match(/^(const|let|var)\s+(\w+)\s*=\s*(.+?);?$/);
      if (m) return { name: m[2], value: m[3], isConst: m[1] === 'const' };
      break;
    case 'typescript':
      m = line.match(/^(const|let|var)\s+(\w+)(?::\s*[\w\[\]<>|&]+)?\s*=\s*(.+?);?$/);
      if (m) return { name: m[2], value: m[3], isConst: m[1] === 'const' };
      break;
    case 'go':
      m = line.match(/^(?:var\s+)?(\w+)\s*(?::=|=)\s*(.+)$/);
      if (m && !['func','for','if','package','import'].includes(m[1])) return { name: m[1], value: m[2], isConst: false };
      break;
    case 'rust':
      m = line.match(/^let\s+(?:mut\s+)?(\w+)(?::\s*[\w&<>\[\]]+)?\s*=\s*(.+?);?$/);
      if (m) return { name: m[1], value: m[2], isConst: !line.includes('mut') };
      break;
    case 'java':
      m = line.match(/^(?:final\s+)?(\w[\w<>\[\]]*)\s+(\w+)\s*=\s*(.+?);?$/);
      if (m && !['for','if','while','return','class','public','private'].includes(m[1])) return { name: m[2], value: m[3], isConst: line.startsWith('final'), type: m[1] };
      break;
    case 'csharp':
      m = line.match(/^(?:readonly\s+)?(\w[\w<>\[\]]*)\s+(\w+)\s*=\s*(.+?);?$/);
      if (m && !['for','if','while','return','class','public','private','static'].includes(m[1])) return { name: m[2], value: m[3], isConst: line.startsWith('readonly'), type: m[1] };
      break;
    case 'php':
      m = line.match(/^\$(\w+)\s*=\s*(.+?);?$/);
      if (m) return { name: m[1], value: m[2], isConst: false };
      break;
    case 'ruby':
      m = line.match(/^(\w+)\s*=\s*(.+)$/);
      if (m && !['def','class','for','while','if','elsif','else','end','return'].includes(m[1])) return { name: m[1], value: m[2], isConst: false };
      break;
    case 'swift':
      m = line.match(/^(let|var)\s+(\w+)(?::\s*[\w\[\]<>?]+)?\s*=\s*(.+)$/);
      if (m) return { name: m[2], value: m[3], isConst: m[1] === 'let' };
      break;
  }
  return null;
}

function emitVariable(v, tgt) {
  const val = convertValue(v.value, tgt);
  const name = tgt === 'ruby' || tgt === 'python' ? toSnake(v.name) : toCamel(v.name);
  switch (tgt) {
    case 'python': return name + ' = ' + val;
    case 'javascript': return (v.isConst ? 'const ' : 'let ') + name + ' = ' + val + ';';
    case 'typescript': return (v.isConst ? 'const ' : 'let ') + name + ' = ' + val + ';';
    case 'go': return name + ' := ' + val;
    case 'rust': return 'let ' + (v.isConst ? '' : 'mut ') + toSnake(v.name) + ' = ' + val + ';';
    case 'java': return 'var ' + name + ' = ' + val + ';';
    case 'csharp': return 'var ' + name + ' = ' + val + ';';
    case 'php': return '$' + name + ' = ' + val + ';';
    case 'ruby': return toSnake(v.name) + ' = ' + val;
    case 'swift': return (v.isConst ? 'let ' : 'var ') + name + ' = ' + val;
  }
  return name + ' = ' + val + semi(tgt);
}

function convertValue(val, tgt) {
  let v = val.replace(/;$/, '').trim();
  // Booleans
  if (v === 'True' || v === 'true') {
    if (tgt === 'python') return 'True';
    return 'true';
  }
  if (v === 'False' || v === 'false') {
    if (tgt === 'python') return 'False';
    return 'false';
  }
  if (v === 'None' || v === 'nil' || v === 'null' || v === 'nullptr') {
    if (tgt === 'python') return 'None';
    if (tgt === 'ruby') return 'nil';
    if (tgt === 'go') return 'nil';
    if (tgt === 'rust') return 'None';
    if (tgt === 'swift') return 'nil';
    return 'null';
  }
  // Arrays
  v = v.replace(/\[\]int\{/, '[').replace(/\[\]string\{/, '[').replace(/\[\]float64\{/, '[');
  v = v.replace(/vec!\[/, '[').replace(/Vec::new\(\)/, '[]');
  v = v.replace(/new ArrayList<.*?>\(Arrays\.asList\((.+?)\)\)/, '[$1]');
  v = v.replace(/new List<.*?>\s*\{(.+?)\}/, '[$1]');
  v = v.replace(/array\((.+?)\)/, '[$1]');
  // Remove PHP $ from values
  v = v.replace(/\$(\w+)/g, '$1');
  return v;
}

/* ========== PRINT STATEMENTS ========== */
function matchPrint(line, src) {
  let m;
  switch (src) {
    case 'python':
      m = line.match(/^print\((.+)\)$/);
      if (m) return { content: m[1] };
      break;
    case 'javascript': case 'typescript':
      m = line.match(/^console\.log\((.+?)\)\s*;?$/);
      if (m) return { content: m[1] };
      break;
    case 'go':
      m = line.match(/^fmt\.Println\((.+?)\)$/);
      if (m) return { content: m[1] };
      break;
    case 'rust':
      m = line.match(/^println!\((.+?)\)\s*;?$/);
      if (m) return { content: m[1] };
      break;
    case 'java':
      m = line.match(/^System\.out\.println\((.+?)\)\s*;?$/);
      if (m) return { content: m[1] };
      break;
    case 'csharp':
      m = line.match(/^Console\.WriteLine\((.+?)\)\s*;?$/);
      if (m) return { content: m[1] };
      break;
    case 'php':
      m = line.match(/^echo\s+(.+?)(?:\s*\.\s*"\\n")?\s*;?$/);
      if (m) return { content: m[1] };
      break;
    case 'ruby':
      m = line.match(/^puts\s+(.+)$/);
      if (m) return { content: m[1] };
      break;
    case 'swift':
      m = line.match(/^print\((.+?)\)$/);
      if (m) return { content: m[1] };
      break;
  }
  return null;
}

function emitPrint(pr, tgt) {
  let c = pr.content.replace(/;$/, '').trim();
  // Remove format specifiers and convert between string interpolation styles
  c = normalizeStringContent(c);
  switch (tgt) {
    case 'python': return 'print(' + c + ')';
    case 'javascript': return 'console.log(' + c + ');';
    case 'typescript': return 'console.log(' + c + ');';
    case 'go': return 'fmt.Println(' + c + ')';
    case 'rust': return 'println!("{}", ' + c + ');';
    case 'java': return 'System.out.println(' + c + ');';
    case 'csharp': return 'Console.WriteLine(' + c + ');';
    case 'php': return 'echo ' + c + ' . "\\n";';
    case 'ruby': return 'puts ' + c;
    case 'swift': return 'print(' + c + ')';
  }
  return '';
}

function normalizeStringContent(s) {
  // Remove rust format specifiers
  s = s.replace(/"\{\}"(?:,\s*)?/g, '');
  if (s === '') s = '""';
  return s;
}

/* ========== RETURN ========== */
function matchReturn(line, src) {
  let m;
  if (src === 'ruby') {
    m = line.match(/^return\s+(.+)$/);
  } else {
    m = line.match(/^return\s+(.+?)\s*;?$/);
  }
  if (m) return { value: m[1] };
  return null;
}

function emitReturn(ret, tgt) {
  const v = ret.value.replace(/;$/, '').replace(/^\$/, '');
  switch (tgt) {
    case 'python': case 'ruby': return 'return ' + v;
    case 'go': return 'return ' + v;
    default: return 'return ' + v + semi(tgt);
  }
}

/* ========== STRING OPERATIONS ========== */
function matchStringOp(line, src) {
  let m;
  const assignPat = /^(?:(?:const|let|var|final|readonly)\s+)?(?:(?:string|String|str|&str|bool|boolean|int|Integer)\s+)?(\$?\w+)(?::\s*\w+)?\s*=\s*/;
  m = line.match(new RegExp(assignPat.source + '(\\$?\\w+)\\.(upper|lower|toUpperCase|toLowerCase|ToUpper|ToLower|upcase|downcase|uppercased|lowercased|to_uppercase|to_lowercase|trim|strip|Trim|TrimSpace|trimmingCharacters|length|Length|len|count|includes|Contains|contains|include\\?|str_contains).*$'));
  if (!m) {
    // Python/Ruby style: function(var)
    m = line.match(new RegExp(assignPat.source + '(?:len|strlen)\\((\\$?\\w+)\\).*$'));
    if (m) return { assign: m[1].replace(/^\$/, ''), target: m[2].replace(/^\$/, ''), op: 'length' };
    // "x" in name (Python)
    m = line.match(new RegExp(assignPat.source + '"([^"]+)"\\s+in\\s+(\\w+)$'));
    if (m) return { assign: m[1].replace(/^\$/, ''), target: m[3], op: 'contains', arg: m[2] };
    // PHP functions
    m = line.match(new RegExp(assignPat.source + '(strtoupper|strtolower|trim|strlen|str_contains)\\(\\$?(\\w+)(?:,\\s*"([^"]*)")?\\).*$'));
    if (m) {
      const opMap = {strtoupper:'upper',strtolower:'lower',trim:'trim',strlen:'length',str_contains:'contains'};
      return { assign: m[1].replace(/^\$/, ''), target: m[3], op: opMap[m[2]] || m[2], arg: m[4] };
    }
    // Go strings.X()
    m = line.match(new RegExp(assignPat.source + 'strings\\.(ToUpper|ToLower|TrimSpace|Contains)\\((\\w+)(?:,\\s*"([^"]*)")?\\).*$'));
    if (m) {
      const opMap = {ToUpper:'upper',ToLower:'lower',TrimSpace:'trim',Contains:'contains'};
      return { assign: m[1].replace(/^\$/, ''), target: m[3], op: opMap[m[2]] || m[2], arg: m[4] };
    }
    return null;
  }

  const opMap = {
    upper:'upper',toUpperCase:'upper',ToUpper:'upper',upcase:'upper',uppercased:'upper',to_uppercase:'upper',strtoupper:'upper',
    lower:'lower',toLowerCase:'lower',ToLower:'lower',downcase:'lower',lowercased:'lower',to_lowercase:'lower',strtolower:'lower',
    trim:'trim',strip:'trim',Trim:'trim',TrimSpace:'trim',trimmingCharacters:'trim',
    length:'length',Length:'length',len:'length',count:'length',
    includes:'contains',Contains:'contains',contains:'contains','include?':'contains',str_contains:'contains'
  };
  const argMatch = line.match(/(?:includes|Contains|contains|include\?|str_contains)\s*\(\s*"([^"]*)"/);
  return { assign: m[1].replace(/^\$/, ''), target: m[2].replace(/^\$/, ''), op: opMap[m[3]] || m[3], arg: argMatch ? argMatch[1] : undefined };
}

function emitStringOp(so, tgt) {
  const a = tgt === 'ruby' || tgt === 'python' ? toSnake(so.assign) : toCamel(so.assign);
  const t = tgt === 'php' ? '$' + so.target : (tgt === 'ruby' || tgt === 'python' ? toSnake(so.target) : toCamel(so.target));
  const decl = tgt === 'javascript' || tgt === 'typescript' ? 'const ' : (tgt === 'go' ? '' : (tgt === 'rust' ? 'let ' : (tgt === 'java' || tgt === 'csharp' ? 'var ' : (tgt === 'swift' ? 'let ' : ''))));
  const assign = tgt === 'go' ? ' := ' : ' = ';
  const s = semi(tgt);

  switch (so.op) {
    case 'upper':
      switch (tgt) {
        case 'python': return a + ' = ' + t + '.upper()';
        case 'javascript': case 'typescript': return decl + a + ' = ' + t + '.toUpperCase()' + s;
        case 'go': return a + ' := strings.ToUpper(' + t + ')';
        case 'rust': return 'let ' + toSnake(so.assign) + ' = ' + toSnake(so.target) + '.to_uppercase()' + s;
        case 'java': return 'var ' + a + ' = ' + t + '.toUpperCase()' + s;
        case 'csharp': return 'var ' + a + ' = ' + t + '.ToUpper()' + s;
        case 'php': return '$' + so.assign + ' = strtoupper($' + so.target + ')' + s;
        case 'ruby': return toSnake(so.assign) + ' = ' + t + '.upcase';
        case 'swift': return 'let ' + a + ' = ' + t + '.uppercased()';
      }
      break;
    case 'lower':
      switch (tgt) {
        case 'python': return a + ' = ' + t + '.lower()';
        case 'javascript': case 'typescript': return decl + a + ' = ' + t + '.toLowerCase()' + s;
        case 'go': return a + ' := strings.ToLower(' + t + ')';
        case 'rust': return 'let ' + toSnake(so.assign) + ' = ' + toSnake(so.target) + '.to_lowercase()' + s;
        case 'java': return 'var ' + a + ' = ' + t + '.toLowerCase()' + s;
        case 'csharp': return 'var ' + a + ' = ' + t + '.ToLower()' + s;
        case 'php': return '$' + so.assign + ' = strtolower($' + so.target + ')' + s;
        case 'ruby': return toSnake(so.assign) + ' = ' + t + '.downcase';
        case 'swift': return 'let ' + a + ' = ' + t + '.lowercased()';
      }
      break;
    case 'trim':
      switch (tgt) {
        case 'python': return a + ' = ' + t + '.strip()';
        case 'javascript': case 'typescript': return decl + a + ' = ' + t + '.trim()' + s;
        case 'go': return a + ' := strings.TrimSpace(' + t + ')';
        case 'rust': return 'let ' + toSnake(so.assign) + ' = ' + toSnake(so.target) + '.trim()' + s;
        case 'java': return 'var ' + a + ' = ' + t + '.trim()' + s;
        case 'csharp': return 'var ' + a + ' = ' + t + '.Trim()' + s;
        case 'php': return '$' + so.assign + ' = trim($' + so.target + ')' + s;
        case 'ruby': return toSnake(so.assign) + ' = ' + t + '.strip';
        case 'swift': return 'let ' + a + ' = ' + t + '.trimmingCharacters(in: .whitespaces)';
      }
      break;
    case 'length':
      switch (tgt) {
        case 'python': return a + ' = len(' + t + ')';
        case 'javascript': case 'typescript': return decl + a + ' = ' + t + '.length' + s;
        case 'go': return a + ' := len(' + t + ')';
        case 'rust': return 'let ' + toSnake(so.assign) + ' = ' + toSnake(so.target) + '.len()' + s;
        case 'java': return 'var ' + a + ' = ' + t + '.length()' + s;
        case 'csharp': return 'var ' + a + ' = ' + t + '.Length' + s;
        case 'php': return '$' + so.assign + ' = strlen($' + so.target + ')' + s;
        case 'ruby': return toSnake(so.assign) + ' = ' + t + '.length';
        case 'swift': return 'let ' + a + ' = ' + t + '.count';
      }
      break;
    case 'contains':
      const arg = so.arg ? '"' + so.arg + '"' : '"..."';
      switch (tgt) {
        case 'python': return a + ' = ' + arg + ' in ' + t;
        case 'javascript': case 'typescript': return decl + a + ' = ' + t + '.includes(' + arg + ')' + s;
        case 'go': return a + ' := strings.Contains(' + t + ', ' + arg + ')';
        case 'rust': return 'let ' + toSnake(so.assign) + ' = ' + toSnake(so.target) + '.contains(' + arg + ')' + s;
        case 'java': return 'var ' + a + ' = ' + t + '.contains(' + arg + ')' + s;
        case 'csharp': return 'var ' + a + ' = ' + t + '.Contains(' + arg + ')' + s;
        case 'php': return '$' + so.assign + ' = str_contains($' + so.target + ', ' + arg + ')' + s;
        case 'ruby': return toSnake(so.assign) + ' = ' + t + '.include?(' + arg + ')';
        case 'swift': return 'let ' + a + ' = ' + t + '.contains(' + arg + ')';
      }
      break;
  }
  return a + assign + t + s;
}

/* ========== ARRAY OPERATIONS ========== */
function matchArrayOp(line, src) {
  let m;
  // Push/append
  const pushPatterns = {
    python: /^(\w+)\.append\((.+)\)$/,
    javascript: /^(\w+)\.push\((.+?)\);?$/,
    typescript: /^(\w+)\.push\((.+?)\);?$/,
    go: /^(\w+)\s*=\s*append\((\w+),\s*(.+?)\)$/,
    rust: /^(\w+)\.push\((.+?)\);?$/,
    java: /^(\w+)\.add\((.+?)\);?$/,
    csharp: /^(\w+)\.Add\((.+?)\);?$/,
    php: /^\$(\w+)\[\]\s*=\s*(.+?);?$/,
    ruby: /^(\w+)\.push\((.+?)\)$/,
    swift: /^(\w+)\.append\((.+?)\)$/
  };
  if (pushPatterns[src]) {
    m = line.match(pushPatterns[src]);
    if (m) {
      if (src === 'go') return { op: 'push', arr: m[1], value: m[3] };
      return { op: 'push', arr: m[1], value: m[2] };
    }
  }

  // Index access (assign)
  const assignPat = /^(?:(?:const|let|var|final|readonly)\s+)?(?:(?:\w[\w<>\[\]*]*)\s+)?(\$?\w+)(?::\s*[\w\[\]<>]+)?\s*=\s*/;
  // items[0]
  m = line.match(new RegExp(assignPat.source + '(?:&?)(\\$?\\w+)\\[(\\d+)\\].*$'));
  if (m) return { op: 'index', assign: m[1].replace(/^\$/, ''), arr: m[2].replace(/^\$/, ''), index: m[3] };
  // items.get(0) (Java)
  m = line.match(new RegExp(assignPat.source + '(\\w+)\\.get\\((\\d+)\\).*$'));
  if (m) return { op: 'index', assign: m[1].replace(/^\$/, ''), arr: m[2], index: m[3] };

  // Slice
  // Python: items[1:3]
  m = line.match(new RegExp(assignPat.source + '(\\$?\\w+)\\[(\\d+):(\\d+)\\].*$'));
  if (m) return { op: 'slice', assign: m[1].replace(/^\$/, ''), arr: m[2].replace(/^\$/, ''), start: m[3], end: m[4] };
  // JS: items.slice(1, 3)
  m = line.match(new RegExp(assignPat.source + '(\\w+)\\.slice\\((\\d+),\\s*(\\d+)\\).*$'));
  if (m) return { op: 'slice', assign: m[1].replace(/^\$/, ''), arr: m[2], start: m[3], end: m[4] };
  // Java: items.subList(1, 3)
  m = line.match(new RegExp(assignPat.source + '(\\w+)\\.subList\\((\\d+),\\s*(\\d+)\\).*$'));
  if (m) return { op: 'slice', assign: m[1].replace(/^\$/, ''), arr: m[2], start: m[3], end: m[4] };
  // C#: items.GetRange(1, 2)
  m = line.match(new RegExp(assignPat.source + '(\\w+)\\.GetRange\\((\\d+),\\s*(\\d+)\\).*$'));
  if (m) return { op: 'slice', assign: m[1].replace(/^\$/, ''), arr: m[2], start: m[3], end: String(parseInt(m[3]) + parseInt(m[4])) };
  // PHP: array_slice($items, 1, 2)
  m = line.match(new RegExp(assignPat.source + 'array_slice\\(\\$?(\\w+),\\s*(\\d+),\\s*(\\d+)\\).*$'));
  if (m) return { op: 'slice', assign: m[1].replace(/^\$/, ''), arr: m[2], start: m[3], end: String(parseInt(m[3]) + parseInt(m[4])) };
  // Ruby: items[1..2]
  m = line.match(new RegExp(assignPat.source + '(\\w+)\\[(\\d+)\\.\\.(\\d+)\\].*$'));
  if (m) return { op: 'slice', assign: m[1].replace(/^\$/, ''), arr: m[2], start: m[3], end: String(parseInt(m[4]) + 1) };
  // Swift: Array(items[1...2])
  m = line.match(new RegExp(assignPat.source + 'Array\\((\\w+)\\[(\\d+)\\.\\.\\.(\\d+)\\]\\).*$'));
  if (m) return { op: 'slice', assign: m[1].replace(/^\$/, ''), arr: m[2], start: m[3], end: String(parseInt(m[4]) + 1) };
  // Rust: &items[1..3]
  m = line.match(new RegExp(assignPat.source + '&(\\w+)\\[(\\d+)\\.\\.(\\d+)\\].*$'));
  if (m) return { op: 'slice', assign: m[1].replace(/^\$/, ''), arr: m[2], start: m[3], end: m[4] };

  // Length/size
  m = line.match(new RegExp(assignPat.source + 'len\\((\\$?\\w+)\\).*$'));
  if (m) return { op: 'length', assign: m[1].replace(/^\$/, ''), arr: m[2].replace(/^\$/, '') };
  m = line.match(new RegExp(assignPat.source + '(\\$?\\w+)\\.(length|Length|size|count|Count|len)(?:\\(\\))?.*$'));
  if (m) return { op: 'length', assign: m[1].replace(/^\$/, ''), arr: m[2].replace(/^\$/, '') };
  m = line.match(new RegExp(assignPat.source + 'count\\(\\$?(\\w+)\\).*$'));
  if (m) return { op: 'length', assign: m[1].replace(/^\$/, ''), arr: m[2] };

  return null;
}

function emitArrayOp(ao, tgt) {
  const s = semi(tgt);
  const arr = tgt === 'php' ? '$' + ao.arr : (tgt === 'ruby' || tgt === 'python' ? toSnake(ao.arr) : toCamel(ao.arr));

  if (ao.op === 'push') {
    const v = ao.value.replace(/;$/, '').replace(/^\$/, '');
    switch (tgt) {
      case 'python': return toSnake(ao.arr) + '.append(' + v + ')';
      case 'javascript': case 'typescript': return toCamel(ao.arr) + '.push(' + v + ')' + s;
      case 'go': return ao.arr + ' = append(' + ao.arr + ', ' + v + ')';
      case 'rust': return toSnake(ao.arr) + '.push(' + v + ')' + s;
      case 'java': return toCamel(ao.arr) + '.add(' + v + ')' + s;
      case 'csharp': return toCamel(ao.arr) + '.Add(' + v + ')' + s;
      case 'php': return '$' + ao.arr + '[] = ' + v + s;
      case 'ruby': return toSnake(ao.arr) + '.push(' + v + ')';
      case 'swift': return toCamel(ao.arr) + '.append(' + v + ')';
    }
  }

  const a = tgt === 'ruby' || tgt === 'python' ? toSnake(ao.assign) : toCamel(ao.assign);
  const decl = tgt === 'javascript' || tgt === 'typescript' ? 'const ' : (tgt === 'go' ? '' : (tgt === 'rust' ? 'let ' : (tgt === 'java' || tgt === 'csharp' ? 'var ' : (tgt === 'swift' ? 'let ' : ''))));
  const assign = tgt === 'go' ? ' := ' : ' = ';

  if (ao.op === 'index') {
    switch (tgt) {
      case 'java': return decl + a + assign + arr + '.get(' + ao.index + ')' + s;
      default: return decl + a + assign + arr + '[' + ao.index + ']' + s;
    }
  }

  if (ao.op === 'slice') {
    switch (tgt) {
      case 'python': return a + ' = ' + arr + '[' + ao.start + ':' + ao.end + ']';
      case 'javascript': case 'typescript': return decl + a + ' = ' + arr + '.slice(' + ao.start + ', ' + ao.end + ')' + s;
      case 'go': return a + ' := ' + arr + '[' + ao.start + ':' + ao.end + ']';
      case 'rust': return 'let ' + toSnake(ao.assign) + ' = &' + toSnake(ao.arr) + '[' + ao.start + '..' + ao.end + ']' + s;
      case 'java': return decl + a + assign + arr + '.subList(' + ao.start + ', ' + ao.end + ')' + s;
      case 'csharp': return decl + a + assign + arr + '.GetRange(' + ao.start + ', ' + (parseInt(ao.end) - parseInt(ao.start)) + ')' + s;
      case 'php': return '$' + ao.assign + ' = array_slice($' + ao.arr + ', ' + ao.start + ', ' + (parseInt(ao.end) - parseInt(ao.start)) + ')' + s;
      case 'ruby': return toSnake(ao.assign) + ' = ' + arr + '[' + ao.start + '..' + (parseInt(ao.end) - 1) + ']';
      case 'swift': return 'let ' + a + ' = Array(' + arr + '[' + ao.start + '...' + (parseInt(ao.end) - 1) + '])';
    }
  }

  if (ao.op === 'length') {
    switch (tgt) {
      case 'python': return a + ' = len(' + arr + ')';
      case 'javascript': case 'typescript': return decl + a + ' = ' + arr + '.length' + s;
      case 'go': return a + ' := len(' + arr + ')';
      case 'rust': return 'let ' + toSnake(ao.assign) + ' = ' + toSnake(ao.arr) + '.len()' + s;
      case 'java': return decl + a + assign + arr + '.size()' + s;
      case 'csharp': return decl + a + assign + arr + '.Count' + s;
      case 'php': return '$' + ao.assign + ' = count($' + ao.arr + ')' + s;
      case 'ruby': return toSnake(ao.assign) + ' = ' + arr + '.length';
      case 'swift': return 'let ' + a + ' = ' + arr + '.count';
    }
  }

  return '// Could not convert array operation';
}

/* ========== FUNCTION CALLS ========== */
function matchFunctionCall(line, src) {
  let m;
  if (src === 'php') {
    m = line.match(/^(\w+)\((.*)?\)\s*;?$/);
  } else {
    m = line.match(/^(\w+)\((.*)?\)\s*;?$/);
  }
  if (m && !['if','for','while','switch','catch','foreach','elseif'].includes(m[1])) {
    return { name: m[1], args: m[2] || '' };
  }
  // Swift labeled call: greet(name: "ANIMA")
  if (src === 'swift') {
    m = line.match(/^(\w+)\((.+?)\)$/);
    if (m) return { name: m[1], args: m[2].replace(/\w+:\s*/g, '') };
  }
  return null;
}

function emitFunctionCall(fc, tgt) {
  const name = tgt === 'ruby' || tgt === 'python' ? toSnake(fc.name) : (tgt === 'csharp' ? capitalize(fc.name) : toCamel(fc.name));
  const args = fc.args.replace(/\$(\w+)/g, '$1').replace(/;$/, '');
  switch (tgt) {
    case 'python': return name + '(' + args + ')';
    case 'javascript': case 'typescript': return name + '(' + args + ');';
    case 'go': return name + '(' + args + ')';
    case 'rust': return name + '(' + args + ');';
    case 'java': return name + '(' + args + ');';
    case 'csharp': return name + '(' + args + ');';
    case 'php': return name + '(' + args + ');';
    case 'ruby': return name + '(' + args + ')';
    case 'swift': return name + '(' + args + ')';
  }
  return name + '(' + args + ')' + semi(tgt);
}

/* ========== INCREMENT ========== */
function emitIncrement(name, op, tgt) {
  const n = tgt === 'php' ? '$' + name : (tgt === 'ruby' || tgt === 'python' ? toSnake(name) : toCamel(name));
  const val = op === '++' ? '1' : '1';
  const sign = op === '++' ? '+=' : '-=';
  switch (tgt) {
    case 'python': return n + ' ' + sign + ' ' + val;
    case 'ruby': return n + ' ' + sign + ' ' + val;
    case 'go': return n + op;
    default: return n + op + semi(tgt);
  }
}

/* ========== COMPOUND ASSIGN ========== */
function emitCompoundAssign(name, op, value, tgt) {
  const n = tgt === 'php' ? '$' + name : (tgt === 'ruby' || tgt === 'python' ? toSnake(name) : toCamel(name));
  return n + ' ' + op + ' ' + value.replace(/;$/, '').replace(/^\$/, '') + semi(tgt);
}

/* ========== BLOCK DELIMITERS ========== */
function convertBlockDelimiter(delim, src, tgt) {
  if (delim === 'end') {
    if (needsBraces(tgt)) return '}';
    return 'end';
  }
  if (delim === '?>') return '';
  if (delim === '{' && !needsBraces(tgt)) return '';
  if (delim === '}') {
    if (!needsBraces(tgt)) return 'end';
    return '}';
  }
  return delim;
}

/* ========== ADAPT SYNTAX (fallback) ========== */
function adaptSyntax(line, src, tgt) {
  let l = line;
  // Remove semicolons for non-semicolon languages
  if (!needsSemicolon(tgt)) l = l.replace(/;$/, '');
  // Add semicolons for semicolon languages
  if (needsSemicolon(tgt) && !l.endsWith(';') && !l.endsWith('{') && !l.endsWith('}') && !l.endsWith(':') && l.trim() !== '') {
    if (!l.match(/^(if|else|for|while|switch|case|func|fn|def|class|\/\/|#|\/\*)/)) {
      l = l + ';';
    }
  }
  // Remove PHP $
  if (src === 'php') l = l.replace(/\$(\w+)/g, '$1');
  // Add PHP $
  if (tgt === 'php') {
    l = l.replace(/(?<!\$)\b([a-z]\w*)\b(?!\s*\()/g, function(match) {
      if (['echo','print','return','if','else','elseif','for','foreach','while','function','class','new','true','false','null','as','in','array','count','strlen','strtoupper','strtolower','trim','str_contains','array_slice'].includes(match)) return match;
      return '$' + match;
    });
  }
  return l;
}

/* ========== POST-PROCESS ========== */
function postProcess(lines, src, tgt) {
  let result = lines.join('\n');
  // Clean up double braces from elseif conversion
  result = result.replace(/\}\s*\n\s*\} else/g, '} else');
  // Clean up empty lines with just braces
  result = result.replace(/\n{3,}/g, '\n\n');
  return result;
}

/* ========== NAMING UTILS ========== */
function toCamel(s) {
  return s.replace(/_([a-z])/g, (_, c) => c.toUpperCase());
}

function toSnake(s) {
  return s.replace(/[A-Z]/g, c => '_' + c.toLowerCase()).replace(/^_/, '');
}

function capitalize(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

/* ========== SYNTAX HIGHLIGHTING ========== */
function highlightCode(code, lang) {
  const escaped = code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  const lines = escaped.split('\n');
  const highlighted = lines.map(line => {
    let l = line;
    // Comments
    if (['python', 'ruby'].includes(lang)) {
      l = l.replace(/(#.*)$/, '<span class="hl-cm">$1</span>');
    } else {
      l = l.replace(/(\/\/.*)$/, '<span class="hl-cm">$1</span>');
    }
    // Strings
    l = l.replace(/("(?:[^"\\]|\\.)*")/g, '<span class="hl-str">$1</span>');
    l = l.replace(/('(?:[^'\\]|\\.)*')/g, '<span class="hl-str">$1</span>');
    l = l.replace(/(`(?:[^`\\]|\\.)*`)/g, '<span class="hl-str">$1</span>');
    // Numbers
    l = l.replace(/\b(\d+\.?\d*)\b/g, '<span class="hl-num">$1</span>');
    // Keywords
    const keywords = getKeywords(lang);
    keywords.forEach(kw => {
      l = l.replace(new RegExp('\\b(' + kw + ')\\b', 'g'), '<span class="hl-kw">$1</span>');
    });
    // Types
    const types = getTypes(lang);
    types.forEach(t => {
      l = l.replace(new RegExp('\\b(' + t + ')\\b', 'g'), '<span class="hl-type">$1</span>');
    });
    return l;
  });
  return highlighted.join('\n');
}

function getKeywords(lang) {
  const kw = {
    python: ['def', 'class', 'if', 'elif', 'else', 'for', 'while', 'return', 'import', 'from', 'in', 'not', 'and', 'or', 'is', 'None', 'True', 'False', 'with', 'as', 'try', 'except', 'finally', 'raise', 'pass', 'break', 'continue', 'lambda', 'yield', 'range', 'print', 'len'],
    javascript: ['function', 'const', 'let', 'var', 'if', 'else', 'for', 'while', 'return', 'import', 'export', 'from', 'of', 'in', 'new', 'this', 'class', 'extends', 'true', 'false', 'null', 'undefined', 'try', 'catch', 'finally', 'throw', 'async', 'await', 'switch', 'case', 'break', 'continue', 'typeof', 'instanceof'],
    typescript: ['function', 'const', 'let', 'var', 'if', 'else', 'for', 'while', 'return', 'import', 'export', 'from', 'of', 'in', 'new', 'this', 'class', 'extends', 'implements', 'interface', 'type', 'enum', 'true', 'false', 'null', 'undefined', 'try', 'catch', 'finally', 'throw', 'async', 'await', 'as', 'switch', 'case', 'break', 'continue'],
    go: ['func', 'package', 'import', 'if', 'else', 'for', 'range', 'return', 'var', 'const', 'type', 'struct', 'interface', 'map', 'chan', 'go', 'defer', 'select', 'switch', 'case', 'break', 'continue', 'true', 'false', 'nil', 'append', 'len', 'make', 'new'],
    rust: ['fn', 'let', 'mut', 'if', 'else', 'for', 'while', 'loop', 'return', 'use', 'mod', 'pub', 'struct', 'enum', 'impl', 'trait', 'match', 'true', 'false', 'None', 'Some', 'Ok', 'Err', 'self', 'super', 'crate', 'as', 'in', 'ref', 'move', 'async', 'await', 'break', 'continue', 'where'],
    java: ['public', 'private', 'protected', 'static', 'final', 'class', 'interface', 'extends', 'implements', 'if', 'else', 'for', 'while', 'return', 'new', 'this', 'super', 'try', 'catch', 'finally', 'throw', 'throws', 'import', 'package', 'true', 'false', 'null', 'switch', 'case', 'break', 'continue', 'void', 'abstract', 'synchronized'],
    csharp: ['public', 'private', 'protected', 'static', 'readonly', 'class', 'interface', 'struct', 'enum', 'if', 'else', 'for', 'foreach', 'while', 'return', 'new', 'this', 'base', 'try', 'catch', 'finally', 'throw', 'using', 'namespace', 'true', 'false', 'null', 'switch', 'case', 'break', 'continue', 'void', 'var', 'abstract', 'override', 'virtual', 'async', 'await', 'in'],
    php: ['function', 'if', 'else', 'elseif', 'for', 'foreach', 'while', 'return', 'echo', 'print', 'class', 'extends', 'implements', 'new', 'public', 'private', 'protected', 'static', 'true', 'false', 'null', 'try', 'catch', 'finally', 'throw', 'use', 'namespace', 'switch', 'case', 'break', 'continue', 'as', 'array', 'require', 'include'],
    ruby: ['def', 'end', 'class', 'module', 'if', 'elsif', 'else', 'unless', 'for', 'while', 'until', 'do', 'return', 'require', 'include', 'extend', 'true', 'false', 'nil', 'self', 'super', 'begin', 'rescue', 'ensure', 'raise', 'yield', 'block_given', 'puts', 'print', 'each', 'map', 'select', 'in'],
    swift: ['func', 'let', 'var', 'if', 'else', 'for', 'while', 'return', 'import', 'class', 'struct', 'enum', 'protocol', 'extension', 'true', 'false', 'nil', 'self', 'super', 'try', 'catch', 'throw', 'guard', 'switch', 'case', 'break', 'continue', 'in', 'where', 'async', 'await', 'print']
  };
  return kw[lang] || [];
}

function getTypes(lang) {
  const types = {
    python: ['int', 'float', 'str', 'bool', 'list', 'dict', 'tuple', 'set', 'bytes'],
    javascript: ['Array', 'Object', 'String', 'Number', 'Boolean', 'Promise', 'Map', 'Set'],
    typescript: ['string', 'number', 'boolean', 'any', 'void', 'never', 'unknown', 'Array', 'Promise', 'Record', 'Partial', 'Required', 'Readonly'],
    go: ['int', 'int8', 'int16', 'int32', 'int64', 'uint', 'float32', 'float64', 'string', 'bool', 'byte', 'rune', 'error', 'interface'],
    rust: ['i8', 'i16', 'i32', 'i64', 'i128', 'u8', 'u16', 'u32', 'u64', 'u128', 'f32', 'f64', 'bool', 'char', 'str', 'String', 'Vec', 'Option', 'Result', 'Box'],
    java: ['int', 'long', 'float', 'double', 'boolean', 'char', 'byte', 'short', 'String', 'Integer', 'Long', 'Float', 'Double', 'Boolean', 'List', 'ArrayList', 'Map', 'HashMap', 'Set', 'Object', 'void'],
    csharp: ['int', 'long', 'float', 'double', 'decimal', 'bool', 'char', 'byte', 'string', 'object', 'void', 'List', 'Dictionary', 'HashSet', 'Array', 'Task', 'var'],
    php: ['int', 'float', 'string', 'bool', 'array', 'object', 'null', 'void', 'mixed', 'callable'],
    ruby: ['Integer', 'Float', 'String', 'Array', 'Hash', 'Symbol', 'NilClass', 'TrueClass', 'FalseClass'],
    swift: ['Int', 'Float', 'Double', 'String', 'Bool', 'Array', 'Dictionary', 'Set', 'Optional', 'Any', 'Void']
  };
  return types[lang] || [];
}

/* ========== TOAST ========== */
function showToast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 2000);
}

/* Tab key support */
codeInput.addEventListener('keydown', e => {
  if (e.key === 'Tab') {
    e.preventDefault();
    const start = codeInput.selectionStart, end = codeInput.selectionEnd;
    codeInput.value = codeInput.value.substring(0, start) + '  ' + codeInput.value.substring(end);
    codeInput.selectionStart = codeInput.selectionEnd = start + 2;
  }
});

/* Ctrl+Enter to convert */
codeInput.addEventListener('keydown', e => {
  if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
    e.preventDefault();
    convertCode();
  }
});

/* IntersectionObserver fade-in */
const observer = new IntersectionObserver(entries => {
  entries.forEach(entry => { if (entry.isIntersecting) { entry.target.classList.add('visible'); observer.unobserve(entry.target); }});
}, { threshold: 0.1 });
document.querySelectorAll('.fade-in').forEach(el => observer.observe(el));
</script>
<script src="/js/analytics-lite.js" defer></script>
<script src="/js/revenue.js" defer></script>
<script src="/js/lead-capture.js" defer></script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "FAQPage",
  "mainEntity": [
    {
      "@type": "Question",
      "name": "What is a code converter?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "A code converter is a tool that translates source code from one programming language to another. ANIMA's Code Converter uses pattern-based rules to convert common constructs like variable declarations, functions, loops, conditionals, and string operations between 10 popular languages."
      }
    },
    {
      "@type": "Question",
      "name": "Which programming languages does this converter support?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "The converter supports Python, JavaScript, TypeScript, Go, Rust, Java, C#, PHP, Ruby, and Swift. It handles common patterns including variable declarations, function definitions, loops, conditionals, print statements, string operations, array operations, and comments."
      }
    },
    {
      "@type": "Question",
      "name": "Is this code converter accurate?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "This is a pattern-based converter that handles common code patterns well. It works best for straightforward code snippets with standard constructs. Complex code with advanced language-specific features, frameworks, or libraries may need manual review after conversion."
      }
    },
    {
      "@type": "Question",
      "name": "Is my code sent to a server?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "No. All conversion happens entirely in your browser using JavaScript. Your code never leaves your device. There is no server-side processing, no data collection, and no signup required."
      }
    },
    {
      "@type": "Question",
      "name": "Can I convert Python to JavaScript with this tool?",
      "acceptedAnswer": {
        "@type": "Answer",
        "text": "Yes. Python to JavaScript is one of the most popular conversions. The tool converts Python functions (def), print statements, for/while loops, list operations, string methods, and variable assignments into their JavaScript equivalents with proper syntax including semicolons, braces, and console.log."
      }
    }
  ]
}
</script>
</body>
</html>